{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hacking to the gate! • All posts by \"进制转换\" tag",
    "description": "Bipedal Bit's blog",
    "home_page_url": "https://blog.bipedalbit.net",
    "items": [
        {
            "id": "https://blog.bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "url": "https://blog.bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "title": "C++二进制-十进制转换器",
            "date_published": "2015-10-08T14:05:52.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 布置了二进制-十进制转换器的小作业，本来还要求顺手扩展一下大数的四则运算，我嫌麻烦没做扩展，就只是写来玩玩。也算熟悉一下底层的二进制-十进制转换机制，顺便复习下C++源码规范。注释写了很多，就不多做解释了，只贴代码。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; converter.h:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#ifndef _CONVERTER_H_\n#define _CONVERTER_H_\n\n#include &lt;string&gt;\n\n/*\n * This is a class to offer operations converting radix of number in string.\n */\nclass Converter\n&#123;\nprivate:\n\t/* to store the binary form of picked up number string */\n\tstd::string binVal;\n\t/* to store the decimal form of picked up number string */\n\tstd::string decVal;\n\t/* to sign the number by marking wether it is negtive */\n\tbool negtive;\n\t/* to mark wether the number has a dot */\n\tbool hasDot;\n\t/* to store the index of dot in binary number string */\n\tint binDotIndex;\n\t/* to store the index of dot in decimal number string */\n\tint decDotIndex;\n\t/* max reserved digits sum when float converted from decimal to binary */\n\tint binFloatPrecision;\n\t/*\n\t * Convert the binary number to decimal form then fill this-&gt;decVal.\n\t */\n\tvoid bin2Dec();\n\t/*\n\t * Convert the decimal number to binary form then fill this-&gt;binVal.\n\t */\n\tvoid dec2Bin();\npublic:\n\t/*\n\t * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n\t */\n\tConverter(std::string str, int radix, int binFloatPrecision = 20);\n\t/*\n\t * Get the the number string with specified radix.\n\t */\n\tstd::string getNum(int radix);\n&#125;;\n\n#endif\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; converter.cpp:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n #include &quot;converter.h&quot;\n #include &lt;iostream&gt;\n #include &lt;stdexcept&gt;\n\n/*\n * name: Converter\n * args:\n *\tstring str: the original string containing target number\n *\tint radix: the radix of the number to pick up form str\n *\tint binFloatPrecision: max reserved digits sum when float converted from decimal to binary\n *\t\twhose default value is 20\n * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n */\n Converter::Converter(std::string str, int radix, int binFloatPrecision)\n&#123;\n\t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* check binFloatPrecision */\n\tif (binFloatPrecision &lt; 1)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: binFloatPrecision should be greater than 0.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* fill this-&gt;binFloatPrecision */\n\tthis-&gt;binFloatPrecision = binFloatPrecision;\n\t/* assistant variables for traversing the original string */\n\tint len = str.size();\n\tint i = 0;\n\t/* mark wether there&#39;s a dot in the number */\n\tbool hasDot = false;\n\t/* store number string temporarily */\n\tstd::string tmp = &quot;&quot;;\n\tif (len &gt; 0)\n\t&#123;\n\t\t/* handle binary radix */\n\t\tif (radix == 2)\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get &#39;0&#39;s and &#39;1&#39;s only */\n\t\t\t\tif (str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\t/* handle decimal radix */\n\t\telse\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; !(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get all arabic numerals */\n\t\t\t\tif(!(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t/* if no number picked up set 0 */\n\tif(tmp == &quot;&quot;)\n\t&#123;\n\t\ttmp = &quot;0&quot;;\n\t&#125;\n\t/* add &#39;0&#39; if necessary */\n\tif (tmp[0] == &#39;.&#39;)\n\t&#123;\n\t\ttmp = &#39;0&#39; + tmp;\n\t&#125;\n\t/* mark wether the number has a dot */\n\tthis-&gt;hasDot = hasDot;\n\t/* fill corresponding number form */\n\tif (radix == 2)\n\t&#123;\n\t\tthis-&gt;binVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of binary form */\n\t\t\tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tbin2Dec();\n\t&#125;\n\telse\n\t&#123;\n\t\tthis-&gt;decVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of decimal form */\n\t\t\tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tdec2Bin();\n\t&#125;\n\t/* have a test */\n/*\n\tstd::cout &lt;&lt; &quot;radix: 2&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;binVal &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; &quot;radix: 10&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;decVal &lt;&lt; std::endl;\n*/\n&#125;\n\n/*\n * name: getNum\n * arguments:\n *\tint radix: spedify a radix to find which form number is to got\n * return: the number string with specified form\n * access: public\n * Get the the number string with specified radix.\n */\n std::string Converter::getNum(int radix)\n &#123;\n \t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn NULL;\n\t&#125;\n \tstd::string tmp = &quot;&quot;;\n \t/* add the &#39;-&#39; character if necessary */\n \tif (this-&gt;negtive)\n \t&#123;\n \t\ttmp += &#39;-&#39;;\n \t&#125;\n \t/* add the binary form number */\n \tif (radix == 2)\n \t&#123;\n \t\ttmp += this-&gt;binVal;\n \t&#125;\n \t/* add the decimal form number */\n \telse\n \t&#123;\n \t\ttmp += this-&gt;decVal;\n \t&#125;\n \treturn tmp;\n &#125;\n\n/*\n * name: bin2Dec\n * access: private\n * Convert the binary number to decimal form then fill this-&gt;decVal.\n */\n void Converter::bin2Dec()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the binary number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;binDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;binVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint decLen;\n \t/* convert radix digit by digit while traversing the int part of the binary number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new binary digit into carry */\n \t\tcarry += this-&gt;binVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tdecLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 2 and add carries */\n \t\tfor(int j = decLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\ttmp[j] = tmp[j]*2+carry;\n \t\t\tif (tmp[j] &gt; 9)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/10;\n \t\t\t\t/* limit digit within 10 */\n \t\t\t\ttmp[j] %= 10;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%10)+tmp;\n \t\t\tcarry /= 10;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* get the length except the float part */\n \t\tint decIntLen = tmp.size();\n \t\t/* get the length of the whole binary number string */\n \t\tint binLen = this-&gt;binVal.size();\n \t\t/* convert radix digit by digit while traversing the float part of the binary number string */\n \t\tfor(int i = binLen-1 ; i &gt; intLen ; i--)\n \t\t&#123;\n \t\t\t/* carry to first float digit if occur a &#39;1&#39; */\n \t\t\tcarry = (this-&gt;binVal[i] == &#39;1&#39; ? 5 : 0);\n \t\t\t/* update tmp&#39;s length */\n \t\t\tdecLen = tmp.size();\n \t\t\t/* traverse tmp to divide each digit by 2 and add carries */\n \t\t\tfor(int j = decIntLen ; j &lt; decLen ; j++)\n \t\t\t&#123;\n \t\t\t\tif (tmp[j] &amp; 1)\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 5;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* expand digit if necessary */\n \t\t\tif (carry)\n \t\t\t&#123;\n \t\t\t\ttmp += carry;\n \t\t\t&#125;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;decVal and this-&gt;decDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;decVal = tmp;\n \tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n\n/*\n * name: dec2Bin\n * access: private\n * Convert the decimal number to binary form then fill this-&gt;binVal.\n */\n void Converter::dec2Bin()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the decimal number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;decDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;decVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint binLen;\n \t/* convert radix digit by digit while traversing the int part of the decimal number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new decimal digit into carry */\n \t\tcarry += this-&gt;decVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tbinLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 10 and add carries */\n \t\tfor(int j = binLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\t/*\n \t\t\t * Type of tmp[] is char[] and MAX_CHAR = 127 &gt; 99.\n \t\t\t * So the assignment statement below will work safely.\n \t\t\t */\n \t\t\ttmp[j] = tmp[j]*10+carry;\n \t\t\tif (tmp[j] &gt; 1)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/2;\n \t\t\t\t/* limit digit within 2 */\n \t\t\t\ttmp[j] &amp;= 1;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%2)+tmp;\n \t\t\tcarry /= 2;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n\tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* may need carry while traversing digits */\n \t\tcarry = 0;\n \t\t/* get the length of the whole decimal number string */\n \t\tint decLen = this-&gt;decVal.size();\n \t\t/* get the length of the float part of the decimal number string */\n \t\tint floatLen = decLen-intLen-1;\n \t\t/* get a copy of the float part of the decimal number string */\n \t\tstd::string tmp2 = this-&gt;decVal.substr(intLen+1, floatLen);\n \t\t/* adjust tmp2 to prepare for algorithm below */\n \t\tfor(int i = 0 ; i &lt; floatLen ; i++)\n \t\t&#123;\n \t\t\ttmp2[i] -= &#39;0&#39;;\n \t\t&#125;\n \t\t/*\n \t\t * asume:   B = b1*2^-1 + b2*2^-2 + b3*2^-3 + ...\n \t\t *            2*B = b1 + b2*2^-1 + b3*2^-2 + ... \t// take b1 as first digit\n \t\t * 2*(2*B-b1) = b2 + b3*2^-1 + ... \t\t// take b2 as second digit\n \t\t * \t\t...\n \t\t * so the binary float will got digit by digit in order\n \t\t */\n \t\tfor(int i = 0 ; i &lt; this-&gt;binFloatPrecision ; i++)\n \t\t&#123;\n \t\t\t/* traverse tmp2 to multiply each digit by 2 and add carries */\n \t\t\tfor(int j = floatLen-1 ; j &gt;= 0 ; j--)\n \t\t\t&#123;\n \t\t\t\ttmp2[j] = tmp2[j]*2+carry;\n \t\t\t\tif (tmp2[j] &gt; 9)\n \t\t\t\t&#123;\n \t\t\t\t\t/* update carry */\n \t\t\t\t\tcarry = tmp2[j]/10;\n \t\t\t\t\t/* limit digit within 10 */\n \t\t\t\t\ttmp2[j] %= 10;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* get the last carry as new digit of binary float */\n \t\t\ttmp += carry;\n \t\t\t/* reset carry */\n \t\t\tcarry = 0;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;binVal and this-&gt;binDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;binVal = tmp;\n \tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; test.cpp:</p>\n<pre><code class=\"hljs\">#include &quot;converter.h&quot;\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\t//Converter c(&quot;0.625&quot;, 10);\n\tConverter c(&quot;ujsgdfksagrua0.10100000000000000000&quot;, 2);\n\tcout &lt;&lt; c.getNum(10) &lt;&lt; endl;\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 都过500行了，会不会写得有点啰嗦？</p>\n",
            "tags": [
                "C++",
                "进制转换"
            ]
        }
    ]
}