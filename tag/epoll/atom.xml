<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.bipedalbit.net</id>
    <title>Hacking to the gate! • Posts by &#34;epoll&#34; tag</title>
    <link href="https://blog.bipedalbit.net" />
    <updated>2015-07-23T03:01:28.000Z</updated>
    <category term="Qt" />
    <category term="signal-slot" />
    <category term="Q_OBJECT" />
    <category term="nginx" />
    <category term="select/poll" />
    <category term="epoll" />
    <category term="ngx_int_t" />
    <category term="rbtree" />
    <category term="C" />
    <category term="static" />
    <category term="内存分布" />
    <category term="sublime" />
    <category term="C++" />
    <category term="makefile" />
    <category term="node.js" />
    <category term="github" />
    <category term="socket.io" />
    <category term="Web请求处理机制" />
    <category term="同步/异步" />
    <category term="阻塞/非阻塞" />
    <category term="事件驱动模型" />
    <category term="BP神经网络" />
    <category term="机器学习" />
    <category term="python" />
    <category term="pybrain" />
    <category term="c++11" />
    <category term="多线程" />
    <category term="ubuntu" />
    <category term="debian" />
    <category term="apt-file" />
    <category term="cin" />
    <category term="cout" />
    <category term="scanf" />
    <category term="printf" />
    <category term="进制转换" />
    <category term="人工神经网络" />
    <category term="人机博弈" />
    <category term="Maxmin" />
    <category term="AlphaBeta" />
    <category term="PVS" />
    <category term="MTD(f)" />
    <category term="位域" />
    <category term="bitset" />
    <category term="vector&amp;lt;bool&amp;gt;" />
    <category term="网络爬虫" />
    <category term="类脑" />
    <category term="codeigniter" />
    <category term="php" />
    <category term="IIS7" />
    <category term="apache" />
    <category term="模拟登录" />
    <category term="proxy" />
    <category term="domain" />
    <category term="DNS" />
    <category term="hexo" />
    <category term="vps" />
    <category term="dropbox" />
    <category term="ffmpeg" />
    <category term="板绘" />
    <category term="sai" />
    <category term="琪露诺" />
    <category term="LLM" />
    <category term="ollama" />
    <category term="open-webui" />
    <category term="oneapi" />
    <category term="mcpserver" />
    <category term="NAS" />
    <category term="minio" />
    <category term="CDN" />
    <category term="waline" />
    <entry>
        <id>https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%B8%80%E3%80%91nginx%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</id>
        <title>【一】nginx核心架构概述</title>
        <link rel="alternate" href="https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%B8%80%E3%80%91nginx%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
        <content type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 毕业前，毕设完成后，我闲极无聊接触了一下socket编程，用C++的Qt框架写了玩具一样的TCP和UDP通信客户端。跟直系学长电话聊天时被建议深挖一下socket，尝试走走后端或者架构师路线。问该怎么深挖，答研究源码，要学习socket相关知识，研究服务器源码是最合适不过的了。至于选择哪个服务器，经过考量调查，发现比起比较沉重庞大的apache，nginx更加小巧，也非常优秀。于是在开始正式吃源码之前，我先开始了一番自我科普工作。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h3 id=&#34;1、进程模型&#34;&gt;&lt;a href=&#34;#1、进程模型&#34; class=&#34;headerlink&#34; title=&#34;1、进程模型&#34;&gt;&lt;/a&gt;1&lt;span style=&#34;font-family:宋体;&#34;&gt;、进程模型&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 首先，默认的，与其他服务器一样，&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;Unix&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;下的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;也以&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;daemon&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（守护进程）的形式持续在后台运行。虽然&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;也可以以调试为目的关掉后台模式，使用前台模式，甚至可以通过配置取消&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程（后面会详细解释），使&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;以单进程的形式工作。但是这些与&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;引以为傲的架构关系不大，这里按下不表。尽管&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;也支持多线程方式，我们还是着重来了解下其默认的多进程方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nginx&lt;span style=&#34;font-family:宋体;&#34;&gt;在启动后会创建一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程（主进程）和若干个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程（从进程）。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程主要负责管理&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程，具体来说就是接收来自管理员的信号并转发给对应&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程；监控&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程的工作状态，在&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程异常终止时重新创建并启动&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程。而&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程负责处理基本的网络事件。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程之间优先级对等、相互独立，公平竞争来自客户端的请求，每个请求只由一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程处理。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程模型示意图如图&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;所示。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;
    &amp;nbsp;&lt;img src=&#34;http://img.blog.csdn.net/20150723104541689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&#34; alt=&#34;&#34; /&gt;
    图&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;1&amp;nbsp;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程模型示意图&lt;/span&gt;
&lt;/p&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; worker&lt;span style=&#34;font-family:宋体;&#34;&gt;进程的数量可以进行设置，一般设置与&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;核数一致，这一原则与&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的事件处理模型有关。后面会继续介绍&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的事件处理模型。&lt;/span&gt;
### 2&lt;span style=&#34;font-family:宋体;&#34;&gt;、信号与请求&lt;/span&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nginx&lt;span style=&#34;font-family:宋体;&#34;&gt;与外界互动无非通过两种接口界面：来自管理员的信号和来自客户端的请求。下面我们举例说明&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;是如何处理信号与请求的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 管理员要控制&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;需要与&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程通信，向&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程发送指令信号即可。比如，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;在&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;0.8&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;版本之前使用&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;kill&amp;nbsp;-HUP pid&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;命令来重启&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;。使用这个命令重启&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;将实现从容地重启过程，期间服务不中断。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程在接到&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;HUP&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;指令后首先会重新加载配置文件，然后启动新的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程，向旧的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程发送停止信号。这时新的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程开始接收网络请求，旧的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程停止接收新的请求，等到处理完当前请求后，旧的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程就退出销毁了。在&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;0.8&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;版本以后，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;引入了一系列命令行参数以方便管理服务器，比如&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;.&amp;#x2F;nginx&amp;nbsp;-s&amp;nbsp;reload&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;.&amp;#x2F;nginx&amp;nbsp;-s&amp;nbsp;stop&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，分别用来重启和停止&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;。执行操作命令时，我们实际上启动了一个新的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程，这个进程在解析命令中的参数后，自行向&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程发送相应的信号，达成与之前手动发送信号相同的效果。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;3、请求与事件&#34;&gt;&lt;a href=&#34;#3、请求与事件&#34; class=&#34;headerlink&#34; title=&#34;3、请求与事件&#34;&gt;&lt;/a&gt;3&lt;span style=&#34;font-family:宋体;&#34;&gt;、请求与事件&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 服务器最常处理的就是&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;80&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;端口&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;http&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;协议的请求了，&lt;/span&gt; 以此为例说明一下&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;处理请求的过程。首先，每一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程都是从&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;fork&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（分叉）而成的，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程中先建立好需要监听的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（套接字，即&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;IP&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;地址&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;端口号）和相应的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;listenfd&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（监听文件描述符或句柄）。我们知道&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;通信中每个进程都要分配一个端口号，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;分配工作就由&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程来完成。所有&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;listenfd&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;在新的连接到来时变得可读，为保证只有一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程处理连接，各&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程在注册&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;listenfd&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;读事件前先要抢&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;accept_mutex&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（接受连接互斥锁），一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程抢注连接成功后，开始读取请求、解析请求、处理请求并反馈数据给客户端。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;4、进程模型分析&#34;&gt;&lt;a href=&#34;#4、进程模型分析&#34; class=&#34;headerlink&#34; title=&#34;4、进程模型分析&#34;&gt;&lt;/a&gt;4&lt;span style=&#34;font-family:宋体;&#34;&gt;、进程模型分析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nginx&lt;span style=&#34;font-family:宋体;&#34;&gt;使用但不仅仅使用多进程请求处理模型（&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;PPC&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;），每个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程一次只处理一个请求，使得请求间资源独立不需要上锁，进程间互不影响能并行处理请求。一个请求处理失败导致一个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程异常退出，不会使服务中断，而是由&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;master&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程立刻重新启动一个新的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程，降低了服务器面临的整体风险，使服务更加稳定。但是相比多线程模型（&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;TPC&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;），系统开销略大，效率略低，这需要借助别的手段来改进。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;5、nginx的高并发机制——异步非阻塞事件机制&#34;&gt;&lt;a href=&#34;#5、nginx的高并发机制——异步非阻塞事件机制&#34; class=&#34;headerlink&#34; title=&#34;5、nginx的高并发机制——异步非阻塞事件机制&#34;&gt;&lt;/a&gt;5&lt;span style=&#34;font-family:宋体;&#34;&gt;、nginx的高并发机制&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;——&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;异步非阻塞事件机制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IIS&lt;span style=&#34;font-family:宋体;&#34;&gt;的事件处理机制是多线程，每个请求独占一个工作线程。由于多线程比较占用内存，线程间的上下文切换（反复的对寄存器组进行保护现场和恢复现场的操作）带来的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;开销也很大，多线程机制的服务器在面临数千并发量时，会给系统造成很大的压力，高并发性能并不算理想，当然如果硬件足够出色，能够提供足够的系统资源，系统压力也就不再是问题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我们深入到系统层面讨论一下多进程与多线程，阻塞式机制与非阻塞式机制的区别。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 熟悉操作系统的同学应该了解，多线程的出现是为了在资源充足的情况下更充分的调度使用&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，尤其对提高多核&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的利用率十分有益。但是线程是系统任务的最小单位，而进程却是系统分配资源的最小单位，这就意味着多线程将面临一个很大的问题：当线程数增多，资源需求变大，这些线程的母进程可能无法立即一口气申请到足够所有线程使用的资源，而当系统手里没有足够的资源满足一个进程时，它会选择让整个进程都等着。这时即使系统资源足够一部分线程正常工作，母进程也无法申请到这些资源，导致所有线程一起等待。直白的说，使用多线程，进程内的线程间可以灵活的进行调度（虽然增加了线程死锁的风险和线程切换的开销），但是却无法保证母进程在逐渐庞大沉重时还能够在系统中得到合理的调度。由此可见，多线程确实可以提高&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;利用率，但是并不是解决服务器高并发请求问题的理想解决方案，且不说在高并发状态下&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的高利用率也无法维持。以上是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;IIS&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的多线程阻塞式事件机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nginx&lt;span style=&#34;font-family:宋体;&#34;&gt;的多进程机制保证了每个请求独立申请系统资源，一旦满足条件，每一个请求都可以立即被处理，即非阻塞处理。但是创建进程需要的资源开销会比线程多一些，为了节约进程数，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;使用了一些进程调度算法，使&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;事件处理不仅仅靠多进程机制，而是非阻塞的多进程机制。下面我们就来具体的引入&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的异步非阻塞事件处理机制。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;6、epoll&#34;&gt;&lt;a href=&#34;#6、epoll&#34; class=&#34;headerlink&#34; title=&#34;6、epoll&#34;&gt;&lt;/a&gt;6&lt;span style=&#34;font-family:宋体;&#34;&gt;、epoll&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Linux&lt;span style=&#34;font-family:宋体;&#34;&gt;下，言高并发的高性能网络必&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;也正是使用了&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;模型作为网络事件的处理机制。我们先看看&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;是怎么来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 最早的调度方案是异步忙轮询方式，即持续的轮询&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;事件也就是遍历&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;集合的访问状态，显然服务器空闲时这一方案造成了无谓的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;开销。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 后来，&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;select&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;作为调度进程和提高&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;利用率的代理先后出现，字面上看，一个是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;选择&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;”&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，一个是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;投票&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;”&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，它们的本质相同，都是轮询&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;集合并处理请求，与之前不同的地方在于，它们能够监视&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;事件，空闲时轮询线程将被阻塞，而一个或多个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;事件到来时则被唤醒，摆脱了&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;忙轮询&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;”&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;忙&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;”&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，成为异步轮询方式。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;select&amp;#x2F;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;模型轮询的是整个&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;FD&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（文件描述符）集合即&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;集合，网络事件处理效率随着并发请求数线性降低，所以使用一个宏来限制最大并发连接数。同时，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;select&amp;#x2F;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;模型的内核空间与用户空间通信方式为内存复制，带来较高的开销。以上缺点催生了新模型的产生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; epoll&lt;span style=&#34;font-family:宋体;&#34;&gt;可以认为是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;event&amp;nbsp;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的简写，&lt;/span&gt;是&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;Linux&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;内核为处理大批量文件描述符而作了改进的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;Linux&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;下多路复用&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&lt;/span&gt;&amp;#x2F;O&lt;span style=&#34;font-family:宋体;&#34;&gt;接口&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;select&amp;#x2F;poll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;CPU&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;利用率。&lt;/span&gt;首先，&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;没有最大并发连接数的限制，上限是可以打开的最大文件数，这与硬件内存大小有关，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;1GB&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的机器上大约是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;10w&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;左右；然后是&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;最显著的优点，它只对&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;活跃&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;”&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进行操作，因为只有那些被内核&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;读写事件异步唤醒的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;才被放入&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;ready&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;队列，准备进入&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;worker&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;进程被处理，这在实际生产环境中节省了大量轮询开销，极大的提高了事件处理效率；最后，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;使用共享内存（&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;MMAP&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;）的方式实现内核空间与用户空间的通信，省掉了内存复制的开销。额外的，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;中使用&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;ET&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;（边缘触发）工作模式即快速工作模式。&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;ET&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;模式下，只支持非阻塞&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;FD&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;就绪即由内核通过&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;发送通知，经过某些操作使&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;FD&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;不再是就绪状态时也会发送通知，但如果一直没有&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;I&amp;#x2F;O&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;操作导致&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;FD&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;变为未就绪状态将不再发送通知。总的来说，&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;nginx&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;在&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;Linux&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;下是基于事件，利用&lt;/span&gt;&lt;span style=&#34;font-family:Times New Roman;&#34;&gt;epoll&lt;/span&gt;&lt;span style=&#34;font-family:宋体;&#34;&gt;处理网络事件的。&lt;/span&gt;&lt;/p&gt;
</content>
        <category term="nginx" />
        <category term="select/poll" />
        <category term="epoll" />
        <updated>2015-07-23T03:01:28.000Z</updated>
    </entry>
</feed>
