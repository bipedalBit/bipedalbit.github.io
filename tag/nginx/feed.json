{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hacking to the gate! • All posts by \"nginx\" tag",
    "description": "Bipedal Bit's blog",
    "home_page_url": "https://blog.bipedalbit.net",
    "items": [
        {
            "id": "https://blog.bipedalbit.net/2016/04/25/%E5%88%A9%E7%94%A8Dropbox%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E7%9A%84%E9%9D%99%E6%80%81%E7%AB%99/",
            "url": "https://blog.bipedalbit.net/2016/04/25/%E5%88%A9%E7%94%A8Dropbox%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E7%9A%84%E9%9D%99%E6%80%81%E7%AB%99/",
            "title": "利用Dropbox实现实时同步的静态站",
            "date_published": "2016-04-25T06:05:09.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 上个周末正在练习nginx静态站服务器功能的基本配置，忽然想到一个点子。既然我有现成的VPS可以用，而且只是用来搭ShadowSocks服务器科学上网用，不拿来做建站练习实在有点浪费。之前早就把VPS和手头各个平台上的ShadowSocks+Dropbox环境配好了，那为什么不干脆在VPS的Dropbox文件夹里建站呢？自动同步，多终端随处修改，应该会比Github Pages更方便。试了一下，结果亦可赛艇。</p>\n<span id=\"more\"></span>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><p>&nbsp;&nbsp;&nbsp; VPS的选择主要看需要，论国内访问速度当然还是BAT和新浪之类的国产云主机最好，但是如果你想顺便用来科学上网，那么就得选国外VPS服务商了。一般来说，提起国外的网络服务运营商，总是想起欧美的，尤其是美国的，然而事实上，日本的VPS产业也很发达。大名鼎鼎的<a href=\"https://www.linode.com/\">Linode</a>、<a href=\"https://www.conoha.jp/zh/\">Conoha</a>等服务商，因为机房离国内近，相对美国的VPS有了速度优势。最近可能意识到墙内市场的潜力，有的日本VPS服务明显做的很贴咱的心了，比如我选的<a href=\"https://www.z.com/\">z.com</a>，它就是Conoha重新套了个壳，900日元每月的开销不算便宜也不很贵，但是它能用支付宝结帐！</p>\n<h3 id=\"系统环境\"><a href=\"#系统环境\" class=\"headerlink\" title=\"系统环境\"></a>系统环境</h3><p>&nbsp;&nbsp;&nbsp; 要搭服务器，不论什么功能，稳定性是很重要的，虽然巨硬和IBM也分别有server产品，但是咱用不起，挑个Linux系统比较合适，至于Mac OS，你是要搭服务器，又不是要去星巴克。我Linux入门时选择的是最流行的发行版Ubuntu，于是VPS也挑了Ubuntu 14.04LTS的镜像，使用和练习都比较方便，上手快，国内大家爱用的还有CentOS和RedHat。就别选什么Desktop镜像了，DE占空间又浪费资源，就算有远程桌面，也没有必要用，SSH连接足矣。把公钥放Github，wget到服务器~&#x2F;.ssh目录，改个名叫authorized_keys就行，多个公钥可以都放authorized_keys里面，一个一行就好。</p>\n<h3 id=\"Dropbox\"><a href=\"#Dropbox\" class=\"headerlink\" title=\"Dropbox\"></a>Dropbox</h3><p>&nbsp;&nbsp;&nbsp; Dropbox是个云盘，跟国内遍地都是的云盘有几个不同点，首先是资历老，然后给的免费空间少（XDDDD），2GB，跨平台做得好，几乎所有系统平台都有客户端，最重要的是有一个文件实时同步功能（也许正是这个功能限制了免费空间的大小），最后，是的，国外的好东西一般是要被墙的，Dropbox也不例外。会科学上网的同学们可以各显神通去<a href=\"https://www.dropbox.com/\">官网</a>注册，下客户端试用一下。在VPS上装个Dropbox用来传文件简直方便，VPS网快，墙内下不动的东西也可以VPS下完从Dropbox拖回来。据说国内的金山快盘可以作为Dropbox的替代品，改天做个评测再发博文介绍下。别跟我提百度云，且不论它没有官方Linux客户端且免费空间太大，我对百度有偏见。<br>&nbsp;&nbsp;&nbsp; 这篇文用到的就是Dropbox的自动同步功能，在各个终端的Dropbox文件夹内，内容都与云端进行实时同步。既然是个文件夹，那么里面放一个静态站也没有什么不可以了，2GB绰绰有余。</p>\n<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><p>&nbsp;&nbsp;&nbsp; <a href=\"http://nginx.org/\">Nginx</a>读作engine X，是由Igor Sysoev（俄罗斯籍）为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。主要功能为静态网站的服务器、多服务端的负载均衡服务器即反向代理服务器。配置简单、高效、轻。既然是做静态站，我首选了Nginx作为服务器，Apache有点笨重，不做动态站就先不装了。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>&nbsp;&nbsp;&nbsp; 做什么样的静态站呢？这次直接把我的Hexo博客拿来做实验。<a href=\"https://bipedalbit.net/2016/4/24/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">上篇文</a>提到过，Hexo是个静态博客站生成器，<code>hexo g</code>命令执行后，Hexo项目目录的public子目录下就是静态站的确切内容了。可以干脆把Hexo项目目录放在Dropbox文件夹中，每次<code>hexo g</code>之后，自动更新静态站内容，同时Dropbox自动把静态站同步到VPS，VPS的Nginx不需要更改配置因为地址映射没有变化。于是我们现在可以在本地修改Hexo博客后自动发布更新到直连外网的VPS，还可以在任意一个向Github分发过SSH公钥的终端向Github Pages发布新的静态站内容。<br>&nbsp;&nbsp;&nbsp; 不知到你们想到了什么，我觉得这个套路可以使VPS上维护一个经常预更新的静态站alpha版，Github Pages上维护一个比较稳定的静态站beta版。</p>\n",
            "tags": [
                "nginx",
                "hexo",
                "vps",
                "dropbox"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/09/30/nginx%E4%B9%8B%E5%9B%9E%E5%A4%B4%E8%A1%A5%E8%AF%BE/",
            "url": "https://blog.bipedalbit.net/2015/09/30/nginx%E4%B9%8B%E5%9B%9E%E5%A4%B4%E8%A1%A5%E8%AF%BE/",
            "title": "nginx之回头补课",
            "date_published": "2015-09-30T04:50:34.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 最近买了苗泽的那本《Nginx高性能Web服务器详解》，准备系统地学习下Nginx相关的知识。于是在二次科普的过程中发现之前对Nginx的一些理解和认识被刷新细化了。特此发文总结补课。</p>\n<span id=\"more\"></span>\n<h1 id=\"一-Web请求处理机制\"><a href=\"#一-Web请求处理机制\" class=\"headerlink\" title=\"一. Web请求处理机制\"></a>一. Web请求处理机制</h1><h2 id=\"1-1-多进程方式\"><a href=\"#1-1-多进程方式\" class=\"headerlink\" title=\"1.1 多进程方式\"></a>1.1 多进程方式</h2><p>&nbsp;&nbsp;&nbsp; 传统的多进程方式是指：每接到一个客户端请求，就由服务器主进程生成一个子进程来负责与客户端建立连接并进行交互。连接断开子进程即销毁。<br>&nbsp;&nbsp;&nbsp; 优点：<br>&nbsp;&nbsp;&nbsp; ①设计实现比较简单，许多细节被OS管理；<br>&nbsp;&nbsp;&nbsp; ②由于进程间独立，资源独立分配使用，运行时出错风险小，稳定性好；<br>&nbsp;&nbsp;&nbsp; ③OS的进程资源回收机制比较完备，垃圾不会积累。<br>&nbsp;&nbsp;&nbsp; 缺点：<br>&nbsp;&nbsp;&nbsp; 动态生成子进程涉及内存复制等操作，资源、时间开销比较大。发生大并发时对OS资源造成较大压力，将导致OS性能下降。<br>&nbsp;&nbsp;&nbsp; Apache最初的设计架构就采用了多进程方式，但是为了适应大并发的要求，对多进程方式进行了改进。<br>&nbsp;&nbsp;&nbsp; 多进程方式的短板在于动态生成进程时的开销，于是Apache采用了“预生成进程”的工作方式。顾名思义，在还没有接到客户端请求的空闲时间，预先生成若干工作进程。当接到客户端请求，主进程分配子进程与客户端进行交互。连接断开后子进程保留，做开销很小的适当清理后被主进程管理起来等待下一个客户端请求。“预生成进程”在一定程度上缓解了大并发时Web服务器对OS资源造成的压力。</p>\n<h2 id=\"1-2-多线程方式\"><a href=\"#1-2-多线程方式\" class=\"headerlink\" title=\"1.2 多线程方式\"></a>1.2 多线程方式</h2><p>&nbsp;&nbsp;&nbsp; 总体来说多线程方式与多进程方式十分类似，它们的区别在于，Web服务器接到客户端请求后，多线程方式下，主进程将动态派生一个工作线程来与客户端进行交互。<br>&nbsp;&nbsp;&nbsp; 同样是动态生成，OS产生一个线程的开销要远远小于产生一个进程的开销（在实验验证之前，我对此表示怀疑）。<br>&nbsp;&nbsp;&nbsp; 优点：<br>&nbsp;&nbsp;&nbsp; OS资源压力小于多进程方式。<br>&nbsp;&nbsp;&nbsp; 缺点：<br>&nbsp;&nbsp;&nbsp; OS对线程管理的支持甚少，线程调度规则、内存空间管理、线程资源管理都需要开发者自己考虑，增大了开发难度和出错风险。错误也容易在Web服务器持续运行的过程中发生堆积。<br>&nbsp;&nbsp;&nbsp; IIS服务器采用了多线程方式处理Web请求，它的稳定性相对不错。但是IIS Web服务器管理员仍然倾向于定期检查和重启服务器，以消除不可预知的错误堆积或其他隐患。</p>\n<h1 id=\"二-异步-同步、阻塞-非阻塞\"><a href=\"#二-异步-同步、阻塞-非阻塞\" class=\"headerlink\" title=\"二. 异步&#x2F;同步、阻塞&#x2F;非阻塞\"></a>二. 异步&#x2F;同步、阻塞&#x2F;非阻塞</h1><p>&nbsp;&nbsp;&nbsp; 异步与非阻塞，同步与阻塞的概念常被人混淆。事实上，异步&#x2F;同步与阻塞&#x2F;非阻塞发生在网络通信的不同阶段，前者发生在客户端与服务端的通信阶段，与请求处理过程无关；后者发生在请求处理阶段。</p>\n<h2 id=\"2-1-异步-同步\"><a href=\"#2-1-异步-同步\" class=\"headerlink\" title=\"2.1 异步&#x2F;同步\"></a>2.1 异步&#x2F;同步</h2><p>&nbsp;&nbsp;&nbsp; 在网络通信中同步机制指：发送方发送请求后，等到接收方发回响应后才发出下一个请求。发送端与接收端步调一致。异步机制：发送方是否发送请求不受接收方是否作出响应的影响。在接收方，发送方的请求形成队列，依次处理完成后依次进行响应。</p>\n<h2 id=\"2-2-阻塞-非阻塞\"><a href=\"#2-2-阻塞-非阻塞\" class=\"headerlink\" title=\"2.2 阻塞&#x2F;非阻塞\"></a>2.2 阻塞&#x2F;非阻塞</h2><p>&nbsp;&nbsp;&nbsp; 阻塞与非阻塞的对象，通常是网络套接字Socket，其实质是IO操作。阻塞方式中，IO结果返回前，当前线程从运行状态被挂起，直到IO结果返回，才进入就绪状态等待调度以继续运行；非阻塞方式中，线程不会被挂起，如果当前调用无法马上返回结果，一个失败消息将被<strong>立即返回</strong>，并继续执行下一个调用。</p>\n<h2 id=\"2-3-同步阻塞方式\"><a href=\"#2-3-同步阻塞方式\" class=\"headerlink\" title=\"2.3 同步阻塞方式\"></a>2.3 同步阻塞方式</h2><p>&nbsp;&nbsp;&nbsp; 发送方发送请求后一直等待响应；接收方处理请求时的IO操作如果不能马上返回结果则一直等待，返回结果后响应发送方。一个请求周期期间，发送方和接收方不能进行其他工作。比如，超市排队付账时，客户（发送方）向收款员（接收方）付款（发送请求）后需等待找零，期间不能做其他事；收款员要等待收款机返回结果（IO操作）后才能找零（响应请求），期间也只能等待。这种方式实现简单，效率不高。</p>\n<h2 id=\"2-4-同步非阻塞方式\"><a href=\"#2-4-同步非阻塞方式\" class=\"headerlink\" title=\"2.4 同步非阻塞方式\"></a>2.4 同步非阻塞方式</h2><p>&nbsp;&nbsp;&nbsp; 付款后顾客只能等着，收款员可以先干点给商品打包、玩手机之类的杂事。实际中不使用。</p>\n<h2 id=\"2-5-异步阻塞方式\"><a href=\"#2-5-异步阻塞方式\" class=\"headerlink\" title=\"2.5 异步阻塞方式\"></a>2.5 异步阻塞方式</h2><p>&nbsp;&nbsp;&nbsp; 付款后顾客可以干点跟后面顾客聊天、玩手机之类的杂事，收款员只能等着。实际中不使用。</p>\n<h2 id=\"2-6-异步非阻塞方式\"><a href=\"#2-6-异步非阻塞方式\" class=\"headerlink\" title=\"2.6 异步非阻塞方式\"></a>2.6 异步非阻塞方式</h2><p>&nbsp;&nbsp;&nbsp; 发送方发送请求后无需忙等，可以继续其他操作，有响应时再做出对应反应；接收方如果不能马上获得IO结果，将请求挂入请求队列，继续其他工作，返回IO结果时触发一个事件，接收方向发送方作出对应响应。比如，付款后顾客可以干点跟后面顾客聊天、玩手机之类的杂事；收款员完成商品扫码和收款金额输入后可以先干点给商品打包、玩手机之类的杂事，当收款机发出警报声，收款员告诉顾客机器坏了没法收款，当收款机刷新出找零金额，收款员开始找零。</p>\n<h1 id=\"三-Nginx的请求处理机制\"><a href=\"#三-Nginx的请求处理机制\" class=\"headerlink\" title=\"三. Nginx的请求处理机制\"></a>三. Nginx的请求处理机制</h1><p>&nbsp;&nbsp;&nbsp; Nginx使用“预生成进程”或“带进程池”的多进程方式作为请求处理方式，使用异步非阻塞方式作为网络通信方式。Nginx服务器在启动时就由主进程fork（分支）若干固定数目的工作进程（工作进程数通常与CPU核心数线性相关，有助于提高CPU利用率），这些工作进程就是Nginx的进程池。使用多进程方式保证大并发情景下<strong>不增加</strong>OS资源压力，使用异步非阻塞方式保证大并发情景下<strong>不降低</strong>请求处理能力。</p>\n<h1 id=\"四-Nginx事件驱动模型\"><a href=\"#四-Nginx事件驱动模型\" class=\"headerlink\" title=\"四. Nginx事件驱动模型\"></a>四. Nginx事件驱动模型</h1><h2 id=\"4-1-事件驱动模型概述\"><a href=\"#4-1-事件驱动模型概述\" class=\"headerlink\" title=\"4.1 事件驱动模型概述\"></a>4.1 事件驱动模型概述</h2><p>&nbsp;&nbsp;&nbsp; 事件驱动模型一般由事件收集器、事件发送器和事件处理器三个基本单元组成：<br>&nbsp;&nbsp;&nbsp; ①事件收集器：事件收集器一般由一个事件循环程序构成，即无线循环监听各种预设类型的事件；<br>&nbsp;&nbsp;&nbsp; ②事件收集器：事件发送器实际上只是一个事件映射集；<br>&nbsp;&nbsp;&nbsp; ③时间处理器：通常，事件处理器的并发实现有以下三种方式：为请求创建新进程、为请求创建新线程、将请求放入请求队列。第一种方式OS资源开销大；第二种方式开发者需要自己动手完成线程同步，编码复杂；第三种方式编码逻辑复杂，但大多数Web服务器采用第三种方式，基于第三种方式的事件驱动模型逐渐形成了一系列“事件驱动处理库”，又被称为“多路IO复用方法”。</p>\n<h2 id=\"4-2-select库\"><a href=\"#4-2-select库\" class=\"headerlink\" title=\"4.2 select库\"></a>4.2 select库</h2><p>&nbsp;&nbsp;&nbsp; 各个版本的Linux和Windows平台都支持select库，接口基本相同，参数含义略有差异。首先它需要创建3个事件描述符集合（事件映射集），分别可以关注并收集Read、Write、Exception事件描述符（事件收集）。其次调用OS核心的select()函数。然后<strong>轮询</strong>每个事件描述符集中的每个事件描述符，如有事件发生则进行处理。Nginx服务器在编译过程中如未指定其他高性能事件驱动模型库，将自动编译 select 库。</p>\n<h2 id=\"4-3-poll库\"><a href=\"#4-3-poll库\" class=\"headerlink\" title=\"4.3 poll库\"></a>4.3 poll库</h2><p>&nbsp;&nbsp;&nbsp; 限于Linux平台的基本事件驱动模型。poll与select的区别在于，它只创建一个事件描述符集，而每个事件描述符<strong>结构上</strong>分别设置Read、Write、Exception事件，<strong>轮询</strong>时可同时检查三种事件是否发生。同样的，如未指定其他高性能事件驱动模型库，Nginx将自动编译 poll 库。</p>\n<h2 id=\"4-4-epoll\"><a href=\"#4-4-epoll\" class=\"headerlink\" title=\"4.4 epoll\"></a>4.4 epoll</h2><p>&nbsp;&nbsp;&nbsp; epoll是公认优秀的高性能事件驱动模型，Linux 2.6及以上版本可以使用它。epoll是对poll的改进，epoll可以看成是event poll，即基于事件的poll。epoll利用OS调用，让内核来创建事件描述符集，然后监听内核的反馈事件。当内核通过一个事件反馈发生事件的描述符列表再处理这些事件。<br>&nbsp;&nbsp;&nbsp; epoll库在Linux平台上是高效的（因为Linux内核的高效性），它支持一个进程打开大数目的事件描述符，上限是OS支持的最大打开文件数。同时因为它只处理内核上报的“活跃”描述符，epoll的IO效率不随描述符数目的增加线性下降（类似哈希查找之于遍历查找），即它支持大描述符集。</p>\n<h2 id=\"4-5-rtsig模型\"><a href=\"#4-5-rtsig模型\" class=\"headerlink\" title=\"4.5 rtsig模型\"></a>4.5 rtsig模型</h2><p>&nbsp;&nbsp;&nbsp; rtsig即real time signal的缩写，即实时信号。事实上，rtsig调用内核创建一个固定长度上限的事件信号发生队列，等待工作进程依次处理。</p>\n<h2 id=\"4-6-其他事件驱动模型\"><a href=\"#4-6-其他事件驱动模型\" class=\"headerlink\" title=\"4.6 其他事件驱动模型\"></a>4.6 其他事件驱动模型</h2><p>&nbsp;&nbsp;&nbsp; kqueue模型，是用于支持BSD系列平台（FreeBSD、OpenBSD、NetBSD、Mac OS X等）的高效事件驱动模型。也是poll的变种，仰仗OS内核支持条件触发（LT即level-triggered即满足条件触发）和边缘触发（ET即edge-triggered，即状态变换触发）。</p>\n<p>&nbsp;&nbsp;&nbsp; &#x2F;dev&#x2F;poll模型，是用于支持Unix衍生平台（Solaris、HP&#x2F;UX、IRIX、Tru64 UNIX），该模型是Sun公司开发Solaris系列平台时提出的事件驱动机制方案，使用了虚拟的&#x2F;dev&#x2F;poll设备，开发人员监听设备消息获取事件通知。</p>\n<p>&nbsp;&nbsp;&nbsp; eventport模型，是用于支持Solaris10及以上版本平台的高效事件驱动模型。也是Sun公司开发Solaris是提出的方案，可以有效防止内核崩溃等情况。</p>\n<h2 id=\"4-7-IOCP模型\"><a href=\"#4-7-IOCP模型\" class=\"headerlink\" title=\"4.7 IOCP模型\"></a>4.7 IOCP模型</h2><p>&nbsp;&nbsp;&nbsp; 苗泽在书中没有提到，但现在Nginx在windows平台下还支持IOCP模型，虽然我对它不甚了解，但圈内提及Windows平台下的大并发网络，一定会提起IOCP模型，估计也是利用内核优化的事件驱动模型。</p>\n",
            "tags": [
                "nginx",
                "Web请求处理机制",
                "同步/异步",
                "阻塞/非阻塞",
                "事件驱动模型"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/08/18/%E3%80%90%E4%BA%94%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "https://blog.bipedalbit.net/2015/08/18/%E3%80%90%E4%BA%94%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "【五】nginx的数据结构(3)——扩展红黑树",
            "date_published": "2015-08-17T18:04:43.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 基础版的红黑树写完之后总觉得有些辅助功能不补充一下就难以体现红黑树在统计方面的优越性，于是我又写了红黑树扩展版。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 发扬我一贯的支线任务狂魔的作风，一晚上就完成了之前设想的红黑树扩展版本。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.2\n */\n\n#ifndef _RBTREE_H_INCLUDED_\n#define _RBTREE_H_INCLUDED_\n\n/* the node structure of the red-black tree */\ntypedef struct rbtree_node_s rbtree_node_t;\n/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */\ntypedef int rbtree_key_t;\n/* Abstract type is complicated to achieve with C so I use char* instead. */\ntypedef char* rbtree_data_t;\n\nstruct rbtree_node_s\n&#123;\n    /* key of the node */\n    rbtree_key_t    key;\n    /* pointer of the parent of the node */\n    rbtree_node_t*  parent;\n    /* pointer of the left kid of the node */\n    rbtree_node_t*  left;\n    /* pointer of the right kid of the node */\n    rbtree_node_t*  right;\n    /* color of the node */\n    unsigned char   color;\n    /* pointer of the value of the node corresponding to the key */\n    rbtree_data_t   value;\n    /* count of nodes in the subtree whose root is the current node */\n    int node_cnt;\n&#125;;\n\n/* the tree object stucture of the red-black tree */\ntypedef struct rbtree_s rbtree_t;\n/* foundational insert function pointer */\ntypedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);\n/* foundational visit function pointer */\ntypedef void (*rbtree_visit_p) (rbtree_node_t* node);\n\nstruct rbtree_s\n&#123;\n    /* the pointer of the root node of the tree */\n    rbtree_node_t* root;\n    /* black leaf nodes as sentinel */\n    rbtree_node_t* sentinel;\n    /* the polymorphic insert function pointer */\n    rbtree_insert_p insert;\n&#125;;\n\n/* macros */\n#define rbtree_init(tree, s, i)     \\\nrbtree_sentinel_init(s);            \\\n(tree)-&gt;root = s;               \\\n(tree)-&gt;sentinel = s;           \\\n(tree)-&gt;insert = i\n\n#define rbtree_red(node)    ((node)-&gt;color = 1)\n#define rbtree_black(node)  ((node)-&gt;color = 0)\n#define rbtree_is_red(node) ((node)-&gt;color)\n#define rbtree_is_black(node)   (!rbtree_is_red(node))\n /* copy n2&#39;s color to n1 */\n#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)\n/* sentinel must be black cuz it&#39;s leaf node */\n#define rbtree_sentinel_init(node)  \\\nrbtree_black(node);         \\\n(node)-&gt;node_cnt = 0\n\n/* statements of public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node);\n/* get node by key */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);\n/* get node by order number */\nrbtree_node_t* rbtree_index(rbtree_t* tree, int index);\nint rbtree_height(rbtree_t* tree, rbtree_node_t* node);\nint rbtree_count(rbtree_t* tree);\nvoid rbtree_visit(rbtree_node_t* node);\nvoid rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p);\n\n#endif  /* _RBTREE_H_INCLUDED_ */\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 可以看到，我增加了按序号查找结点、求树高、求结点数、可重写访问节点方法的遍历，这么几个功能。<br>&nbsp;&nbsp;&nbsp; 为了提高按序号查找结点的效率，我增加了一个结点项node_cnt，代表当前结点为根的子树上的结点总数。这样按序号查找结点的过程将是一个二分查找，时间效率与按key查找相同，都是O(log2n)。<br>&nbsp;&nbsp;&nbsp; 遍历方法使用递归的中序遍历，默认的结点访问方法是个空方法，用户可以自行重写。<br>&nbsp;&nbsp;&nbsp; rbtree.c：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.2\n */\n\n#include &lt;stddef.h&gt;\n#include &quot;rbtree.h&quot;\n\n/* inline methods */\n/* get the node with the minimum key in a subtree of the red-black tree */\nstatic inline rbtree_node_t*\nrbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)\n&#123;\n    while(node-&gt;left != sentinel)\n    &#123;\n        node = node-&gt;left;\n    &#125;\n\n    return node;\n&#125;\n\n/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */\nstatic inline void rbtree_replace(rbtree_t* tree,\n    rbtree_node_t* node, rbtree_node_t* tmp)\n&#123;\n    /* upward: p[node] &lt;- p[tmp] */\n    tmp-&gt;parent = node-&gt;parent;\n\n    if (node == tree-&gt;root)\n    &#123;\n        tree-&gt;root = tmp;\n    &#125;\n    else if (node == node-&gt;parent-&gt;left)\n    &#123;\n        /* downward: left[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;left = tmp;\n    &#125;\n    else\n    &#123;\n        /* downward: right[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;right = tmp;\n    &#125;\n\n    node-&gt;parent = tmp;\n&#125;\n\n/* change the topologic structure of the tree keeping the order of the nodes */\nstatic inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* node as the var x in CLRS while tmp as the var y */\n    rbtree_node_t* tmp = node-&gt;right;\n\n    /* fix node_cnt */\n    node-&gt;node_cnt = node-&gt;left-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;\n    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;\n\n    /* replace y with left[y] */\n    /* downward: right[x] &lt;- left[y] */\n    node-&gt;right = tmp-&gt;left;\n    /* if left[[y] is not NIL it has a parent */\n    if (tmp-&gt;left != tree-&gt;sentinel)\n    &#123;\n        /* upward: p[left[y]] &lt;- x */\n        tmp-&gt;left-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;left = node;\n&#125;\n\nstatic inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* tmp = node-&gt;left;\n\n    /* fix node_cnt */\n    node-&gt;node_cnt = node-&gt;right-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;\n    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;\n\n    /* replace y with right[y] */\n    node-&gt;left = tmp-&gt;right;\n    if (tmp-&gt;right != tree-&gt;sentinel)\n    &#123;\n        tmp-&gt;right-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;right = node;\n&#125;\n\n/* static methods */\n/* fix the red-black tree after the new node inserted */\nstatic void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    while(rbtree_is_red(node-&gt;parent))\n    &#123;\n        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)\n        &#123;\n            /* case 1: node&#39;s uncle is red */\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n                /* Then we can consider the whole subtree */\n                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */\n                /* and keep looping till &quot;node&quot; become the root. */\n            &#125;\n            /* case 2: node&#39;s uncle is black */\n            else\n            &#123;\n                /* ensure node is the left kid of its parent */\n                if (node == node-&gt;parent-&gt;right)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_left_rotate(tree, node);\n                &#125;\n                /* case 2 -&gt; case 1 */\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (node == node-&gt;parent-&gt;left)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_right_rotate(tree, node);\n                &#125;\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n    &#125;\n    /* ensure the root node being black */\n    rbtree_black(tree-&gt;root);\n&#125;\n\nstatic void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* brother = NULL;\n\n    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))\n    &#123;\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            brother = node-&gt;parent-&gt;right;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* update brother after topologic change of the tree */\n                brother = node-&gt;parent-&gt;right;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                /* go upward and keep on fixing color */\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;right))\n                &#123;\n                    rbtree_black(brother-&gt;left);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    /* update brother after topologic change of the tree */\n                    brother = node-&gt;parent-&gt;right;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;right);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* end the loop and ensure root is black */\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            brother = node-&gt;parent-&gt;left;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                brother = node-&gt;parent-&gt;left;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;left))\n                &#123;\n                    rbtree_black(brother-&gt;right);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    brother = node-&gt;parent-&gt;left;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;left);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n    &#125;\n\n    rbtree_black(node);\n&#125;\n\n/* public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* Using ** to know wether the new node will be a left kid */\n    /* or a right kid of its parent node. */\n    rbtree_node_t** tmp = &amp;tree-&gt;root;\n    rbtree_node_t* parent;\n\n    while(*tmp != tree-&gt;sentinel)\n    &#123;\n        parent = *tmp;\n\n        /* update node_cnt */\n        (parent-&gt;node_cnt)++;\n\n        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;\n    &#125;\n\n    /* The pointer knows wether the node should be on the left side */\n    /* or on the right one. */\n    *tmp = node;\n    node-&gt;parent = parent;\n    node-&gt;left = tree-&gt;sentinel;\n    node-&gt;right = tree-&gt;sentinel;\n    rbtree_red(node);\n&#125;\n\nvoid rbtree_visit(rbtree_node_t* node)\n&#123;\n    /* visiting the current node */\n&#125;\n\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n\n    /* if the tree is empty */\n    if (tree-&gt;root == sentinel)\n    &#123;\n        tree-&gt;root = node;\n        node-&gt;parent = sentinel;\n        node-&gt;left = sentinel;\n        node-&gt;right = sentinel;\n        rbtree_black(node);\n\n        return;\n    &#125;\n\n    /* generally */\n    tree-&gt;insert(tree, node);\n    rbtree_insert_fixup(tree, node);\n&#125;\n\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n    /* wether &quot;node&quot; is on the left side or the right one */\n    rbtree_node_t** ptr_to_node = NULL;\n    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */\n    rbtree_node_t* cover = NULL;\n    /* wether we lossing a red node on the edge of the tree */\n    int loss_red = rbtree_is_red(node);\n    int is_root = (node == tree-&gt;root);\n\n    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */\n    /* sentinel in &quot;node&quot;&#39;s kids */\n    if (node-&gt;left == sentinel)\n    &#123;\n        cover = node-&gt;right;\n    &#125;\n    else if (node-&gt;right == sentinel)\n    &#123;\n        cover = node-&gt;left;\n    &#125;\n    /* &quot;node&quot;&#39;s kids are both non-sentinel */\n    else\n    &#123;\n        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */\n        cover = rbtree_subtree_min(node-&gt;right, sentinel);\n        node-&gt;key = cover-&gt;key;\n        node-&gt;value = cover-&gt;value;\n        node = cover;\n        loss_red = rbtree_is_red(node);\n        is_root = 0;\n        /* move &quot;cover&quot;&#39;s kids */\n        /* &quot;cover&quot; can only be a left kid */\n        /* and can only have a right non-sentinel kid */\n        /* because of function &quot;rbtree_subtree_min&quot; */\n        cover = node-&gt;right;\n    &#125;\n\n    if (is_root)\n    &#123;\n        /* update root */\n        tree-&gt;root = cover;\n    &#125;\n    else\n    &#123;\n        /* downward link */\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            node-&gt;parent-&gt;left = cover;\n        &#125;\n        else\n        &#123;\n            node-&gt;parent-&gt;right = cover;\n        &#125;\n    &#125;\n    /* upward link */\n    cover-&gt;parent = node-&gt;parent;\n    /* &quot;cover&quot; may be a sentinel */\n    if (cover != sentinel)\n    &#123;\n        /* set &quot;cover&quot; */\n        cover-&gt;left = node-&gt;left;\n        cover-&gt;right = node-&gt;right;\n        rbtree_copy_color(cover, node);\n    &#125;\n\n    /* clear &quot;node&quot; since it&#39;s useless */\n    node-&gt;key = -1;\n    node-&gt;parent = NULL;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    node-&gt;value = NULL;\n\n    /* update node_cnt */\n    rbtree_node_t* tmp = cover-&gt;parent;\n    while(tmp != sentinel)\n    &#123;\n        (tmp-&gt;node_cnt)--;\n        tmp = tmp-&gt;parent;\n    &#125;\n\n    if (loss_red)\n    &#123;\n        return;\n    &#125;\n\n    /* When lossing a black node on edge */\n    /* the fifth rule of red-black tree will be broke. */\n    /* So the tree need to be fixed. */\n    rbtree_delete_fixup(tree, cover);\n&#125;\n\n/* find the node in the tree corresponding to the given key value */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)\n&#123;\n    rbtree_node_t* tmp = tree-&gt;root;\n    /* next line is just fot test */\n    // int step_cnt = 0;\n\n    /* search the binary tree */\n    while(tmp != tree-&gt;sentinel)\n    &#123;\n        /* next line is just fot test */\n        // step_cnt++;\n        if(key == tmp-&gt;key)\n        &#123;\n            /* next line is just for test */\n            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);\n            return tmp;\n        &#125;\n\n        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;\n    &#125;\n\n    return NULL;\n&#125;\n\n/* find the node in the tree corresponding to the given order number */\nrbtree_node_t* rbtree_index(rbtree_t* tree, int index)\n&#123;\n    if (index &lt; 0 || index &gt;= rbtree_count(tree))\n    &#123;\n        return NULL;\n    &#125;\n\n    rbtree_node_t* tmp = tree-&gt;root;\n    int left_cnt = 0;\n    int sub_left_cnt;\n\n    while(tmp-&gt;node_cnt &gt; 0)\n    &#123;\n        sub_left_cnt = tmp-&gt;left-&gt;node_cnt;\n        if (left_cnt + sub_left_cnt == index)\n        &#123;\n            return tmp;\n        &#125;\n\n        if (left_cnt + sub_left_cnt &lt; index)\n        &#123;\n            left_cnt += sub_left_cnt + 1;\n            tmp = tmp-&gt;right;\n        &#125;\n        else\n        &#123;\n            tmp = tmp-&gt;left;\n        &#125;\n    &#125;\n&#125;\n\n/* get the height of the subtree */\nint rbtree_height(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    if (node == tree-&gt;sentinel)\n    &#123;\n        return 0;\n    &#125;\n\n    int left_height = rbtree_height(tree, node-&gt;left);\n    int right_height = rbtree_height(tree, node-&gt;right);\n    int sub_height = (left_height &gt; right_height) ? left_height : right_height;\n    return sub_height+1;\n&#125;\n\n/* get the count of nodes in the tree */\nint rbtree_count(rbtree_t* tree)\n&#123;\n    return tree-&gt;root-&gt;node_cnt;\n&#125;\n\n/* visit every node of the subtree whose root is given in order */\nvoid rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p visit)\n&#123;\n    if (node != tree-&gt;sentinel)\n    &#123;\n        rbtree_traversal(tree, node-&gt;left, visit);\n        visit(node);\n        rbtree_traversal(tree, node-&gt;right, visit);\n    &#125;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 还是做个压力测试。<br>&nbsp;&nbsp;&nbsp; test.c：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    double duration;\n    double room;\n\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 1&lt;&lt;20;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */\n    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */\n    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));\n    int i;\n\n    long time1 = clock();\n\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i%10];\n        n[i].node_cnt = 1;\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    srand( (unsigned int)time(0) );\n    int no = rand()%cnt;\n    printf(&quot;n[%d]-&gt;key = %d\\n&quot;, no, rbtree_index(&amp;t, no)-&gt;key);\n\n    long time2 = clock();\n    room = 48.0*cnt/(1&lt;&lt;20);\n    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;\n    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\\n&quot;, cnt, room, duration);\n\n    const int search_cnt = 1&lt;&lt;10;\n    for( i = 0 ; i &lt; search_cnt ; i++ )\n    &#123;\n        rbtree_find(&amp;t, (rand()%cnt)+1);\n    &#125;\n\n    long time3 = clock();\n    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;\n    printf(&quot;Searching %d nodes among %d spends %f seconds.\\n&quot;, search_cnt, cnt, duration);\n\n    const int index_cnt = 1&lt;&lt;10;\n    for( i = 0 ; i &lt; index_cnt ; i++ )\n    &#123;\n        rbtree_index(&amp;t, (rand()%cnt));\n    &#125;\n\n    long time4 = clock();\n    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;\n    printf(&quot;Indexing %d nodes among %d spends %f seconds.\\n&quot;, index_cnt, cnt, duration);\n\n    const int delete_cnt = 1&lt;&lt;10;\n    int nums[delete_cnt];\n    int num;\n    /* Let&#39;s hash! */\n    char* mark = (char*)calloc(cnt, sizeof(char));\n    memset(mark, 0, cnt*sizeof(char));\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        for(;;)\n        &#123;\n            num = rand()%cnt;\n            if (mark[num] == 0)\n            &#123;\n                mark[num] = 1;\n                nums[i] = num;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    long time5 = clock();\n    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;\n    printf(&quot;Hash %d times spends %f seconds.\\n&quot;, delete_cnt, duration);\n\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        rbtree_delete(&amp;t, &amp;n[nums[i]]);\n    &#125;\n\n    long time6 = clock();\n    duration = (double)(time6 - time5) / CLOCKS_PER_SEC;\n    printf(&quot;Deleting %d nodes among %d spends %f seconds.\\n&quot;, delete_cnt, cnt, duration);\n    free(mark);\n\n    int h = rbtree_height(&amp;t, t.root);\n    long time7 = clock();\n    duration = (double)(time7 - time6) / CLOCKS_PER_SEC;\n    printf(&quot;The height of the tree is %d. Getting it spends %f seconds.\\n&quot;, h, duration);\n\n    rbtree_traversal(&amp;t, t.root, rbtree_visit);\n    long time8 = clock();\n    duration = (double)(time8 - time7) / CLOCKS_PER_SEC;\n    printf(&quot;Traversal the tree spends %f seconds.\\n&quot;, duration);\n\n    printf(&quot;Count of nodes in the tree is %d.\\n&quot;, rbtree_count(&amp;t));\n\n    free(n);\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 上一个版本的压力测试结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.\nSearching 1024 nodes among 1048576 spends 0.001140 seconds.\nHash 1024 times spends 0.000334 seconds.\nDeleting 1024 nodes among 1048576 spends 0.000783 seconds.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 扩展版本的压力测试结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.467859 seconds.\nSearching 1024 nodes among 1048576 spends 0.001188 seconds.\nIndexing 1024 nodes among 1048576 spends 0.001484 seconds.\nHash 1024 times spends 0.000355 seconds.\nDeleting 1024 nodes among 1048576 spends 0.001417 seconds.\nThe height of the tree is 28. Getting it spends 0.021669 seconds.\nTraversal the tree spends 0.023913 seconds.\nCount of nodes in the tree is 1047552.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 比较一下可以发现：<br>&nbsp;&nbsp;&nbsp; 1.插入结点略慢了一点，因为插入时多维护了一个node_cnt项。<br>&nbsp;&nbsp;&nbsp; 2.按key查找结点速度没有变化。<br>&nbsp;&nbsp;&nbsp; 3.哈希查找速度没有变化。<br>&nbsp;&nbsp;&nbsp; 4.删除结点花的时间几乎是原来的两倍，因为每次删除后都要一路向上更新node_cnt，几乎相当于包含了一次按key查询。<br>&nbsp;&nbsp;&nbsp; 5.按序号查询比按key查询略慢，因为每次进入右子树需要多做一次加法。<br>&nbsp;&nbsp;&nbsp; 6.遍历花的时间与求树高相同，因为它们的实质都是遍历树，时间效率O(n)数量级，具体点为2n次结点访问，分别为结点入栈和出栈时。<br>&nbsp;&nbsp;&nbsp; 别问我max、min、mid在哪，能按序号查询了这些还是问题吗？</p>\n",
            "tags": [
                "nginx",
                "rbtree",
                "C"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/08/16/%E3%80%90%E5%9B%9B%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "https://blog.bipedalbit.net/2015/08/16/%E3%80%90%E5%9B%9B%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "【四】nginx的数据结构(2)——自己动手重写红黑树",
            "date_published": "2015-08-16T14:06:30.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 不管看了多少遍有多滚瓜烂熟，数据结构或者算法的代码如果不亲自码一遍，我总是不敢说自己懂了。这次就来自己动手重写红黑树。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 费话不多说，上重写代码，这次姑且用英语写的注释当复习英语了。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#ifndef _RBTREE_H_INCLUDED_\n#define _RBTREE_H_INCLUDED_\n\n/* the node structure of the red-black tree */\ntypedef struct rbtree_node_s rbtree_node_t;\n/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */\ntypedef int rbtree_key_t;\n/* Abstract type is complicated to achieve with C so I use char* instead. */\ntypedef char* rbtree_data_t;\n\nstruct rbtree_node_s\n&#123;\n    /* key of the node */\n    rbtree_key_t    key;\n    /* pointer of the parent of the node */\n    rbtree_node_t*  parent;\n    /* pointer of the left kid of the node */\n    rbtree_node_t*  left;\n    /* pointer of the right kid of the node */\n    rbtree_node_t*  right;\n    /* color of the node */\n    unsigned char   color;\n    /* pointer of the value of the node corresponding to the key */\n    rbtree_data_t   value;\n&#125;;\n\n/* the tree object stucture of the red-black tree */\ntypedef struct rbtree_s rbtree_t;\n/* foundational insert function pointer*/\ntypedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);\n\nstruct rbtree_s\n&#123;\n    /* the pointer of the root node of the tree */\n    rbtree_node_t* root;\n    /* black leaf nodes as sentinel */\n    rbtree_node_t* sentinel;\n    /* the polymorphic insert function pointer */\n    rbtree_insert_p insert;\n&#125;;\n\n/* macros */\n#define rbtree_init(tree, s, i)     \\\nrbtree_sentinel_init(s);            \\\n(tree)-&gt;root = s;               \\\n(tree)-&gt;sentinel = s;           \\\n(tree)-&gt;insert = i\n\n#define rbtree_red(node)    ((node)-&gt;color = 1)\n#define rbtree_black(node)  ((node)-&gt;color = 0)\n#define rbtree_is_red(node) ((node)-&gt;color)\n#define rbtree_is_black(node)   (!rbtree_is_red(node))\n /* copy n2&#39;s color to n1 */\n#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)\n/* sentinel must be black cuz it&#39;s leaf node */\n#define rbtree_sentinel_init(node)  rbtree_black(node)\n\n/* statements of public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node);\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);\n\n#endif  /* _RBTREE_H_INCLUDED_ */\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 看过nginx源码的有心人会发现，我的头文件相对于ngx_rbree.h改动不大，非常像。<br>&nbsp;&nbsp;&nbsp; 关键的rbtree.c：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#include &lt;stddef.h&gt;\n#include &quot;rbtree.h&quot;\n\n/* inline methods */\n/* get the node with the minimum key in a subtree of the red-black tree */\nstatic inline rbtree_node_t*\nrbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)\n&#123;\n    while(node-&gt;left != sentinel)\n    &#123;\n        node = node-&gt;left;\n    &#125;\n\n    return node;\n&#125;\n\n/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */\nstatic inline void rbtree_replace(rbtree_t* tree,\n    rbtree_node_t* node, rbtree_node_t* tmp)\n&#123;\n    /* upward: p[node] &lt;- p[tmp] */\n    tmp-&gt;parent = node-&gt;parent;\n\n    if (node == tree-&gt;root)\n    &#123;\n        tree-&gt;root = tmp;\n    &#125;\n    else if (node == node-&gt;parent-&gt;left)\n    &#123;\n        /* downward: left[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;left = tmp;\n    &#125;\n    else\n    &#123;\n        /* downward: right[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;right = tmp;\n    &#125;\n\n    node-&gt;parent = tmp;\n&#125;\n\n/* change the topologic structure of the tree keeping the order of the nodes */\nstatic inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* node as the var x in CLRS while tmp as the var y */\n    rbtree_node_t* tmp = node-&gt;right;\n\n    /* replace y with left[y] */\n    /* downward: right[x] &lt;- left[y] */\n    node-&gt;right = tmp-&gt;left;\n    /* if left[[y] is not NIL it has a parent */\n    if (tmp-&gt;left != tree-&gt;sentinel)\n    &#123;\n        /* upward: p[left[y]] &lt;- x */\n        tmp-&gt;left-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;left = node;\n&#125;\n\nstatic inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* tmp = node-&gt;left;\n\n    /* replace y with right[y] */\n    node-&gt;left = tmp-&gt;right;\n    if (tmp-&gt;right != tree-&gt;sentinel)\n    &#123;\n        tmp-&gt;right-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;right = node;\n&#125;\n\n/* static methods */\n/* fix the red-black tree after the new node inserted */\nstatic void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    while(rbtree_is_red(node-&gt;parent))\n    &#123;\n        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)\n        &#123;\n            /* case 1: node&#39;s uncle is red */\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n                /* Then we can consider the whole subtree */\n                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */\n                /* and keep looping till &quot;node&quot; become the root. */\n            &#125;\n            /* case 2: node&#39;s uncle is black */\n            else\n            &#123;\n                /* ensure node is the left kid of its parent */\n                if (node == node-&gt;parent-&gt;right)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_left_rotate(tree, node);\n                &#125;\n                /* case 2 -&gt; case 1 */\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (node == node-&gt;parent-&gt;left)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_right_rotate(tree, node);\n                &#125;\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n    &#125;\n    /* ensure the root node being black */\n    rbtree_black(tree-&gt;root);\n&#125;\n\nstatic void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* brother = NULL;\n\n    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))\n    &#123;\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            brother = node-&gt;parent-&gt;right;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* update brother after topologic change of the tree */\n                brother = node-&gt;parent-&gt;right;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                /* go upward and keep on fixing color */\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;right))\n                &#123;\n                    rbtree_black(brother-&gt;left);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    /* update brother after topologic change of the tree */\n                    brother = node-&gt;parent-&gt;right;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;right);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* end the loop and ensure root is black */\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            brother = node-&gt;parent-&gt;left;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                brother = node-&gt;parent-&gt;left;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;left))\n                &#123;\n                    rbtree_black(brother-&gt;right);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    brother = node-&gt;parent-&gt;left;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;left);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n    &#125;\n\n    rbtree_black(node);\n&#125;\n\n/* public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* Using ** to know wether the new node will be a left kid */\n    /* or a right kid of its parent node. */\n    rbtree_node_t** tmp = &amp;tree-&gt;root;\n    rbtree_node_t* parent;\n\n    while(*tmp != tree-&gt;sentinel)\n    &#123;\n        parent = *tmp;\n        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;\n    &#125;\n\n    /* The pointer knows wether the node should be on the left side */\n    /* or on the right one. */\n    *tmp = node;\n    node-&gt;parent = parent;\n    node-&gt;left = tree-&gt;sentinel;\n    node-&gt;right = tree-&gt;sentinel;\n    rbtree_red(node);\n&#125;\n\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n\n    /* if the tree is empty */\n    if (tree-&gt;root == sentinel)\n    &#123;\n        tree-&gt;root = node;\n        node-&gt;parent = sentinel;\n        node-&gt;left = sentinel;\n        node-&gt;right = sentinel;\n        rbtree_black(node);\n\n        return;\n    &#125;\n\n    /* generally */\n    tree-&gt;insert(tree, node);\n    rbtree_insert_fixup(tree, node);\n&#125;\n\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n    /* wether &quot;node&quot; is on the left side or the right one */\n    rbtree_node_t** ptr_to_node = NULL;\n    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */\n    rbtree_node_t* cover = NULL;\n    /* wether we lossing a red node on the edge of the tree */\n    int loss_red = rbtree_is_red(node);\n    int is_root = (node == tree-&gt;root);\n\n    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */\n    /* sentinel in &quot;node&quot;&#39;s kids */\n    if (node-&gt;left == sentinel)\n    &#123;\n        cover = node-&gt;right;\n    &#125;\n    else if (node-&gt;right == sentinel)\n    &#123;\n        cover = node-&gt;left;\n    &#125;\n    /* &quot;node&quot;&#39;s kids are both non-sentinel */\n    else\n    &#123;\n        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */\n        cover = rbtree_subtree_min(node-&gt;right, sentinel);\n        node-&gt;key = cover-&gt;key;\n        node-&gt;value = cover-&gt;value;\n        node = cover;\n        loss_red = rbtree_is_red(node);\n        is_root = 0;\n        /* move &quot;cover&quot;&#39;s kids */\n        /* &quot;cover&quot; can only be a left kid */\n        /* and can only have a right non-sentinel kid */\n        /* because of function &quot;rbtree_subtree_min&quot; */\n        cover = node-&gt;right;\n    &#125;\n\n    if (is_root)\n    &#123;\n        /* update root */\n        tree-&gt;root = cover;\n    &#125;\n    else\n    &#123;\n        /* downward link */\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            node-&gt;parent-&gt;left = cover;\n        &#125;\n        else\n        &#123;\n            node-&gt;parent-&gt;right = cover;\n        &#125;\n    &#125;\n    /* upward link */\n    cover-&gt;parent = node-&gt;parent;\n    /* &quot;cover&quot; may be a sentinel */\n    if (cover != sentinel)\n    &#123;\n        /* set &quot;cover&quot; */\n        cover-&gt;left = node-&gt;left;\n        cover-&gt;right = node-&gt;right;\n        rbtree_copy_color(cover, node);\n    &#125;\n\n    /* clear &quot;node&quot; since it&#39;s useless */\n    node-&gt;key = -1;\n    node-&gt;parent = NULL;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    node-&gt;value = NULL;\n\n    if (loss_red)\n    &#123;\n        return;\n    &#125;\n\n    /* When lossing a black node on edge */\n    /* the fifth rule of red-black tree will be broke. */\n    /* So the tree need to be fixed. */\n    rbtree_delete_fixup(tree, cover);\n&#125;\n\n/* find the node in the tree corresponding to the given key value */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)\n&#123;\n    rbtree_node_t* tmp = tree-&gt;root;\n    int step_cnt = 0;\n\n    /* search the binary tree */\n    while(tmp != tree-&gt;sentinel)\n    &#123;\n        /* next line is just fot test */\n        // step_cnt++;\n        if(key == tmp-&gt;key)\n        &#123;\n            /* next line is just for test */\n            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);\n            return tmp;\n        &#125;\n\n        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;\n    &#125;\n\n    return NULL;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp;  虽然明白nginx源码中100+行的长函数体也是一种避免太多函数调用增加时间空间开销的优化，我还是把所有函数都分类分割成100行以下。增加可读性是一方面，可能也是有点强迫症吧。之后会扩展几个统计方法，像max、min和mid，还会扩展一个遍历方法。<br>&nbsp;&nbsp;&nbsp; 下面是调用测试，test.c：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 10;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    rbtree_node_t n[cnt];\n    int i;\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i];\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    rbtree_node_t* p[cnt];\n\n    for (i = 1; i &lt;= cnt; i++)\n    &#123;\n        printf(&quot;key: %d\\n&quot;, i);\n        p[i] = rbtree_find(&amp;t, i);\n        printf(&quot;value: %s\\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);\n    &#125;\n\n    rbtree_delete(&amp;t, &amp;n[5]);\n\n    printf(&quot;\\nafter delete 6-&gt;mango:\\n\\n&quot;);\n\n    for (i = 1; i &lt;= cnt; i++)\n    &#123;\n        printf(&quot;key: %d\\n&quot;, i);\n        p[i] = rbtree_find(&amp;t, i);\n        printf(&quot;value: %s\\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 解开rbtree_find方法里的测试行注释，顺利执行：</p>\n<pre><code class=\"hljs\">key: 1\nstep count: 3, color: black, value: apple\nkey: 2\nstep count: 2, color: black, value: banana\nkey: 3\nstep count: 3, color: black, value: cherry\nkey: 4\nstep count: 1, color: black, value: grape\nkey: 5\nstep count: 3, color: black, value: lemon\nkey: 6\nstep count: 2, color: black, value: mango\nkey: 7\nstep count: 4, color: black, value: pear\nkey: 8\nstep count: 3, color: red, value: pineapple\nkey: 9\nstep count: 4, color: black, value: strawberry\nkey: 10\nstep count: 5, color: red, value: watermelon\n\nafter delete 6-&gt;mango:\n\nkey: 1\nstep count: 3, color: black, value: apple\nkey: 2\nstep count: 2, color: black, value: banana\nkey: 3\nstep count: 3, color: black, value: cherry\nkey: 4\nstep count: 1, color: black, value: grape\nkey: 5\nstep count: 3, color: black, value: lemon\nkey: 6\nvalue: ?\nkey: 7\nstep count: 2, color: black, value: pear\nkey: 8\nstep count: 4, color: black, value: pineapple\nkey: 9\nstep count: 3, color: red, value: strawberry\nkey: 10\nstep count: 4, color: black, value: watermelon\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 下面分别是删除6-&gt;mango前的红黑树和删除后的红黑树示意图：<br><img src=\"http://img.blog.csdn.net/20150816200143108\" alt=\"\" height=\"422\" width=\"400\" /><br><img src=\"http://img.blog.csdn.net/20150816200200052\" alt=\"\" height=\"331\" width=\"400\" /><br>&nbsp;&nbsp;&nbsp; 下面我们来做个大量数据的压力测试，注意把rbtree_find方法里的测试行注释掉，不然后果恐怕会比较吓人：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    double duration;\n    double room;\n\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 1&lt;&lt;20;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */\n    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */\n    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));\n    int i;\n\n    long time1 = clock();\n\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i%10];\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    long time2 = clock();\n    room = 48.0*cnt/(1&lt;&lt;20);\n    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;\n    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\\n&quot;, cnt, room, duration);\n\n    const int search_cnt = 1&lt;&lt;10;\n    srand( (unsigned int)time(0) );\n    for( i = 0 ; i &lt; search_cnt ; i++ )\n    &#123;\n        rbtree_find(&amp;t, (rand()%cnt)+1);\n    &#125;\n\n    long time3 = clock();\n    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;\n    printf(&quot;Searching %d nodes among %d spends %f seconds.\\n&quot;, search_cnt, cnt, duration);\n\n    const int delete_cnt = 1&lt;&lt;10;\n    int nums[delete_cnt];\n    int num;\n    /* Let&#39;s hash! */\n    char* mark = (char*)calloc(cnt, sizeof(char));\n    memset(mark, 0, cnt*sizeof(char));\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        for(;;)\n        &#123;\n            num = rand()%cnt;\n            if (mark[num] == 0)\n            &#123;\n                mark[num] = 1;\n                nums[i] = num;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    long time4 = clock();\n    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;\n    printf(&quot;Hash %d times spends %f seconds.\\n&quot;, delete_cnt, duration);\n\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        rbtree_delete(&amp;t, &amp;n[nums[i]]);\n    &#125;\n\n    long time5 = clock();\n    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;\n    printf(&quot;Deleting %d nodes among %d spends %f seconds.\\n&quot;, delete_cnt, cnt, duration);\n    free(mark);\n    free(n);\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 来看看结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.\nSearching 1024 nodes among 1048576 spends 0.001140 seconds.\nHash 1024 times spends 0.000334 seconds.\nDeleting 1024 nodes among 1048576 spends 0.000783 seconds.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 删除比查找还快，耗时只有哈希查找的两倍多点，上百万的插入也耗时不足半秒，嗯我还挺满意的。<br>&nbsp;&nbsp;&nbsp; 写统计和遍历方法去了。</p>\n",
            "tags": [
                "nginx",
                "rbtree",
                "C"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/08/06/%E3%80%90%E4%B8%89%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E2%80%94%E2%80%94ngx-int-t%E4%B8%8Engx-rbtree-t/",
            "url": "https://blog.bipedalbit.net/2015/08/06/%E3%80%90%E4%B8%89%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E2%80%94%E2%80%94ngx-int-t%E4%B8%8Engx-rbtree-t/",
            "title": "【三】nginx的数据结构(1)——ngx_int_t与ngx_rbtree_t",
            "date_published": "2015-08-05T23:18:00.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 就来挑两个特别的数据结构ngx_int_t、ngx_rbtree_t作为研读nginx源码的开始吧。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 面对<span style=\"font-family:Times New Roman;\">.&#x2F;src&#x2F;core</span><span style=\"font-family:宋体;\">子目录中</span><span style=\"font-family:Times New Roman;\">71</span><span style=\"font-family:宋体;\">个源文件，有点无从下手。浏览包含主函数的</span><span style=\"font-family:Times New Roman;\">nginx.c</span><span style=\"font-family:宋体;\">文件，发现</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">使用了很多自行封装的数据结构，不弄清楚这是些什么样的数据结构就很难理解主函数中操作的意义。于是我们挑看起来基础的数据结构开始研究。组织</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">所有数据结构的是</span><span style=\"font-family:Times New Roman;\">ngx_core.h</span><span style=\"font-family:宋体;\">文件。它首先包含了</span><span style=\"font-family:Times New Roman;\">ngx_config.h</span><span style=\"font-family:宋体;\">，我们在</span><span style=\"font-family:Times New Roman;\">ngx_config.h</span><span style=\"font-family:宋体;\">中发现了三个类型定义。</span></p>\n<h1 id=\"1-ngx-int-t、ngx-uint-t、ngx-flag-t\"><a href=\"#1-ngx-int-t、ngx-uint-t、ngx-flag-t\" class=\"headerlink\" title=\"1. ngx_int_t、ngx_uint_t、ngx_flag_t\"></a>1. ngx_int_t<span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">ngx_uint_t</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">ngx_flag_t</span></h1><p>&nbsp;&nbsp;&nbsp; nginx.c<span style=\"font-family:宋体;\">中看到的第一个陌生数据类型是</span><span style=\"font-family:Times New Roman;\">ngx_int_t</span><span style=\"font-family:宋体;\">，在</span><span style=\"font-family:Times New Roman;\">nginx_config.h</span><span style=\"font-family:宋体;\">中找到了它的定义。</span></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">intptr_t</span> <span class=\"hljs-type\">ngx_int_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">uintptr_t</span> <span class=\"hljs-type\">ngx_uint_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">intptr_t</span> <span class=\"hljs-type\">ngx_flag_t</span>;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 顺藤摸瓜找到了三个数据类型的定义。本科<span style=\"font-family:Times New Roman;\">c</span><span style=\"font-family:宋体;\">入门教学中并没有对</span><span style=\"font-family:Times New Roman;\">intptr_t&#x2F;uintptr_t</span><span style=\"font-family:宋体;\">的介绍，我在</span><span style=\"font-family:Times New Roman;\">c</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">stdint.h</span><span style=\"font-family:宋体;\">头文件中发现了它们的定义。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* Types for `void *&#x27; pointers.  */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> __WORDSIZE == 64</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> __intptr_t_defined</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>    <span class=\"hljs-type\">intptr_t</span>;<br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> __intptr_t_defined</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>   <span class=\"hljs-type\">uintptr_t</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> __intptr_t_defined</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">intptr_t</span>;<br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> __intptr_t_defined</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>    <span class=\"hljs-type\">uintptr_t</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 首先注释说这两种类型是<span style=\"font-family:Times New Roman;\">“void&nbsp;*”</span><span style=\"font-family:宋体;\">的指针类型，尽管字面上看，</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">确实是整型指针类型和无符号整型指针类型，但是让人摸不着头脑，为什么要使用整型作为整型的指针类型呢？先放一放，看后面的宏，机器是</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位字长则</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">long&nbsp;int</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;long&nbsp;int</span><span style=\"font-family:宋体;\">，正好我机器上是</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位编译器，</span><span style=\"font-family:Times New Roman;\">sizeof()</span><span style=\"font-family:宋体;\">了一下，是</span><span style=\"font-family:Times New Roman;\">8</span><span style=\"font-family:宋体;\">个字节</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位，小于</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位字长的</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;int</span><span style=\"font-family:宋体;\">，查表得知</span><span style=\"font-family:Times New Roman;\">32</span><span style=\"font-family:宋体;\">位编译器下</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">unsigned</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">4</span><span style=\"font-family:宋体;\">个字节，</span><span style=\"font-family:Times New Roman;\">16</span><span style=\"font-family:宋体;\">位编译器下为</span><span style=\"font-family:Times New Roman;\">2</span><span style=\"font-family:宋体;\">个字节。那么</span><span style=\"font-family:Times New Roman;\">intptr_t&#x2F;uintptr_t</span><span style=\"font-family:宋体;\">应该是会随着平台字长变化而发生对应变化的整型类型。经过了解，发现《深入分析</span><span style=\"font-family:Times New Roman;\">Linux</span><span style=\"font-family:宋体;\">内核源码》中对此的解释是，系统内核在操作内存时，将内存当做一个大数组，而指针就是数组索引</span><span style=\"font-family:Times New Roman;\">&#x2F;</span><span style=\"font-family:宋体;\">下标，内核程序员使用这种特殊的整型来接受内存地址值、操作内存相比使用指针更加直观，不容易犯错。看起来，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">中，只是单纯的想要使用一些平台相关的</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;int</span><span style=\"font-family:宋体;\">类型变量而已。</span></p>\n<h1 id=\"2-ngx-rbtree-t\"><a href=\"#2-ngx-rbtree-t\" class=\"headerlink\" title=\"2. ngx_rbtree_t\"></a>2. ngx_rbtree_t</h1><h2 id=\"2-1-什么是红黑树\"><a href=\"#2-1-什么是红黑树\" class=\"headerlink\" title=\"2.1 什么是红黑树\"></a>2.1 <span style=\"font-family:宋体;\">什么是红黑树</span></h2><p>&nbsp;&nbsp;&nbsp; 作为一个曾经常年在<span style=\"font-family:Times New Roman;\">ACM</span><span style=\"font-family:宋体;\">比赛里划水的退役队员，对红黑树这样的有名数据结构还是比较敏感的。红黑树是一种特殊约束形式下的平衡二叉查找树实现。学过数据结构课的同学应该知道，课本上的最早的自平衡二叉树</span><span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树严格的要求子树的高度差不超过</span><span style=\"font-family:Times New Roman;\">2</span><span style=\"font-family:宋体;\">，以获得根结点到所有叶结点距离基本相同（平衡）的特性。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 红黑树不追求严格的平衡，而是通过<span style=\"font-family:Times New Roman;\">5</span><span style=\"font-family:宋体;\">个约束实现基本平衡：</span><br>&nbsp;&nbsp;&nbsp; ①结点是红色或黑色；<br>&nbsp;&nbsp;&nbsp; ②根是黑色；<br>&nbsp;&nbsp;&nbsp; ③叶结点是黑色；<br>&nbsp;&nbsp;&nbsp; ④红色结点的子结点都是黑色；<br>&nbsp;&nbsp;&nbsp; ⑤任一结点到其叶结点的简单路径中黑色结点数相同。</p>\n<p>&nbsp;&nbsp;&nbsp; AVL树根到叶结点最长距离与最短距离的比不超过2。红黑树的约束也保证了这一特性（最长路径是红黑相间，最短路径是全黑，这种情况下最长路径刚好是最短路径的2倍长）。</p>\n<p>&nbsp;&nbsp;&nbsp; 既然是平衡二叉查找树的一种实现，那么红黑树自然是内部有序的，同时跟AVL树一样支持O(log2n)时间复杂度的查找、插入和删除。</p>\n<p>&nbsp;&nbsp;&nbsp; 相比AVL树，红黑可以保证在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个结点。尽管最坏情况下需对O(log2n)个结点重染色，但就分摊意义（平均效率）而言，仅为O(1)个。但是因为没有严格约束树的平衡特性，红黑树的左右子树高度差比AVL树要大。</p>\n<h2 id=\"2-2-ngx-rbtree-h\"><a href=\"#2-2-ngx-rbtree-h\" class=\"headerlink\" title=\"2.2 ngx_rbtree.h\"></a>2.2 ngx_rbtree.h</h2><p>&nbsp;&nbsp;&nbsp; 机会难得，我们就把nginx的源码作为素材来深入了解一下红黑树的实现。首先是结点的结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">ngx_uint_t</span> <span class=\"hljs-type\">ngx_rbtree_key_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">ngx_int_t</span> <span class=\"hljs-type\">ngx_rbtree_key_int_t</span>;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_node_s</span> <span class=\"hljs-type\">ngx_rbtree_node_t</span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_node_s</span> &#123;<br>    <span class=\"hljs-type\">ngx_rbtree_key_t</span>    key;<span class=\"hljs-comment\">//平台相关的无符号整型关键字</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *left;<span class=\"hljs-comment\">//左子结点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *right;<span class=\"hljs-comment\">//&lt;span style=&amp;quot;font-family:宋体;&amp;quot;&gt;右&lt;/span&gt;子结点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *parent;<span class=\"hljs-comment\">//父结点指针</span><br>    u_char          color;<span class=\"hljs-comment\">//结点颜色</span><br>    u_char          data;<span class=\"hljs-comment\">//结点数据</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 然后是红黑树的结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_s</span>  <span class=\"hljs-type\">ngx_rbtree_t</span>;  <span class=\"hljs-comment\">//“_s”是结构体“_t”是类型</span><br><span class=\"hljs-comment\">//下面是一个函数指针变量类型的定义，是红黑树插入函数的指针</span><br><span class=\"hljs-comment\">//参数有树根结点、插入结点和哨兵结点的指针</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*ngx_rbtree_insert_pt)</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *root,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_s</span> &#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *root;    <span class=\"hljs-comment\">//根节点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel;    <span class=\"hljs-comment\">//哨兵结点指针</span><br>    ngx_rbtree_insert_pt   insert;  <span class=\"hljs-comment\">//插入函数指针</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 将函数指针变量作为结构体成员变量以达成可以把结构体当做类来使用（既有成员变量又有成员方法）的效果，这种手法在<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的源码中相当普遍。关于函数，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">还有一种更神奇的手段</span><span style=\"font-family:Times New Roman;\">——</span><span style=\"font-family:宋体;\">宏：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbtree_init(tree, s, i)                 \\</span><br><span class=\"hljs-meta\">    ngx_rbtree_sentinel_init(s);                \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;root = s;                       \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;sentinel = s;                   \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;insert = i<span class=\"hljs-comment\">//这里insert函数指针的赋值实现了多态</span></span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 借助宏来达成内联函数的效果（函数实现如果比较简单，就干脆把实现过程整个搬到类中），令人费解的是，<span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">不是没有内联关键字，甚至同一个头文件中就有一个内联函数的定义。研究内联函数之前，下面还有几个宏要看一看：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_red(node)           ((node)-&gt;color = 1)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_black(node)         ((node)-&gt;color = 0)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_is_red(node)            ((node)-&gt;color)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_is_black(node)          (!ngx_rbt_is_red(node))</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_copy_color(n1, n2)      (n1-&gt;color = n2-&gt;color)</span><br><br><span class=\"hljs-comment\">/* a sentinel must be black */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbtree_sentinel_init(node)  ngx_rbt_black(node)</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">源码中的变量都很容易看懂以至于我们不怎么需要查资料或找注释。</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">置</span><span style=\"font-family:Times New Roman;\">1</span><span style=\"font-family:宋体;\">染红置</span><span style=\"font-family:Times New Roman;\">0</span><span style=\"font-family:宋体;\">染黑，</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">1</span><span style=\"font-family:宋体;\">则结点为红色，不为红色的则为黑色，复制结点颜色即复制</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">值，哨兵结点一定要染成黑色。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ngx_inline <span class=\"hljs-type\">ngx_rbtree_node_t</span> *</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_min</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *node, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (node-&gt;left != sentinel) &#123;<br>        node = node-&gt;left;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; ngx_inline是一个宏，实际值就是关键字inline。这个内联函数非常好懂，目的看起来是寻找以任意结点为根结点的子树中结点值最小的结点。实现方法是找到红黑树子树最边缘的左子结点。那么我们有理由猜测，哨兵结点是空结点或边缘标识。</p>\n<h2 id=\"2-3-红黑树的结点插入\"><a href=\"#2-3-红黑树的结点插入\" class=\"headerlink\" title=\"2.3 红黑树的结点插入\"></a><span style=\"font-family:宋体;\">2.3 红黑树的结点插入</span></h2><p>&nbsp;&nbsp;&nbsp; 接下来我们来深入<span style=\"font-family:Times New Roman;\">ngx_rbtree.c</span><span style=\"font-family:宋体;\">看看</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">如何实现几个关键的红黑树方法。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_t</span> *tree, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//根结点指针的指针，或者根结点指针数组，会有多个根结点吗，令人费解</span><br>    <span class=\"hljs-comment\">//临时结点指针</span><br>    <span class=\"hljs-comment\">//哨兵结点指针，推测哨兵在每次查询时可能都不一样，也许指待插位置</span><br>    <span class=\"hljs-comment\">//变量不分行，我写注释都很不方便</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  **root, *temp, *sentinel;<br><br>    <span class=\"hljs-comment\">/* a binary tree insert */</span><br><br>    root = (<span class=\"hljs-type\">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<span class=\"hljs-comment\">//树根指针的指针赋给了root</span><br>    sentinel = tree-&gt;sentinel;<span class=\"hljs-comment\">//哨兵指针赋给了哨兵指针</span><br><br>    <span class=\"hljs-keyword\">if</span> (*root == sentinel) &#123;<span class=\"hljs-comment\">//特判，如果根是哨兵，即树是空的</span><br>        node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<span class=\"hljs-comment\">//新插入的结点变成了根</span><br>        node-&gt;left = sentinel;<span class=\"hljs-comment\">//新结点的左子结点是哨兵</span><br>        node-&gt;right = sentinel;<span class=\"hljs-comment\">//新结点的右子结点也是哨兵</span><br>        <span class=\"hljs-built_in\">ngx_rbt_black</span>(node);<span class=\"hljs-comment\">//新根染黑</span><br>        *root = node;<span class=\"hljs-comment\">//确认新结点为新根</span><br><br>        <span class=\"hljs-keyword\">return</span>;<span class=\"hljs-comment\">//插入结束</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">//树初始化时给了insert指针一个函数地址</span><br>    <span class=\"hljs-comment\">//查看前面的宏ngx_rbtree_init(tree, s, i)</span><br>    <span class=\"hljs-comment\">//发现只是把指定结点染黑，同时赋为根和哨兵，给insert指针指定一个函数</span><br>    <span class=\"hljs-comment\">//ngx_rbtree.c中有两个参数表符合的可选函数：插入值、插入计时器值</span><br>    <span class=\"hljs-comment\">//稍后来看两种插入分别如何实现又有什么区别</span><br>    tree-&gt;<span class=\"hljs-built_in\">insert</span>(*root, node, sentinel);<br><br>    <span class=\"hljs-comment\">/* re-balance tree */</span><br>    <span class=\"hljs-comment\">//如果新结点不是根且其父结点是红的，循环</span><br>    <span class=\"hljs-keyword\">while</span> (node != *root &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_red</span>(node-&gt;parent)) &#123;<br>        <span class=\"hljs-comment\">//如果父结点是左子结点，获得父结点的右兄弟</span><br>        <span class=\"hljs-keyword\">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left) &#123;<br>            temp = node-&gt;parent-&gt;parent-&gt;right;<br>            <span class=\"hljs-comment\">//如果父结点的右兄弟是红的</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(temp)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//父结点染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//父结点的右兄弟染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//父结点的父结点染红</span><br>                node = node-&gt;parent-&gt;parent;<span class=\"hljs-comment\">//父结点的父结点成为当前结点</span><br><br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点的右兄弟是黑的</span><br>                <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;right) &#123;<span class=\"hljs-comment\">//如果新结点是右子结点</span><br>                    node = node-&gt;parent;<span class=\"hljs-comment\">//父结点成为新node</span><br>                    <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, node);<span class=\"hljs-comment\">//node左旋</span><br><br>                &#125;<br><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//node的父结点染黑</span><br>                <span class=\"hljs-comment\">//node的父结点的父结点染红</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<br>                <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//node的父结点的父结点右旋</span><br>            &#125;<br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点是右子结点，获得父结点的左兄弟</span><br>            temp = node-&gt;parent-&gt;parent-&gt;left;<br>            <span class=\"hljs-comment\">//如果父结点的左兄弟是红的</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(temp)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//父结点染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//父结点的左兄弟染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//父结点的父结点染红</span><br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点的左兄弟是黑的</span><br>                <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果新结点是左子结点</span><br>                    node = node-&gt;parent;<span class=\"hljs-comment\">//父结点成为当前结点</span><br>                    <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, node);<br>                    <span class=\"hljs-comment\">//当前结点右旋</span><br>                &#125;<br><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//当前结点染黑</span><br>                <span class=\"hljs-comment\">//当前结点父结点的父结点染红</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<br>                <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//当前结点的父结点的父结点左旋</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-built_in\">ngx_rbt_black</span>(*root);<span class=\"hljs-comment\">//根结点染黑</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 然后是对应ngx_rbtree_insert_pt指针的基础的结点插入函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_insert_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *temp, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  **p;<span class=\"hljs-comment\">//虽然无关紧要，但两层指针令人费解</span><br><br>    <span class=\"hljs-keyword\">for</span> ( ;; ) &#123;<span class=\"hljs-comment\">//无条件循环或者说死循环，等同于while(1)但节省了一个字符</span><br><br>        p = (node-&gt;key &lt; temp-&gt;key) ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class=\"hljs-keyword\">if</span> (*p == sentinel) &#123;<span class=\"hljs-comment\">//在二叉树中查找新结点合适的叶结点位置</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br>    <span class=\"hljs-comment\">//令新结点占据合适的哨兵位置成为新的叶结点，染红，产生新哨兵</span><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    <span class=\"hljs-built_in\">ngx_rbt_red</span>(node);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; ngx_rbtree_insert_timer_value<span style=\"font-family:宋体;\">函数跟</span><span style=\"font-family:Times New Roman;\">ngx_rbtree_insert_value</span><span style=\"font-family:宋体;\">函数唯一区别就是判断大小时，采用了两个值相减，避免溢出。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 以上是插入结点涉及的函数，老实说我不太喜欢这么长的函数实现，换我自己写肯定分块了。分支操作太多，看代码逻辑已经乱了，我们需要画几个图。首先，如果树为空：</p>\n<p><img src=\"http://img.blog.csdn.net/20150806074055339\" alt=\"\" /><br /></p>\n<p>&nbsp;&nbsp;&nbsp; 如果树中只有一个根结点：</p>\n<img src=\"http://img.blog.csdn.net/20150806074132691\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">C&gt;A</span><span style=\"font-family:宋体;\">：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074207378\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">C&lt;B&lt;A</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">染红，</span><span style=\"font-family:Times New Roman;\">B</span><span style=\"font-family:宋体;\">染黑</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">染红，</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">右旋。右旋函数如下：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ngx_inline <span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_right_rotate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> **root, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;left;<br>    node-&gt;left = temp-&gt;right;<span class=\"hljs-comment\">//左子结点指向原左子结点的右结点</span><br><br>    <span class=\"hljs-keyword\">if</span> (temp-&gt;right != sentinel) &#123;<span class=\"hljs-comment\">//如果左子结点的右结点不为哨兵</span><br>        temp-&gt;right-&gt;parent = node;<span class=\"hljs-comment\">//左子结点的右子结点挂在右旋结点上</span><br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<span class=\"hljs-comment\">//左子结点挂在右旋结点的父结点上</span><br><br>    <span class=\"hljs-keyword\">if</span> (node == *root) &#123;<span class=\"hljs-comment\">//如果右旋结点为根节点</span><br>        *root = temp;<span class=\"hljs-comment\">//根节点赋为左子结点</span><br><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;right) &#123;<span class=\"hljs-comment\">//如果右旋结点为右子结点</span><br>        node-&gt;parent-&gt;right = temp;<span class=\"hljs-comment\">//左子结点挂父结点右边</span><br><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//否则左子结点挂父结点左边</span><br>        node-&gt;parent-&gt;left = temp;<br>    &#125;<br><br>    temp-&gt;right = node;<span class=\"hljs-comment\">//右旋结点挂左子结点右边</span><br>    node-&gt;parent = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 显然<span style=\"font-family:Times New Roman;\">B</span><span style=\"font-family:宋体;\">将成为新的根，左</span><span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">右</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074443292\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">B&lt;C&lt;A</span><span style=\"font-family:宋体;\">，会先做一次左旋再做一次右旋，其实除开染色过程，我觉得这跟</span><span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树的插入过程没有什么区别：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074520668\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 其他的插入情景要么与以上几个对称，要么发生在树的其他子树中，实际过程完全一样。LL<span style=\"font-family:宋体;\">型右旋，</span><span style=\"font-family:Times New Roman;\">RR</span><span style=\"font-family:宋体;\">型左旋，</span><span style=\"font-family:Times New Roman;\">LR</span><span style=\"font-family:宋体;\">型先右旋后左旋，</span><span style=\"font-family:Times New Roman;\">RL</span><span style=\"font-family:宋体;\">型先左旋后右旋。</span>与<span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树不同的是，插入结点时红黑树左旋或右旋的判定条件明确为附近一两个结点的颜色，其他过程没有任何区别。</span></p>\n<h2 id=\"2-4-红黑树的结点删除\"><a href=\"#2-4-红黑树的结点删除\" class=\"headerlink\" title=\"2.4 红黑树的结点删除\"></a>2.4 红黑树的结点删除</h2><p>&nbsp;&nbsp;&nbsp; 据说红黑树和<span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树的区别主要体现在删除节点时，我们就来看一看。</span>我刚说什么来着，删除结点的函数体更长了，足足<span style=\"font-family:Times New Roman;\">165</span><span style=\"font-family:宋体;\">行，我决定分段研究，</span>先看第一部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (node-&gt;left == sentinel) &#123;<span class=\"hljs-comment\">//如果左子结点是哨兵或左右子结点都是哨兵</span><br>    temp = node-&gt;right;<span class=\"hljs-comment\">//获得右子结点，后面让它接替node位置</span><br>    subst = node;<span class=\"hljs-comment\">//node赋给subst</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node-&gt;right == sentinel) &#123;<span class=\"hljs-comment\">//如果右子结点是哨兵</span><br>    temp = node-&gt;left;<span class=\"hljs-comment\">//获得左子结点，后面让它接替node位置</span><br>    subst = node;<span class=\"hljs-comment\">//node赋给subst</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果左右子结点都不是哨兵</span><br>    subst = <span class=\"hljs-built_in\">ngx_rbtree_min</span>(node-&gt;right, sentinel);<span class=\"hljs-comment\">//获得右子树中最小的结点</span><br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;left != sentinel) &#123;<span class=\"hljs-comment\">//如果右子树的最小结点的左子结点不是哨兵</span><br>        temp = subst-&gt;left;<span class=\"hljs-comment\">//获得右子树的最小结点的左子结点</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//否则获得右子树最小结点的右子结点</span><br>        temp = subst-&gt;right;<br>    &#125;<span class=\"hljs-comment\">//看起来subst将被从原位置删掉然后接替node的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 下面我们来看看<span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">要干什么用：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (subst == *root) &#123;<span class=\"hljs-comment\">//如果subst是根</span><br>    *root = temp;<span class=\"hljs-comment\">//temp接替根</span><br>    <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//染黑temp</span><br><br>    <span class=\"hljs-comment\">/* DEBUG stuff */</span><br>    node-&gt;left = <span class=\"hljs-literal\">NULL</span>;<span class=\"hljs-comment\">//清空了待删结点</span><br>    node-&gt;right = <span class=\"hljs-literal\">NULL</span>;<br>    node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<br>    node-&gt;key = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br>red = <span class=\"hljs-built_in\">ngx_rbt_is_red</span>(subst);<span class=\"hljs-comment\">//获得subst是否是红色</span><br><br><span class=\"hljs-keyword\">if</span> (subst == subst-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果subst是左子结点</span><br>    subst-&gt;parent-&gt;left = temp;<span class=\"hljs-comment\">//把接替结点挂到subst位置</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果subst是右子结点</span><br>    subst-&gt;parent-&gt;right = temp;<span class=\"hljs-comment\">//把接替结点挂到subst位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 下一段：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (subst == node) &#123;<span class=\"hljs-comment\">//如果subst是待删结点</span><br>    temp-&gt;parent = subst-&gt;parent;<span class=\"hljs-comment\">//接替结点直接接替，删除完成</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果subst不是待删结点</span><br>     <span class=\"hljs-keyword\">if</span> (subst-&gt;parent == node) &#123;<span class=\"hljs-comment\">//如果subst的父结点就是待删结点</span><br>        temp-&gt;parent = subst;<span class=\"hljs-comment\">//接替结点挂在subst上</span><br>     &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果待删结点比subst的父结点更高</span><br>        temp-&gt;parent = subst-&gt;parent;<span class=\"hljs-comment\">//把接替结点挂在subst的父结点上</span><br>    &#125;<br>    <span class=\"hljs-comment\">//subst接替待删结点node的位置，复制待删结点跟周围结点的关系</span><br>    subst-&gt;left = node-&gt;left;<br>    subst-&gt;right = node-&gt;right;<br>    subst-&gt;parent = node-&gt;parent;<br>    <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(subst, node);<span class=\"hljs-comment\">//复制颜色</span><br><br>    <span class=\"hljs-keyword\">if</span> (node == *root) &#123;<span class=\"hljs-comment\">//如果待删结点是根</span><br>        *root = subst;<span class=\"hljs-comment\">//subst接替根</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果待删结点不是根，subst接替它</span><br>        <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>            node-&gt;parent-&gt;left = subst;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            node-&gt;parent-&gt;right = subst;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;left != sentinel) &#123;<span class=\"hljs-comment\">//如果subst左子结点不是哨兵</span><br>        subst-&gt;left-&gt;parent = subst;<span class=\"hljs-comment\">//subst的左子结点放弃node，挂上来</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;right != sentinel) &#123;<span class=\"hljs-comment\">//如果subst右子结点不是哨兵</span><br>        subst-&gt;right-&gt;parent = subst;<span class=\"hljs-comment\">//subst右子结点放弃node，挂上来</span><br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//清空待删结点node</span><br><span class=\"hljs-comment\">/* DEBUG stuff */</span><br>node-&gt;left = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;right = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;key = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">//如果subst是红色，红黑树约束依然被遵守，删除工作就可以结束了</span><br><span class=\"hljs-keyword\">if</span> (red) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 看起来结点的删除过程已经顺利完成了，但是如果<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是黑色，我们需要修复红黑树的约束。下面这一段代码的主角是接替</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">位置的</span><span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">结点：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//当subst的接替结点不是根且为黑色，循环</span><br><span class=\"hljs-keyword\">while</span> (temp != *root &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(temp)) &#123;<br>    <span class=\"hljs-keyword\">if</span> (temp == temp-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果temp是左子结点</span><br>        w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得其右兄弟</span><br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(w)) &#123;<span class=\"hljs-comment\">//如果temp的右兄弟是红色</span><br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w);<span class=\"hljs-comment\">//染黑temp的右兄弟</span><br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(temp-&gt;parent);<span class=\"hljs-comment\">//染红temp的父结点</span><br>            <span class=\"hljs-comment\">//temp的父结点左旋</span><br>            <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, temp-&gt;parent);<br>            w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得temp的新右兄弟</span><br>        &#125;<br>        <span class=\"hljs-comment\">//如果temp右兄弟的左右子结点都是黑的</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left) &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<span class=\"hljs-comment\">//染红temp的右兄弟</span><br>            temp = temp-&gt;parent;<span class=\"hljs-comment\">//获得temp的父结点为新temp</span><br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果temp右兄弟的子结点不全为黑</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<span class=\"hljs-comment\">//如果其右子结点是黑色</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;left);<span class=\"hljs-comment\">//染黑左子结点</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<span class=\"hljs-comment\">//染红temp的右兄弟</span><br>                <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, w);<span class=\"hljs-comment\">//右兄弟右旋</span><br>                w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得temp的新右兄弟</span><br>            &#125;<br>            <span class=\"hljs-comment\">//temp右兄弟复制temp父结点颜色</span><br>            <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(w, temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp-&gt;parent);<span class=\"hljs-comment\">//染黑temp父结点</span><br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;right);<span class=\"hljs-comment\">//染黑temp右兄弟的右子结点</span><br>            <span class=\"hljs-comment\">//temp父结点左旋</span><br>            <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, temp-&gt;parent);<br>            temp = *root;<span class=\"hljs-comment\">//获得根</span><br>        &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果temp是右子结点，做对称的事</span><br>        w = temp-&gt;parent-&gt;left;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(w)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w);<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, temp-&gt;parent);<br>            w = temp-&gt;parent-&gt;left;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left) &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<br>            temp = temp-&gt;parent;<br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;right);<br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<br>                <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, w);<br>                w = temp-&gt;parent-&gt;left;<br>            &#125;<br><br>            <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(w, temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;left);<br>            <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, temp-&gt;parent);<br>            temp = *root;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//染黑当前temp</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 跟插入结点时一样乱，我们梳理一下。</p>\n<p>&nbsp;&nbsp;&nbsp; 首先忽略红黑树的约束进行删除：<br>&nbsp;&nbsp;&nbsp; ①如果删除的是一个叶结点，即没有后继或后继全为哨兵的结点，直接删除即可；<br>&nbsp;&nbsp;&nbsp; ②如果只有一个后继，让其替换待删除结点即可；<br>&nbsp;&nbsp;&nbsp; ③如果有两个后继，需要从树的边缘选择一个结点，有两种等价的选择，待删结点左子树的最大结点和右子树的最小结点，<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">选择的是后者，以这个结点的键与值（</span><span style=\"font-family:Times New Roman;\">key</span><span style=\"font-family:宋体;\">与</span><span style=\"font-family:Times New Roman;\">value&#x2F;data</span><span style=\"font-family:宋体;\">）替换待删结点的键与值，然后删除这个替身。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 不论是①、②情景中的待删结点还是③情景中替身，在源码中都是subst。下面要围绕着它来进行讨论。</p>\n<p>&nbsp;&nbsp;&nbsp; 以上是不考虑红黑树平衡性的纯拓扑结构变动。下面要考虑是否调整树的拓扑结构使树重新平衡，是否调整结点的颜色使树重新符合红黑树的约束条件。我们知道红黑树有一条关键约束是任意结点到其子树中叶结点的简单路径中黑色结点数相同。那么如果<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是一个红色结点，我们不需要对红黑树做任何调整，它仍是一棵红黑树；如果</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是黑色的，所有经过</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">的简单路径上都会少一个黑色结点数，所以需要进行调整。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 下面来根据不同情景分情况讨论，因为二叉树的情景左右颠倒时调整方式也可以左右颠倒，我们只讨论<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是左子结点的情况。设刚接替</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">X</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">X</span><span style=\"font-family:宋体;\">的新右兄弟为</span><span style=\"font-family:Times New Roman;\">W</span><span style=\"font-family:宋体;\">。从经过简化的源码来看，关于结点颜色的变化很令人费解，我们不妨先来看一看：</span><br>&nbsp;&nbsp;&nbsp; ①W为红色：将W染黑，将X与W的父结点X-&gt;parent染红，X-&gt;parent左旋，W重设为X的新右兄弟，然后转入情景①、②或③；<br>&nbsp;&nbsp;&nbsp; ②W为黑色，W两个后继都是黑色：将W染红，X重设为X-&gt;parent；<br>&nbsp;&nbsp;&nbsp; ③W为黑色，W右子结点为黑色：将W左子结点染黑，将W染红，W右旋，W重设为X的新右兄弟，然后将X-&gt;parent的颜色赋给W，将X-&gt;parent染黑，X-&gt;parent左旋，根赋给temp；<br>&nbsp;&nbsp;&nbsp; ④W为黑色，W右子结点为红色：将W左子结点染黑，将W染红，W右旋，W重设为X的新右兄弟，然后将X-&gt;parent的颜色赋给W，将X-&gt;parent染黑，将W右子结点染黑，X-&gt;parent左旋，根赋给temp。</p>\n<p>&nbsp;&nbsp;&nbsp; 最后还要把temp染黑。我们可以看到情景①中进行了一次左旋，情景②只进行了染色，情景③、④都进行了一次右旋和一次左旋。情景①处理结束时一定还要转入别的情景，情景②、③、④的出现则标志着本次调整的结束。那么，红黑树删除结点后的调整过程中，依情景①循环出现的次数，调整过程中旋转的最多见的次数将是1次、2次、3次，再往上次数越多越罕见（依情景①循环出现的次数），最多旋转次数将可能到达树高即log2n次。生产环境中，删除结点后平均每次调整中旋转的次数就像分析源码之前提到的，将是常数规模的。</p>\n<p>&nbsp;&nbsp;&nbsp; 接下来我打算以逐步翻新版本的方式重写红黑树，更精细、直观地了解红黑树这一数据结构。而在重写之前，我们需要了解，nginx的红黑中所有的叶结点，都是哨兵（sentinel），这在调整红黑树时达成了对红黑树的一种优化。通过增加一层全黑的子结点，红黑树中实际有值的子树里，就允许在子结点出现红色结点了。虽然我没有证明，但这常数规模地增加了删除结点时的旋转次数，也促进了插入新结点时进行调整的概率（增加了在红色结点下插入新结点的概率），同样增加了旋转的次数。而旋转将压缩红黑树子树的高度，提高查询效率。</p>\n<p>&nbsp;&nbsp;&nbsp; 在由朴素到精致地重写红黑树的过程中，我将由少到多地考虑使用nginx对红黑树的优化，或者加入我自己的优化。</p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">从杭州回来后翻了CLRS（算法导论），发现：<br>&nbsp;&nbsp;&nbsp; 首先，nginx的红黑树中，sentinel结点并非独创的优化手段，CLRS的红黑树也是带哨兵的，可以说，一般的，我们令红黑树带哨兵。目的是更直截了当的满足红黑树的叶结点全黑约束，同时更方便标识树的边缘。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">其次，所有的叶结点都是由同一个哨兵结点代表，节省了空间开销，省去了叶结点逐一染色的麻烦。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">另外，之前我感到迷惑的static inline组合用法，在oschina.net获得了解释：<br>&nbsp;&nbsp;&nbsp; 1.inline函数是不能像传统的函数那样放在.c中然后在.h中给出接口在其余文件中调用的,因为inline函数其实是跟宏定义类似，被调用时尝试在调用处直接展开整个函数体，不存在所谓的函数入口。<br>&nbsp;&nbsp;&nbsp; 2.因为第一点，会出现一个问题，如果inline函数在两个不同的文件中出现。也就是说一个头文件被两个不同的源文件包含，则会出现重名，链接失败。static inline 的用法就能很好的解决这个问题。使用static修饰符，函数仅在文件内部可见，不会污染命名空间。可以理解为一个inline函数在不同的源文件里面生成了不同的实例，而且名字是完全相同的 。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">总结一下。功能上，我们需要微型函数被大量调用时尝试内联展开以节省压栈弹栈的开销；实践中，为了防止不同文件中函数同名时的链接错误，我们需要加上static关键字的限制。（尽管inline关键字的效果有所不同，c99标准和gcc下static inline组合是兼容的，效果相同）</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">之前看到nginx源码中函数参数有双重指针一直很费解，今天研究了一下才发现原因。ngx_rbtree_t中，root经常使用双重结点指针，也就是根结点地址的地址。如果树的修改过程中，根结点地址被别的结点地址替换掉，需要重新设置根的地址<em>root。假设ngx_rbtree_t中的根地址参数是</em>root单层指针，进入函数体时将是一个值传递，出函数体时无论函数体中如何更改根的地址，都是无效的，只有对根结点内容的修改能保留下来。所以要么使用双重指针作为根地址的参数，要么提供树结构体的地址，变相提供双重指针作为参数，当然可以提供树的结构体对象本身作为参数，但是值传递是要复制整个值对象的，显然当结构体比较大时这样做将明显增加开销。nginx选择双重指针而非结构体指针来避免树结构体内的变量遍历寻址，进一步提高效率。</span></p>\n",
            "tags": [
                "nginx",
                "ngx_int_t",
                "rbtree",
                "C"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%BA%8C%E3%80%91nginx%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B5%8F%E8%A7%88/",
            "url": "https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%BA%8C%E3%80%91nginx%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B5%8F%E8%A7%88/",
            "title": "【二】nginx源码文件结构浏览",
            "date_published": "2015-07-23T07:01:33.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 要读大项目的源码，最好还是先把项目文件组织结构弄清楚，这样后面找源码会比较方便，对整体项目的架构也能有一个具体一些的概念。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 我下载的<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">源码版本不可考，按日期来看是</span><span style=\"font-family:Times New Roman;\">2015</span><span style=\"font-family:宋体;\">年</span><span style=\"font-family:Times New Roman;\">7</span><span style=\"font-family:宋体;\">月的最新版本。解压包获得源码文件夹，进入根目录发现有几个子目录：</span><span style=\"font-family:Times New Roman;\">auto</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">conf</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">contrib</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">docs</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">misc</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">src</span><span style=\"font-family:宋体;\">。从字面上猜测，是自动机或脚本（</span><span style=\"font-family:Times New Roman;\">auto&nbsp;script</span><span style=\"font-family:宋体;\">）、配置文件（</span><span style=\"font-family:Times New Roman;\">configuration</span><span style=\"font-family:宋体;\">）、支持文件（</span><span style=\"font-family:Times New Roman;\">contributions</span><span style=\"font-family:宋体;\">）、文档（</span><span style=\"font-family:Times New Roman;\">document</span><span style=\"font-family:宋体;\">）、杂项（</span><span style=\"font-family:Times New Roman;\">miscellaneous</span><span style=\"font-family:宋体;\">）、源码（</span><span style=\"font-family:Times New Roman;\">source&nbsp;code</span><span style=\"font-family:宋体;\">）。</span></p>\n<h3 id=\"1、浏览源码文件夹根目录\"><a href=\"#1、浏览源码文件夹根目录\" class=\"headerlink\" title=\"1、浏览源码文件夹根目录\"></a>1<span style=\"font-family:宋体;\">、浏览源码文件夹根目录</span></h3><p>&nbsp;&nbsp;&nbsp; 按照惯例，我选择先看看文档，但是<span style=\"font-family:Times New Roman;\">doc</span><span style=\"font-family:宋体;\">子目录里并没有详细的离线文档，只有</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">官网的链接和一些看不懂的小文件。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 杂项<span style=\"font-family:Times New Roman;\">misc</span><span style=\"font-family:宋体;\">里也只有看不太懂的一个</span><span style=\"font-family:Times New Roman;\">GNUmakefile</span><span style=\"font-family:宋体;\">和一个</span><span style=\"font-family:Times New Roman;\">README</span><span style=\"font-family:宋体;\">文件。</span></p>\n<p>&nbsp;&nbsp;&nbsp; contrib<span style=\"font-family:宋体;\">子目录里有一个</span><span style=\"font-family:Times New Roman;\">geo2nginx.pl</span><span style=\"font-family:宋体;\">（</span><span style=\"font-family:Times New Roman;\">geo</span><span style=\"font-family:宋体;\">模块的</span><span style=\"font-family:Times New Roman;\">CSV</span><span style=\"font-family:宋体;\">数据库格式转换</span><span style=\"font-family:Times New Roman;\">perl</span><span style=\"font-family:宋体;\">脚本），一套编码转换文件（包括两个编码映射表和一个编码转换</span><span style=\"font-family:Times New Roman;\">perl</span><span style=\"font-family:宋体;\">脚本），和</span><span style=\"font-family:Times New Roman;\">vim</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">专用语法高亮配置文件。</span></p>\n<p>&nbsp;&nbsp;&nbsp; conf<span style=\"font-family:宋体;\">子目录里有几个编码映射表、变量映射表和一个服务器配置文件。</span></p>\n<p>&nbsp;&nbsp;&nbsp; auto<span style=\"font-family:宋体;\">子目录里有包括服务器安装脚本在内的许多脚本，现在看脚本还比较吃力，所以只简单浏览一下。我们发现</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">支持很多主流的操作系统平台：苹果的开源系统</span><span style=\"font-family:Times New Roman;\">darwin</span><span style=\"font-family:宋体;\">、重要的</span><span style=\"font-family:Times New Roman;\">Unix</span><span style=\"font-family:宋体;\">分支</span><span style=\"font-family:Times New Roman;\">freebsd</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">linux</span><span style=\"font-family:宋体;\">、大多数版本已经开源的又一个</span><span style=\"font-family:Times New Roman;\">Unix</span><span style=\"font-family:宋体;\">分支</span><span style=\"font-family:Times New Roman;\">solaris</span><span style=\"font-family:宋体;\">、用户占有率最高的</span><span style=\"font-family:Times New Roman;\">win32</span><span style=\"font-family:宋体;\">。</span></p>\n<p>&nbsp;&nbsp;&nbsp; src<span style=\"font-family:宋体;\">子目录果然都是需要研究的</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">源码，下面我们会深入浏览。</span></p>\n<h3 id=\"2、浏览src子目录\"><a href=\"#2、浏览src子目录\" class=\"headerlink\" title=\"2、浏览src子目录\"></a>2<span style=\"font-family:宋体;\">、浏览</span><span style=\"font-family:Times New Roman;\">src</span><span style=\"font-family:宋体;\">子目录</span></h3><p>&nbsp;&nbsp;&nbsp; 还是来看一下<span style=\"font-family:Times New Roman;\">src</span><span style=\"font-family:宋体;\">子目录下有哪些子目录：</span><span style=\"font-family:Times New Roman;\">core</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">event</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">http</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">mail</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">misc</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">mysql</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">os</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">stream</span><span style=\"font-family:宋体;\">。还是来按照字面意思猜测一下：核心（主函数、数据结构、主要方法）、事件（事件处理机制）、超文本传输协议（</span><span style=\"font-family:Times New Roman;\">http</span><span style=\"font-family:宋体;\">相关）、邮件（邮件相关）、杂项（</span><span style=\"font-family:Times New Roman;\">google&nbsp;perftools</span><span style=\"font-family:宋体;\">相关源码）、</span><span style=\"font-family:Times New Roman;\">mysql</span><span style=\"font-family:宋体;\">数据库、操作系统（</span><span style=\"font-family:Times New Roman;\">Unix</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">Win32</span><span style=\"font-family:宋体;\">两类系统的系统调用程序源码）、流（意义不明）。看起来</span><span style=\"font-family:Times New Roman;\">.&#x2F;src&#x2F;core</span><span style=\"font-family:宋体;\">子目录对研究源码来说是一个不错的开始。</span></p>\n<p align=\"center\">\n    <span style=\"font-family:宋体;\"><img src=\"http://img.blog.csdn.net/20150723165913000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" /></span>\n    图<span style=\"font-family:Times New Roman;\">2&nbsp;nginx</span><span style=\"font-family:宋体;\">源码文件结构图</span>\n</p>",
            "tags": [
                "nginx"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%B8%80%E3%80%91nginx%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/",
            "url": "https://blog.bipedalbit.net/2015/07/23/%E3%80%90%E4%B8%80%E3%80%91nginx%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/",
            "title": "【一】nginx核心架构概述",
            "date_published": "2015-07-23T03:01:28.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 毕业前，毕设完成后，我闲极无聊接触了一下socket编程，用C++的Qt框架写了玩具一样的TCP和UDP通信客户端。跟直系学长电话聊天时被建议深挖一下socket，尝试走走后端或者架构师路线。问该怎么深挖，答研究源码，要学习socket相关知识，研究服务器源码是最合适不过的了。至于选择哪个服务器，经过考量调查，发现比起比较沉重庞大的apache，nginx更加小巧，也非常优秀。于是在开始正式吃源码之前，我先开始了一番自我科普工作。</p>\n<span id=\"more\"></span>\n<h3 id=\"1、进程模型\"><a href=\"#1、进程模型\" class=\"headerlink\" title=\"1、进程模型\"></a>1<span style=\"font-family:宋体;\">、进程模型</span></h3><p>&nbsp;&nbsp;&nbsp; 首先，默认的，与其他服务器一样，<span style=\"font-family:Times New Roman;\">Unix</span><span style=\"font-family:宋体;\">下的</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">也以</span><span style=\"font-family:Times New Roman;\">daemon</span><span style=\"font-family:宋体;\">（守护进程）的形式持续在后台运行。虽然</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">也可以以调试为目的关掉后台模式，使用前台模式，甚至可以通过配置取消</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程（后面会详细解释），使</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">以单进程的形式工作。但是这些与</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">引以为傲的架构关系不大，这里按下不表。尽管</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">也支持多线程方式，我们还是着重来了解下其默认的多进程方式。</span></p>\n<p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">在启动后会创建一个</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程（主进程）和若干个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程（从进程）。</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程主要负责管理</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程，具体来说就是接收来自管理员的信号并转发给对应</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程；监控</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程的工作状态，在</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程异常终止时重新创建并启动</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程。而</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程负责处理基本的网络事件。</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程之间优先级对等、相互独立，公平竞争来自客户端的请求，每个请求只由一个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程处理。</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">进程模型示意图如图</span><span style=\"font-family:Times New Roman;\">1</span><span style=\"font-family:宋体;\">所示。</span></p>\n<p align=\"center\">\n    &nbsp;<img src=\"http://img.blog.csdn.net/20150723104541689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\n    图<span style=\"font-family:Times New Roman;\">1&nbsp;nginx</span><span style=\"font-family:宋体;\">进程模型示意图</span>\n</p>\n&nbsp;&nbsp;&nbsp; worker<span style=\"font-family:宋体;\">进程的数量可以进行设置，一般设置与</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">核数一致，这一原则与</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的事件处理模型有关。后面会继续介绍</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的事件处理模型。</span>\n### 2<span style=\"font-family:宋体;\">、信号与请求</span>\n\n<p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">与外界互动无非通过两种接口界面：来自管理员的信号和来自客户端的请求。下面我们举例说明</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">是如何处理信号与请求的。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 管理员要控制<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">需要与</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程通信，向</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程发送指令信号即可。比如，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">在</span><span style=\"font-family:Times New Roman;\">0.8</span><span style=\"font-family:宋体;\">版本之前使用</span><span style=\"font-family:Times New Roman;\">kill&nbsp;-HUP pid</span><span style=\"font-family:宋体;\">命令来重启</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">。使用这个命令重启</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">将实现从容地重启过程，期间服务不中断。</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程在接到</span><span style=\"font-family:Times New Roman;\">HUP</span><span style=\"font-family:宋体;\">指令后首先会重新加载配置文件，然后启动新的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程，向旧的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程发送停止信号。这时新的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程开始接收网络请求，旧的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程停止接收新的请求，等到处理完当前请求后，旧的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程就退出销毁了。在</span><span style=\"font-family:Times New Roman;\">0.8</span><span style=\"font-family:宋体;\">版本以后，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">引入了一系列命令行参数以方便管理服务器，比如</span><span style=\"font-family:Times New Roman;\">.&#x2F;nginx&nbsp;-s&nbsp;reload</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">.&#x2F;nginx&nbsp;-s&nbsp;stop</span><span style=\"font-family:宋体;\">，分别用来重启和停止</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">。执行操作命令时，我们实际上启动了一个新的</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">进程，这个进程在解析命令中的参数后，自行向</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程发送相应的信号，达成与之前手动发送信号相同的效果。</span></p>\n<h3 id=\"3、请求与事件\"><a href=\"#3、请求与事件\" class=\"headerlink\" title=\"3、请求与事件\"></a>3<span style=\"font-family:宋体;\">、请求与事件</span></h3><p>&nbsp;&nbsp;&nbsp; 服务器最常处理的就是<span style=\"font-family:Times New Roman;\">80</span><span style=\"font-family:宋体;\">端口</span><span style=\"font-family:Times New Roman;\">http</span><span style=\"font-family:宋体;\">协议的请求了，</span> 以此为例说明一下<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">处理请求的过程。首先，每一个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程都是从</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程</span><span style=\"font-family:Times New Roman;\">fork</span><span style=\"font-family:宋体;\">（分叉）而成的，</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程中先建立好需要监听的</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">（套接字，即</span><span style=\"font-family:Times New Roman;\">IP</span><span style=\"font-family:宋体;\">地址</span><span style=\"font-family:Times New Roman;\">+</span><span style=\"font-family:宋体;\">端口号）和相应的</span><span style=\"font-family:Times New Roman;\">listenfd</span><span style=\"font-family:宋体;\">（监听文件描述符或句柄）。我们知道</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">通信中每个进程都要分配一个端口号，</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程的</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">分配工作就由</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程来完成。所有</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程的</span><span style=\"font-family:Times New Roman;\">listenfd</span><span style=\"font-family:宋体;\">在新的连接到来时变得可读，为保证只有一个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程处理连接，各</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程在注册</span><span style=\"font-family:Times New Roman;\">listenfd</span><span style=\"font-family:宋体;\">读事件前先要抢</span><span style=\"font-family:Times New Roman;\">accept_mutex</span><span style=\"font-family:宋体;\">（接受连接互斥锁），一个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程抢注连接成功后，开始读取请求、解析请求、处理请求并反馈数据给客户端。</span></p>\n<h3 id=\"4、进程模型分析\"><a href=\"#4、进程模型分析\" class=\"headerlink\" title=\"4、进程模型分析\"></a>4<span style=\"font-family:宋体;\">、进程模型分析</span></h3><p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">使用但不仅仅使用多进程请求处理模型（</span><span style=\"font-family:Times New Roman;\">PPC</span><span style=\"font-family:宋体;\">），每个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程一次只处理一个请求，使得请求间资源独立不需要上锁，进程间互不影响能并行处理请求。一个请求处理失败导致一个</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程异常退出，不会使服务中断，而是由</span><span style=\"font-family:Times New Roman;\">master</span><span style=\"font-family:宋体;\">进程立刻重新启动一个新的</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程，降低了服务器面临的整体风险，使服务更加稳定。但是相比多线程模型（</span><span style=\"font-family:Times New Roman;\">TPC</span><span style=\"font-family:宋体;\">），系统开销略大，效率略低，这需要借助别的手段来改进。</span></p>\n<h3 id=\"5、nginx的高并发机制——异步非阻塞事件机制\"><a href=\"#5、nginx的高并发机制——异步非阻塞事件机制\" class=\"headerlink\" title=\"5、nginx的高并发机制——异步非阻塞事件机制\"></a>5<span style=\"font-family:宋体;\">、nginx的高并发机制</span><span style=\"font-family:Times New Roman;\">——</span><span style=\"font-family:宋体;\">异步非阻塞事件机制</span></h3><p>&nbsp;&nbsp;&nbsp; IIS<span style=\"font-family:宋体;\">的事件处理机制是多线程，每个请求独占一个工作线程。由于多线程比较占用内存，线程间的上下文切换（反复的对寄存器组进行保护现场和恢复现场的操作）带来的</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">开销也很大，多线程机制的服务器在面临数千并发量时，会给系统造成很大的压力，高并发性能并不算理想，当然如果硬件足够出色，能够提供足够的系统资源，系统压力也就不再是问题了。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 我们深入到系统层面讨论一下多进程与多线程，阻塞式机制与非阻塞式机制的区别。</p>\n<p>&nbsp;&nbsp;&nbsp; 熟悉操作系统的同学应该了解，多线程的出现是为了在资源充足的情况下更充分的调度使用<span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">，尤其对提高多核</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">的利用率十分有益。但是线程是系统任务的最小单位，而进程却是系统分配资源的最小单位，这就意味着多线程将面临一个很大的问题：当线程数增多，资源需求变大，这些线程的母进程可能无法立即一口气申请到足够所有线程使用的资源，而当系统手里没有足够的资源满足一个进程时，它会选择让整个进程都等着。这时即使系统资源足够一部分线程正常工作，母进程也无法申请到这些资源，导致所有线程一起等待。直白的说，使用多线程，进程内的线程间可以灵活的进行调度（虽然增加了线程死锁的风险和线程切换的开销），但是却无法保证母进程在逐渐庞大沉重时还能够在系统中得到合理的调度。由此可见，多线程确实可以提高</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">利用率，但是并不是解决服务器高并发请求问题的理想解决方案，且不说在高并发状态下</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">的高利用率也无法维持。以上是</span><span style=\"font-family:Times New Roman;\">IIS</span><span style=\"font-family:宋体;\">的多线程阻塞式事件机制。</span></p>\n<p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">的多进程机制保证了每个请求独立申请系统资源，一旦满足条件，每一个请求都可以立即被处理，即非阻塞处理。但是创建进程需要的资源开销会比线程多一些，为了节约进程数，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">使用了一些进程调度算法，使</span><span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">事件处理不仅仅靠多进程机制，而是非阻塞的多进程机制。下面我们就来具体的引入</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的异步非阻塞事件处理机制。</span></p>\n<h3 id=\"6、epoll\"><a href=\"#6、epoll\" class=\"headerlink\" title=\"6、epoll\"></a>6<span style=\"font-family:宋体;\">、epoll</span></h3><p>&nbsp;&nbsp;&nbsp; Linux<span style=\"font-family:宋体;\">下，言高并发的高性能网络必</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">也正是使用了</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">模型作为网络事件的处理机制。我们先看看</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">是怎么来的。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 最早的调度方案是异步忙轮询方式，即持续的轮询<span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">事件也就是遍历</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">集合的访问状态，显然服务器空闲时这一方案造成了无谓的</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">开销。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 后来，<span style=\"font-family:Times New Roman;\">select</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">poll</span><span style=\"font-family:宋体;\">作为调度进程和提高</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">利用率的代理先后出现，字面上看，一个是</span><span style=\"font-family:Times New Roman;\">“</span><span style=\"font-family:宋体;\">选择</span><span style=\"font-family:Times New Roman;\">”</span><span style=\"font-family:宋体;\">，一个是</span><span style=\"font-family:Times New Roman;\">“</span><span style=\"font-family:宋体;\">投票</span><span style=\"font-family:Times New Roman;\">”</span><span style=\"font-family:宋体;\">，它们的本质相同，都是轮询</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">集合并处理请求，与之前不同的地方在于，它们能够监视</span><span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">事件，空闲时轮询线程将被阻塞，而一个或多个</span><span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">事件到来时则被唤醒，摆脱了</span><span style=\"font-family:Times New Roman;\">“</span><span style=\"font-family:宋体;\">忙轮询</span><span style=\"font-family:Times New Roman;\">”</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">“</span><span style=\"font-family:宋体;\">忙</span><span style=\"font-family:Times New Roman;\">”</span><span style=\"font-family:宋体;\">，成为异步轮询方式。</span><span style=\"font-family:Times New Roman;\">select&#x2F;poll</span><span style=\"font-family:宋体;\">模型轮询的是整个</span><span style=\"font-family:Times New Roman;\">FD</span><span style=\"font-family:宋体;\">（文件描述符）集合即</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">集合，网络事件处理效率随着并发请求数线性降低，所以使用一个宏来限制最大并发连接数。同时，</span><span style=\"font-family:Times New Roman;\">select&#x2F;poll</span><span style=\"font-family:宋体;\">模型的内核空间与用户空间通信方式为内存复制，带来较高的开销。以上缺点催生了新模型的产生。</span></p>\n<p>&nbsp;&nbsp;&nbsp; epoll<span style=\"font-family:宋体;\">可以认为是</span><span style=\"font-family:Times New Roman;\">event&nbsp;poll</span><span style=\"font-family:宋体;\">的简写，</span>是<span style=\"font-family:Times New Roman;\">Linux</span><span style=\"font-family:宋体;\">内核为处理大批量文件描述符而作了改进的</span><span style=\"font-family:Times New Roman;\">poll</span><span style=\"font-family:宋体;\">，是</span><span style=\"font-family:Times New Roman;\">Linux</span><span style=\"font-family:宋体;\">下多路复用</span><span style=\"font-family:Times New Roman;\">I</span>&#x2F;O<span style=\"font-family:宋体;\">接口</span><span style=\"font-family:Times New Roman;\">select&#x2F;poll</span><span style=\"font-family:宋体;\">的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统</span><span style=\"font-family:Times New Roman;\">CPU</span><span style=\"font-family:宋体;\">利用率。</span>首先，<span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">没有最大并发连接数的限制，上限是可以打开的最大文件数，这与硬件内存大小有关，</span><span style=\"font-family:Times New Roman;\">1GB</span><span style=\"font-family:宋体;\">的机器上大约是</span><span style=\"font-family:Times New Roman;\">10w</span><span style=\"font-family:宋体;\">左右；然后是</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">最显著的优点，它只对</span><span style=\"font-family:Times New Roman;\">“</span><span style=\"font-family:宋体;\">活跃</span><span style=\"font-family:Times New Roman;\">”</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">进行操作，因为只有那些被内核</span><span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">读写事件异步唤醒的</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">才被放入</span><span style=\"font-family:Times New Roman;\">ready</span><span style=\"font-family:宋体;\">队列，准备进入</span><span style=\"font-family:Times New Roman;\">worker</span><span style=\"font-family:宋体;\">进程被处理，这在实际生产环境中节省了大量轮询开销，极大的提高了事件处理效率；最后，</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">使用共享内存（</span><span style=\"font-family:Times New Roman;\">MMAP</span><span style=\"font-family:宋体;\">）的方式实现内核空间与用户空间的通信，省掉了内存复制的开销。额外的，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">中使用</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">ET</span><span style=\"font-family:宋体;\">（边缘触发）工作模式即快速工作模式。</span><span style=\"font-family:Times New Roman;\">ET</span><span style=\"font-family:宋体;\">模式下，只支持非阻塞</span><span style=\"font-family:Times New Roman;\">socket</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">FD</span><span style=\"font-family:宋体;\">就绪即由内核通过</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">发送通知，经过某些操作使</span><span style=\"font-family:Times New Roman;\">FD</span><span style=\"font-family:宋体;\">不再是就绪状态时也会发送通知，但如果一直没有</span><span style=\"font-family:Times New Roman;\">I&#x2F;O</span><span style=\"font-family:宋体;\">操作导致</span><span style=\"font-family:Times New Roman;\">FD</span><span style=\"font-family:宋体;\">变为未就绪状态将不再发送通知。总的来说，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">在</span><span style=\"font-family:Times New Roman;\">Linux</span><span style=\"font-family:宋体;\">下是基于事件，利用</span><span style=\"font-family:Times New Roman;\">epoll</span><span style=\"font-family:宋体;\">处理网络事件的。</span></p>\n",
            "tags": [
                "nginx",
                "select/poll",
                "epoll"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/05/03/win-Linux%E4%B8%8B%E5%8E%BB%E6%8E%89codeigniter%E6%A1%86%E6%9E%B6%E7%BD%91%E7%AB%99URL%E4%B8%AD%E7%9A%84index-php/",
            "url": "https://blog.bipedalbit.net/2015/05/03/win-Linux%E4%B8%8B%E5%8E%BB%E6%8E%89codeigniter%E6%A1%86%E6%9E%B6%E7%BD%91%E7%AB%99URL%E4%B8%AD%E7%9A%84index-php/",
            "title": "win/Linux下去掉codeigniter框架网站URL中的index.php",
            "date_published": "2015-05-03T04:31:20.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 使用PHP的codeigniter框架后在试验阶段遇到的第一个问题就是，无法隐藏地址栏中的index.php，这让我浑身难受。多方调查之后有了一套解决方案。</p>\n<span id=\"more\"></span>\n<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux:\"></a>Linux:</h1><h2 id=\"一-Apache\"><a href=\"#一-Apache\" class=\"headerlink\" title=\"一.Apache\"></a>一.Apache</h2><h3 id=\"1-启用rewrite模块\"><a href=\"#1-启用rewrite模块\" class=\"headerlink\" title=\"1.启用rewrite模块\"></a>1.启用rewrite模块</h3><p>&nbsp;&nbsp;&nbsp; 手动启用是在Apache配置文件里把“LoadModule rewrite_module modules&#x2F;mod_rewrite.so”解注释。<br>&nbsp;&nbsp;&nbsp; 一些LAMP套件也提供更方便的模块管理。</p>\n<h3 id=\"2-rewrite规则设置\"><a href=\"#2-rewrite规则设置\" class=\"headerlink\" title=\"2.rewrite规则设置\"></a>2.rewrite规则设置</h3><p>&nbsp;&nbsp;&nbsp; 在 CI 的根目录下，即在 index.php ，system的同级目录下，建立.htaccess，直接建立该文件名不会成功，可以从application或system文件夹里复制一个过来，再修改内容。<br>&nbsp;&nbsp;&nbsp; 内容如下（ CI 手册上也有介绍）：</p>\n<pre><code class=\"hljs\">RewriteEngine On\nRewriteCond %&#123;REQUEST_FILENAME&#125; !-f\nRewriteCond %&#123;REQUEST_FILENAME&#125; !-d\nRewriteRule ^(.*)$ index.php/$1 [L]\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; <strong>如果.htaccess文件不是在www的根目录下，例如是： <a href=\"http://localhost/123/\">http://localhost/123/</a> index.php ，第三行需要改写为</strong><br>&nbsp;&nbsp;&nbsp; <code>RewriteRule ^(.*)$ /123/ index.php /$1 [L]</code></p>\n<h3 id=\"3-配置codeigniter\"><a href=\"#3-配置codeigniter\" class=\"headerlink\" title=\"3.配置codeigniter\"></a>3.配置codeigniter</h3><p>&nbsp;&nbsp;&nbsp; 找到CI文件夹&#x2F;application&#x2F;config&#x2F;config.php。<br>&nbsp;&nbsp;&nbsp; <code>$config[&#39;index_page&#39;] =&quot; index.php &quot;;</code>改写成<code>$config[&#39;index_page&#39;] = &quot;&quot;; </code></p>\n<h3 id=\"4-重启Apache\"><a href=\"#4-重启Apache\" class=\"headerlink\" title=\"4.重启Apache\"></a>4.重启Apache</h3><p>&nbsp;&nbsp;&nbsp; 这个各显神通，不累述，如Ubuntu的<code> $ sudo /etc/init.d/apache2 restart</code></p>\n<h2 id=\"二-nginx\"><a href=\"#二-nginx\" class=\"headerlink\" title=\"二.nginx\"></a>二.nginx</h2><h3 id=\"1-rewrite规则设置\"><a href=\"#1-rewrite规则设置\" class=\"headerlink\" title=\"1.rewrite规则设置\"></a>1.rewrite规则设置</h3><p>&nbsp;&nbsp;&nbsp; 修改nginx配置文件，在nginx.conf的SERVER段中添加如下代码：</p>\n<pre><code class=\"hljs\">location /&#123;\n   if (-f $request_filename) &#123;\n       expires max;\n       break;\n   &#125;\n   if (!-e $request_filename) &#123;\n       rewrite ^/(.*)$ /index.php/$1 last;\n   &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-3同上\"><a href=\"#2-3同上\" class=\"headerlink\" title=\"2.3同上\"></a>2.3同上</h3><h3 id=\"4-重启nginx\"><a href=\"#4-重启nginx\" class=\"headerlink\" title=\"4.重启nginx\"></a>4.重启nginx</h3><p>&nbsp;&nbsp;&nbsp; <code>/usr/local/nginx/sbin/nginx -s reload</code></p>\n<h1 id=\"Windows：\"><a href=\"#Windows：\" class=\"headerlink\" title=\"Windows：\"></a>Windows：</h1><h2 id=\"一-IIS7\"><a href=\"#一-IIS7\" class=\"headerlink\" title=\"一.IIS7\"></a>一.IIS7</h2><h3 id=\"1-配置web-config\"><a href=\"#1-配置web-config\" class=\"headerlink\" title=\"1.配置web.config\"></a>1.配置web.config</h3><pre><code class=\"hljs\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;system.webServer&gt;\n        &lt;rewrite&gt;\n            &lt;rules&gt;\n                &lt;rule name=&quot;OrgPage&quot; stopProcessing=&quot;true&quot;&gt;\n                    &lt;match url=&quot;^(.*)$&quot; /&gt;\n                    &lt;conditions logicalGrouping=&quot;MatchAll&quot;&gt;\n                    &lt;add input=&quot;&#123;HTTP_HOST&#125;&quot; pattern=&quot;^(.*)$&quot; /&gt;\n                    &lt;add input=&quot;&#123;REQUEST_FILENAME&#125;&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&gt;\n                    &lt;add input=&quot;&#123;REQUEST_FILENAME&#125;&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&gt;\n                    &lt;/conditions&gt;\n                    &lt;action type=&quot;Rewrite&quot; url=&quot;index.php/&#123;R:1&#125;&quot; /&gt;\n                &lt;/rule&gt;\n            &lt;/rules&gt;\n        &lt;/rewrite&gt;\n    &lt;/system.webServer&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h3 id=\"2-配置codeigniter\"><a href=\"#2-配置codeigniter\" class=\"headerlink\" title=\"2.配置codeigniter\"></a>2.配置codeigniter</h3><p>&nbsp;&nbsp;&nbsp; 找到CI文件夹&#x2F;application&#x2F;config&#x2F;config.php。<br>&nbsp;&nbsp;&nbsp; <code>$config[&#39;index_page&#39;] =&quot; index.php &quot;;</code>改写成<code>$config[&#39;index_page&#39;] = &quot;&quot;; </code></p>\n<h2 id=\"二-Apache\"><a href=\"#二-Apache\" class=\"headerlink\" title=\"二.Apache\"></a>二.Apache</h2><h3 id=\"1-启用rewrite模块-1\"><a href=\"#1-启用rewrite模块-1\" class=\"headerlink\" title=\"1.启用rewrite模块\"></a>1.启用rewrite模块</h3><p>&nbsp;&nbsp;&nbsp; 手动启用是在Apache配置文件里把“LoadModule rewrite_module modules&#x2F;mod_rewrite.so”解注释。<br>&nbsp;&nbsp;&nbsp; 一些WAMP套件也提供更方便的模块管理。</p>\n<h3 id=\"2-rewrite规则设置-1\"><a href=\"#2-rewrite规则设置-1\" class=\"headerlink\" title=\"2.rewrite规则设置\"></a>2.rewrite规则设置</h3><p>&nbsp;&nbsp;&nbsp; 找到Apache的虚拟主机配置文件，如Apache-20\\conf\\extra\\httpd-vhosts.conf。<br>&nbsp;&nbsp;&nbsp; 修改要配置的虚拟主机的Directory标签，如：</p>\n<pre><code class=\"hljs\">&lt;Directory G:/PHP/123&gt;\n    #隐藏index.php相关\n    RewriteEngine On\n    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f\n    RewriteCond %&#123;REQUEST_FILENAME&#125; !-d\n    RewriteRule ^(.*)$ index.php/$1 [L]\n    Options FollowSymLinks\n    #访问权限设置\n    #不允许别人修改页面\n    AllowOverride None\n    #依次考察允许和拒绝ip访问的设置情况\n    order allow,deny\n    #允许来自所有ip的访问\n    Allow from all\n    #deny from 202.18 即拒绝来自202.18打头的ip的访问\n&lt;/Directory&gt;\n</code></pre>\n<h3 id=\"3-配置codeigniter-1\"><a href=\"#3-配置codeigniter-1\" class=\"headerlink\" title=\"3.配置codeigniter\"></a>3.配置codeigniter</h3><p>&nbsp;&nbsp;&nbsp; 找到CI文件夹&#x2F;application&#x2F;config&#x2F;config.php。<br>&nbsp;&nbsp;&nbsp; <code>$config[&#39;index_page&#39;] =&quot; index.php &quot;;</code>改写成<code>$config[&#39;index_page&#39;] = &quot;&quot;; </code></p>\n<h3 id=\"4-重启Apache-1\"><a href=\"#4-重启Apache-1\" class=\"headerlink\" title=\"4.重启Apache\"></a>4.重启Apache</h3><p>&nbsp;&nbsp;&nbsp; win下Apache有图形界面，很方便。</p>\n",
            "tags": [
                "nginx",
                "codeigniter",
                "php",
                "IIS7",
                "apache"
            ]
        }
    ]
}