{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hacking to the gate! • All posts by \"c++\" tag",
    "description": "Bipedal Bit's blog",
    "home_page_url": "https://blog.bipedalbit.net",
    "items": [
        {
            "id": "https://blog.bipedalbit.net/2015/12/01/C-%E7%9A%84%E4%BD%8D%E4%BC%98%E5%8C%96/",
            "url": "https://blog.bipedalbit.net/2015/12/01/C-%E7%9A%84%E4%BD%8D%E4%BC%98%E5%8C%96/",
            "title": "C++的位优化",
            "date_published": "2015-12-01T02:53:29.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 之前的中国象棋初版重在实现，老实说不论是时空效率还是健壮性都不太拿得出手，于是导师要求继续优化改进。考虑和调查过后，时间效率上可以借助之前设想的并行计算得到小幅优化，此外使用类似bool数组的手段也可以在走法生成器中小幅优化边界判断过程，最重要的时间效率优化手段是把博弈机改造成查表器，即以查表为主博弈为辅改变重心。以上都是时间效率优化，这篇文中暂且不展开，我的中国象棋初版在搜索深度大时（大于等于４层）开始出现程序崩溃的现象，暴露了空间效率问题。作为空间效率优化的铺垫，这次我来做个C++位优化的自科普。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 关于空间效率优化，从前顶多考虑到基本变量类型选择的程度，然而C++提供了一些更精细的特性，供程序员进行位级别的内存微操——位域、bitset、vector&lt;bool&gt;。</p>\n<h1 id=\"1-位域\"><a href=\"#1-位域\" class=\"headerlink\" title=\"1 位域\"></a>1 位域</h1><h2 id=\"1-1-字节对齐\"><a href=\"#1-1-字节对齐\" class=\"headerlink\" title=\"1.1 字节对齐\"></a>1.1 字节对齐</h2><p>&nbsp;&nbsp;&nbsp; 介绍位域之前，还需要做一点铺垫。业界C&#x2F;C++面试、笔试题中，经常考到结构体的字节对齐问题。比如，可能会问下面两个结构体分别占多大内存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s2</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; <code>sizeof(s1)</code>和<code>sizeof(s2)</code>分别为56字节和40字节。先不管为什么装着同样变量的结构体占用的内存大小会不同，如果结构体中变量紧密排列，应该占多大内存？ａ：1字节，ｂ：4字节，ｃ：9字节，ｄ：2字节，ｅ：4字节，ｆ：8字节，ｇ：8字节，共36字节。显然这些变量实际上不是紧密排列的，存在一些对齐、填充字节的规则：</p>\n<ul>\n<li>有效对齐值默认为结构体最宽<em>基本类型</em>成员的大小，注意结构体的结构体成员必须到内部寻找基本类型成员变量计算有效对齐值；</li>\n<li>结构体变量的首地址能够被其有效对齐值所整除；</li>\n<li>结构体每个成员相对于结构体首地址的偏移量都是其本身大小的整数倍，如有需要编译器会在成员之间加上填充字节；</li>\n<li>结构体的总大小为结构体有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节；</li>\n<li>存在指定对齐值（<code>#pragma pack (value)</code>中的value）时，<code>有效对齐值 = min&#123;默认对齐值, 指定对齐值&#125;</code>。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 至于为什么要做字节对齐，这与CPU取数方式有关，尤其与CPU与内存间数据总线宽度（现在除了单片机通常为32位）有关。因为数据总线宽度是硬件相关，所以一次取数的位数是固定的，假设总线宽度32位，那么一次取数的数据大小就为4字节，那么CPU读取内存数据就将以内存首地址为基址，以4个字节为偏移量单位。如果结构体中有一个char型和一个int型变量，紧密排列存储在内存中，读char型变量时照样取了结构体的前4个字节，其中高8位的哪个字节是存储着char型变量，会经过一些位运算后被提取出来（比如按位右移24位，这仅仅是猜测），到此为止看不出什么不好的。可是当读int型变量时问题就来了，CPU无法一次读取到整个int变量了，原因前面提到了：<em>CPU读取内存数据就将以内存首地址为基址，以4个字节为偏移量单位</em>。经过两次取数才能获得被分割在两个字（32位内存单位）中完整的int型变量，这还不算完，还要分别从两个字中提取恰当的位并进行拼接，这很浪费时间。<br>&nbsp;&nbsp;&nbsp; 按特定规则进行字节对齐后，虽然浪费了一些填充字节的内存空间，情况还是好多了。以s1为例，有效对齐值是double型和long long型的8字节即两个字，这里称其为一个对齐空间，装填a（填充7个字节），装填f，装填b（填充4个字节），装填g，装填c（一个对齐空间内放不下，第二个空间中也放了1个字节，填充7个字节），装填e，装填d，结构体整体填充2字节，填满对齐空间的整数倍。<br>&nbsp;&nbsp;&nbsp; 同理也可求得s2的内存占用，至于两个结构体的内存占用不一样的原因，是它们的成员变量排列顺序不同，而结构体给成员变量分配内存的顺序与定义变量的顺序相同。<br>&nbsp;&nbsp;&nbsp; 当指定对齐值小于默认对齐值，可令结构体的成员变量排列更紧密，更省空间，但可能降低取数效率。特别的，当指定对齐值为1，结构体成员变量完全紧密排列。</p>\n<h2 id=\"1-2-位域与其利弊\"><a href=\"#1-2-位域与其利弊\" class=\"headerlink\" title=\"1.2 位域与其利弊\"></a>1.2 位域与其利弊</h2><p>&nbsp;&nbsp;&nbsp; 不管是为数据结构的成员变量设计合适的排列顺序，还是指定合适的字节对齐值，都是在字节的层次上优化程序空间效率。而使用位域，可以在位的层次上优化程序空间效率。<br>&nbsp;&nbsp;&nbsp; 还是以1.1节中的s1为例，只在字节层面上优化，以不损失时间效率为前提，最佳策略如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(4)</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>&#125;;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack()</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 实际上就是保证按32位字（4字节）对齐，变量按大小降序排列。此时的<code>sizeof(s1)</code>为36字节，空间开销等同变量成员紧密排列，时间效率没有受到影响。<br>&nbsp;&nbsp;&nbsp; 下面这种写法不知读者见过没有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(4)</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g: <span class=\"hljs-number\">21</span>;<br>\t<span class=\"hljs-type\">int</span> b: <span class=\"hljs-number\">7</span>;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>&#125;;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack()</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 对这样定义的结构体s1，<code>sizeof(s1)</code>是28字节。变量b、g后面的‘:’和数字就是位域的描述方式。位域的作用是把一些用不到当前类型变量中所有位的变量做进一步压缩，比如这里的s1结构体中的g变量，原来占用64位，使用位域压缩后g变量只使用原内存空间的高21位，填充3位补满3个字节后，原long long变量的后5个字节就可以自由分配了；b变量，原来占用32位，使用位域压缩后b变量只使用原内存空间的高7位，填充1位填满1个字节后，原int变量的后3个字节的内存空间就可以自由分配了。b、g压缩过后刚好占据4个字节一个32位字，比原来少占８个字节。<br>&nbsp;&nbsp;&nbsp; 于是，借由位域压缩技术，C++得以进行位层次的空间效率优化了。然而位域的使用有着诸多限制和缺陷：</p>\n<ul>\n<li>位域不可以用于浮点型变量的压缩；</li>\n<li>位域压缩有符号数时，由于其存储变量的编码方式是源码而非平常变量的补码，变量符号将可能出现不可预料的状态；</li>\n<li>位域压缩将局部解除变量间原有的的字节对齐规范，即使位域压缩的变量与相邻变量紧密排列，这可能引起取数时间效率的损失。</li>\n</ul>\n<h1 id=\"2-bitset\"><a href=\"#2-bitset\" class=\"headerlink\" title=\"2 bitset\"></a>2 bitset</h1><p>&nbsp;&nbsp;&nbsp; 这一节我要介绍的是比特集，正如字面意思，它是一种比特的集合的特殊数据结构。位域是C遗留下来的特性，存在很多不完备和妥协的地方,C++中推荐的替换方案之一就是bitset。它的具体使用方法我不想细讲，这里只做个概念介绍，想了解更多可以看<a href=\"http://www.cplusplus.com/reference/bitset/bitset/\">标准C++手册</a>，<del>其实是我困了懒得写</del>。<br>&nbsp;&nbsp;&nbsp; 比特集维护一个静态定义其长度的比特串，内存占用以系统字长（通常为<em>机器字长</em>，即CPU中寄存器的位数，即CPU进行数据计算的单位位宽，而非前面提到的数据总线宽度，但机器字长一定是数据总线宽度的整数倍）为单位长度，当然如果读者使用64位的机器却安装32位的系统则是把机器当做32位机使用，每个CPU寄存器只使用一半的位数。比特集可以通过包含‘０’、‘１’的字符串来构造，也可以通过无符号的整型变量来构造。为什么是无符号数？因为比特的集合本来就是逻辑的、离散的，符号在比特集中没有意义。当然如果想用某个逻辑位来作为符号位也随用户喜欢。相应的，比特集也可以转换成‘０’、‘１’字符串或者整型数。理所当然的，比特集类封装了一系列位运算符号和逻辑位操作方法，注意比特集的位操作符号两边都应该是比特集，位移操作符除外。<br>&nbsp;&nbsp;&nbsp; 也许有读者想了解bitset的内存占用情况，我进行了下面的一系列测试：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">10</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">20</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">40</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">80</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//16</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">160</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//24</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">320</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//40</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">640</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//80</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">1280</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//160</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 测试结果我写在注释里了，可以看到，bitset的存储单位是8个字节，而我的这台笔记本电脑正是64位机器字长的，测试环境是64位的Ubuntu 14.04版本操作系统。<br>&nbsp;&nbsp;&nbsp; 同样的，比特bitset也有它的不足之处，比如它不能再与普通整型数直接进行位运算，且它一经构造，不可以改变长度。至于时间效率，可以充分相信它不比普通整型的同类操作慢。</p>\n<h1 id=\"3-vector\"><a href=\"#3-vector\" class=\"headerlink\" title=\"3 vector&lt;bool&gt;\"></a>3 vector&lt;bool&gt;</h1><p>&nbsp;&nbsp;&nbsp; 当我第一次在手册中看见vector&lt;bool&gt;时我并没有留意，虽然也对bool型的vector容器为什么有一套独立的API感到了一丝困惑。后来在查找bitset相关资料时发现有人写了vector&lt;bool&gt;与bitset的比较文章，这才知道，vector&lt;bool&gt;是C++提供的bitset之外的另一种位层次数据结构微操方案，同等长度的两者的内存占用几乎一样。vector&lt;bool&gt;的具体用法读者依旧可以查看<a href=\"http://www.cplusplus.com/reference/vector/vector-bool/\">手册</a>，<del>是的我又偷懒了XDDD</del>。<br>&nbsp;&nbsp;&nbsp; 既然vector&lt;bool&gt;实现在vector库文件中，想必读者也能猜到它与bitset最大的不同，没错它是可变长的。相应的，作为牺牲，考虑数组与vector的区别，也不难猜到，vector&lt;bool&gt;比bitset慢。首先它的位操作也比bitset少得多，其次vector&lt;bool&gt;中的位不再能够用下标随机存取，而需要使用迭代器来访问。其实比起bitset的变长版本，我觉得说vector&lt;bool&gt;是bool型vector的空间优化版本更合适一些。</p>\n<p>&nbsp;&nbsp;&nbsp; 以上就完成了简单的位层面程序空间效率优化的相关概念引入，下面会继续跟进我的中国象棋的改进版本。</p>\n",
            "tags": [
                "C++",
                "位域",
                "bitset",
                "vector&lt;bool&gt;"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/11/15/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E4%BA%BA%E6%9C%BA%E5%8D%9A%E5%BC%88%E5%AE%9E%E7%8E%B0%E7%BB%83%E4%B9%A0/",
            "url": "https://blog.bipedalbit.net/2015/11/15/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E4%BA%BA%E6%9C%BA%E5%8D%9A%E5%BC%88%E5%AE%9E%E7%8E%B0%E7%BB%83%E4%B9%A0/",
            "title": "中国象棋人机博弈实现练习",
            "date_published": "2015-11-15T13:54:03.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 上一篇简略做了棋牌游戏人机博弈的概念铺垫，这一篇文就来贴一下我的初版实现。精力受限，没有像许多前辈那样把Maxmin系的搜索算法（Maxmin、AlphaBeta、Fail-Soft-AlphaBeta、Aspiration、PVS、MTD(f)）全部实现一遍。刚开始我甚至只打算实现一个MTD(f)的搜索核心，因为毕竟最晚出现的算法通常一定程度上是以往算法的集大成者。但是等把MTD(f)实现完，发现里面一层就是个AlphaBeta，于是AlphaBeta的搜索核心作为副产品也存在于实现成果中了。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 我并不打算在这里贴包括Qt5的GUI实现代码在内的所有大概3500行代码（当然其中至少700行可能是注释），主要讲解一下我的实现思路，偶尔贴一些关键代码。完整项目源码我在GitHub建了仓库，这篇文最后会贴地址，读者也可以自己去我Git找找看，毕竟我一共也没建过几个仓库。下面开始正题。</p>\n<h1 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h1><ul>\n<li>GUI：为了方便人工测试，灵活直观的展现测试结果<del>也方便随时嘚瑟</del>，中国象棋人机博弈程序的实现应该有GUI（图形用户界面）。</li>\n<li>通用部件：应该根据实际需要设计比较高效的、节省空间的、通用的局面表示部件与走法表示部件。</li>\n<li>走法生成器：为了给并行计算和分布式计算做准备，应该设计通用的走法生成器接口。至少实现一个可靠的串行计算的走法生成器。</li>\n<li>搜索核心：为了方便扩展与迭代开发，应该设计通用的搜索核心接口。若干不同版本的走法核心也应该被实现。</li>\n<li>局面评估核心：考虑到短期内难以获得经过结构化解析的对局数据或棋谱，只实现一个参数可在代码中调整的静态局面评估核心，通用局面评估核心接口不予实现，暂时搁置等待重构。</li>\n</ul>\n<h1 id=\"2-概要设计\"><a href=\"#2-概要设计\" class=\"headerlink\" title=\"2 概要设计\"></a>2 概要设计</h1><h2 id=\"2-1-GUI\"><a href=\"#2-1-GUI\" class=\"headerlink\" title=\"2.1 GUI\"></a>2.1 GUI</h2><p>&nbsp;&nbsp;&nbsp; 图形界面中棋盘、棋子的图形是必要组成部分。<br>&nbsp;&nbsp;&nbsp; 此外考虑到人机博弈回合间电脑变动棋子位置太突兀，玩家有时甚至难以察觉棋子位置的变化，应当添加当前选定棋子的标记（对电脑方的棋子来说则是上一步刚被操作过的棋子的标记）。<br>&nbsp;&nbsp;&nbsp; 应当可以选择玩家先手开局或后手开局。<br>&nbsp;&nbsp;&nbsp; 应当有开局按钮。<br>&nbsp;&nbsp;&nbsp; 最好也有悔棋或状态回退按钮。<br>&nbsp;&nbsp;&nbsp; 应当可以在每轮电脑回合前更改电脑使用的搜索核心种类。<br>&nbsp;&nbsp;&nbsp; 应当可以在每轮电脑回合前更改电脑搜索的深度（模拟对局回合数）。<br>&nbsp;&nbsp;&nbsp; 应该显示每轮电脑搜索中评估的局面数量和搜索用时，方便在测试时对算法效率和优化效果进行评估。</p>\n<h2 id=\"2-2-通用部件\"><a href=\"#2-2-通用部件\" class=\"headerlink\" title=\"2.2 通用部件\"></a>2.2 通用部件</h2><p>&nbsp;&nbsp;&nbsp; 最基本的通用部件应该是<em>棋盘位置的表示部件</em>，这个部件首先应当提供位置坐标的设置与查询方法。该部件还可能需要提供一些获取棋盘特定位置属性的方法，以辅助走法生成和局面评估。该部件的变量成员或容器应当进行适当的状态压缩以节省空间。<br>&nbsp;&nbsp;&nbsp; <em>走法表示部件</em>将提供特定走法的属性查询方法，如移动的棋子序号，走法中是否有棋子被吃，移动棋子的起点坐标和终点坐标。走法表示部件将使用棋盘位置表示部件做一些具体的实现。<br>&nbsp;&nbsp;&nbsp; 恰当的<em>局面状态表示部件</em>也是必要的。这个部件将直接为走法生成器和评估核心提供所有棋子的位置、状态查询方法，所有棋子相对位置的属性查询方法，以及所有棋盘特定位置的属性查询方法，棋子位置变更时的局面更新方法，棋子位置变更时的变更回退方法等。毫无疑问局面表示部件将使用棋盘位置表示部件和走法表示部件来实现所需的方法。</p>\n<h2 id=\"2-3-走法生成器\"><a href=\"#2-3-走法生成器\" class=\"headerlink\" title=\"2.3 走法生成器\"></a>2.3 走法生成器</h2><p>&nbsp;&nbsp;&nbsp; 不管计算形式是串行还是并行的，走法生成器应该按照中国象棋规则提供特定局面下合法的所有走法，并装载在一个走法容器中以备查询。合法的走法除需要符合基本的中国象棋行棋规则之外，还应该根据已走局面剔除循环走法。</p>\n<h2 id=\"2-4-搜索核心\"><a href=\"#2-4-搜索核心\" class=\"headerlink\" title=\"2.4 搜索核心\"></a>2.4 搜索核心</h2><p>&nbsp;&nbsp;&nbsp; 搜索核心应该作为游戏程序的主线索，调用走法生成器和局面评估核心对接下来的人机博弈状态做一系列的预演，然后给出相对最好的走法。搜索过程中还应该收集一些程序运行信息，比如评估结点数，搜索时间。搜索每一个新层次时势必要管理搜索树占用的内存空间，应该给出一个可行的空间管理方案。</p>\n<h2 id=\"2-5-局面评估核心\"><a href=\"#2-5-局面评估核心\" class=\"headerlink\" title=\"2.5 局面评估核心\"></a>2.5 局面评估核心</h2><p>&nbsp;&nbsp;&nbsp; 如前所述，暂且只要求实现一个基于少量中国象棋实际经验和主观猜测的评估函数。这个评估函数可能会需要一个类似于走法生成器但有所不同的“棋子影响力覆盖范围生成器”作为工具函数。</p>\n<h1 id=\"3-详细设计\"><a href=\"#3-详细设计\" class=\"headerlink\" title=\"3 详细设计\"></a>3 详细设计</h1><h2 id=\"3-1-GUI\"><a href=\"#3-1-GUI\" class=\"headerlink\" title=\"3.1 GUI\"></a>3.1 GUI</h2><p>&nbsp;&nbsp;&nbsp; Qt5设计GUI有多方便相信用过的读者都有体会，无非就是拖拖控件写写槽函数加点资源调调样式。<br>&nbsp;&nbsp;&nbsp; 本来我想在轮到电脑的回合时间显示一个正在加载时的常见gif图片，但发现这涉及到Qt5的并行计算方式。经过简单的尝试（利用QtConcurrent类）后发现无法在不同线程中顺畅管理相同的控件状态，这可能是资源同步互斥管理的问题（这里相信一些读者会联想到一个关于多线程的笑话：一个程序员遇到了一个问题，想通过多线程来解决它，现在他有两个问题了），于是干脆放弃显示图片的想法了，你将在我的Qt源码中发现我尝试的痕迹。<br>&nbsp;&nbsp;&nbsp; 另一点稍微值得一提的事是，我在准备好一切，要开始写点击棋子的槽函数的时候发现，QLabel控件居然没有Clicked默认事件，看来我是Web应用写多了有点惯性思维了。于是我只好自定义了一个ClickableLabel类，这个类是对QLabel类的封装，重载了基类QWidget的mouseReleaseEvent方法，在方法里发射了一个clicked消息。最后把所有需要点击互动的QLabel提升成了ClickableLabel，并添加了ClickableLabel的clicked消息的槽函数。<br>&nbsp;&nbsp;&nbsp; clickablelable.h：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> CLICKABLELABEL_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> CLICKABLELABEL_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QLabel&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QWidget&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QPoint&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClickableLabel</span> : <span class=\"hljs-keyword\">public</span> QLabel<br>&#123;<br>\tQ_OBJECT<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ClickableLabel</span><span class=\"hljs-params\">(QWidget* parent = <span class=\"hljs-number\">0</span>)</span></span>;<br>\t~<span class=\"hljs-built_in\">ClickableLabel</span>();<br>signals:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clicked</span><span class=\"hljs-params\">(ClickableLabel* clickableLabel)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clicked</span><span class=\"hljs-params\">(QPoint pos, ClickableLabel* clickableLabel)</span></span>;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mouseReleaseEvent</span><span class=\"hljs-params\">(QMouseEvent *event)</span></span>;<br>&#125;;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">// CLICKABLELABEL_H</span></span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; clickablelable.cpp：</p>\n<pre><code class=\"hljs\">#include &quot;clickablelabel.h&quot;\n#include &quot;QMouseEvent&quot;\n\nClickableLabel::ClickableLabel(QWidget* parent)\n\t: QLabel(parent)\n&#123;\n&#125;\n\nClickableLabel::~ClickableLabel()\n&#123;\n&#125;\n\nvoid ClickableLabel::mouseReleaseEvent(QMouseEvent* event)\n&#123;\n\temit clicked(this);\n\temit clicked(event-&gt;pos(), this);\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 还挺简单的，不是吗？</p>\n<h2 id=\"3-2-通用部件\"><a href=\"#3-2-通用部件\" class=\"headerlink\" title=\"3.2 通用部件\"></a>3.2 通用部件</h2><h3 id=\"3-2-1-棋盘位置表示部件\"><a href=\"#3-2-1-棋盘位置表示部件\" class=\"headerlink\" title=\"3.2.1 棋盘位置表示部件\"></a>3.2.1 棋盘位置表示部件</h3><p>&nbsp;&nbsp;&nbsp; 我为棋盘位置表示部件实现了一个Position类，只有一个unsigned char型成员变量，８位，一个字节，高四位表示纵坐标即行序号，第四位表示横坐标即列序号，全１有两个方面的含义：对特定棋子来书，当前位置坐标全１表示该棋子已经被吃；对棋盘上特定位置来说，全１表示棋盘上这个位置没有棋子。<br>&nbsp;&nbsp;&nbsp; 因为这个类中的横纵坐标是状态压缩的，需要分别提供横纵坐标的提取／解析方法x()、y()，还有棋子死活／有无的判定及设置方法dead()、kill()。具体实现都是些简单的位运算，比如取第四位用按位与，取高四位用位移。比较局面状态难免要做一系列的棋盘位置比较，所以还实现了“&#x3D;&#x3D;”和“!&#x3D;”符号。<br>&nbsp;&nbsp;&nbsp; 后面在搜索核心的实现有时候会用到置换表，生成hash key需要获取底层的坐标存储数据，所以这个类还有个突兀的友元声明。</p>\n<h3 id=\"3-2-2-走法表示部件\"><a href=\"#3-2-2-走法表示部件\" class=\"headerlink\" title=\"3.2.2 走法表示部件\"></a>3.2.2 走法表示部件</h3><p>&nbsp;&nbsp;&nbsp; 走法表示使用四个成员变量：移动的棋子序号、被吃的棋子序号、原棋盘位置、新棋盘位置，全部使用unsigned char型变量，共４个字节。实现这个类时我偷了个懒，干脆把成员变量访问限定符都定为public了，于是除了空构造函数和一个初始化所有成员变量的重载，只写了一个比较符号“&#x3D;&#x3D;”。没什么特别的。</p>\n<h3 id=\"3-2-3-局面状态表示部件\"><a href=\"#3-2-3-局面状态表示部件\" class=\"headerlink\" title=\"3.2.3 局面状态表示部件\"></a>3.2.3 局面状态表示部件</h3><p>&nbsp;&nbsp;&nbsp; 这个部件还比较有意思。实际上，写游戏初版时，因为走法生成器，搜索核心或评估核心内部实现过程不顺心，曾经一度重构通用部件，其中也伴随着通用部件新需求的不断提出。作为直接向三大模块提供服务的部件，局面状态表示部件的修改最为频繁。<br>&nbsp;&nbsp;&nbsp; 资料提出的中国象棋棋盘状态存储模型有：</p>\n<ul>\n<li>用32颗棋子的棋盘分布（32*10*9个比特）来保存局面状态；</li>\n<li>用14种棋子的棋盘分布（14*10*9个比特）来保存局面状态；</li>\n<li>用10*9个棋盘位置上32颗棋子的互斥存在标识（10*9*5个比特）来保存局面状态；</li>\n<li>用10*9个棋盘位置上14种棋子的互斥存在标识（10*9*4个比特）来保存局面状态；</li>\n<li>用32颗棋子的坐标值（32*8个比特）来保存局面状态。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 可以看出，上述模型占用空间的大小依次递减。如果比较占用空间大小，第五种模型显然最优。但是实现走法生成器和评估核心时，需要对棋子相对位置上的棋子有无、棋子归属进行大量查询。如果每次针对特定棋盘位置的棋子查询都通过遍历32颗棋子来完成，何况每颗棋子都需要对若干个相对位置做棋子查询，尤其是車、炮这种自由度很大的棋子，恐怕随着搜索树的展开，将累计很大的时间开销。<br>&nbsp;&nbsp;&nbsp; 那么如果换用第四种模型呢？特定棋子相对位置的状态可以直接查询到了，同类查询的时间开销降到了第五种模型的1&#x2F;32。那么如果选用第四种模型，除了稍多一些的空间开销，有没有做出别的牺牲呢？当我们想要查询特定棋子的坐标，不再能够直接查到了，我们需要遍历整个棋盘来寻找一颗棋子，还需要标记这颗棋子是否同类棋子（同归属方、同兵种）中我们需要的那一颗。同类查询的时间开销变成了原来的90倍以上。这并不是一个典型的、合算的空间换时间型优化。<br>&nbsp;&nbsp;&nbsp; 我们重新思考一下局面表示部件在搜索过程中的实际使用情况，不难发现，如果把当前局面作为一个引用参数引入搜索核心类，那么整个搜索过程中，不论采用怎样的局面表示模型，不论对当前局面状态做了多少次更新和回退，空间开销的差别其实微乎其微。真正对空间开销起明显作用的是走法表示部件的数据结构。想到这里不禁觉得一阵无力感袭来，局面状态表示部件的状态压缩是不太有意义的。<br>&nbsp;&nbsp;&nbsp; 那么我们现在可以专注于提高局面状态表示部件中各种方法的时间效率而无视空间开销了。于是我用了一个双向索引，即同时在部件中使用第一种模型和第五种模型。这样不管按棋子序号查询坐标还是按特定坐标查询棋盘位置状态，都可以以常数级的时间开销完成查询过程。当然还实现了许多为三大模块提供服务的方法，还需要记录局面评分和主动权归属。<br>&nbsp;&nbsp;&nbsp; State.h：</p>\n<pre><code class=\"hljs\">#ifndef _STATE_H_\n#define _STATE_H_\n\n#include &quot;Position.h&quot;\n#include &quot;Move.h&quot;\n\n/* 棋子序号 */\n/* 红帅 */\n#define R_KING 0\n/* 红仕序号起点（序号个数2） */\n#define R_MANDARIN 1\n/* 红相序号起点（序号个数2） */\n#define R_ELEPHANT 3\n/* 红马序号起点（序号个数2） */\n#define R_KNIGHT 5\n/* 红車序号起点（序号个数2） */\n#define R_ROOK 7\n/* 红炮序号起点（序号个数2） */\n#define R_CANNON 9\n/* 红兵序号起点（序号个数5） */\n#define R_PAWN 11\n/* 红子序号起点 */\n#define R_BEGIN R_KING\n/* 红子序号终点 */\n#define R_END R_PAWN+4\n/* 黑将 */\n#define B_KING 16\n/* 黑士序号起点（序号个数2） */\n#define B_MANDARIN 17\n/* 黑象序号起点（序号个数2） */\n#define B_ELEPHANT 19\n/* 黑马序号起点（序号个数2） */\n#define B_KNIGHT 21\n/* 黑車序号起点（序号个数2） */\n#define B_ROOK 23\n/* 黑炮序号起点（序号个数2） */\n#define B_CANNON 25\n/* 黑卒序号起点（序号个数5） */\n#define B_PAWN 27\n/* 黑子序号起点 */\n#define B_BEGIN B_KING\n/* 黑子序号终点 */\n#define B_END B_PAWN+4\n/* 坐标数组中表示棋子已被吃 */\n#define DEAD 0xff\n/* 棋子数组中表示坐标无棋子占用 */\n#define NONE DEAD\n\n/* 局面状态类：32+90=122字节 */\n/* 这个类负责记录局面状态，包括局面的棋子索引的状态和坐标索引的状态。 */\n/* 坐标索引的状态提供坐标优先的快速状态查询； */\n/* 棋子索引的状态提供棋子优先的快速状态查询。 */\nclass State\n&#123;\npublic:\n\t/* 当前局面下红方是否持有行动权 */\n\tbool RTurn;\n\t/* 根据中国象棋规则初始化局面状态 */\n\tState();\n\t/* 根据走法更新棋盘状态 */\n\tvoid move(const Move &amp;m);\n\t/* 还原按走法还原更新前的棋盘状态 */\n\tvoid undo(const Move &amp;m);\n\t/* 获取特定棋子行号，即棋子y坐标 */\n\tunsigned char y(unsigned char chessNo) const;\n\t/* 获取特定棋子列号，即棋子x坐标 */\n\tunsigned char x(unsigned char chessNo) const;\n\t/* 获取特定坐标上的棋子序号或空序号 */\n\tunsigned char getNo(unsigned char x, unsigned char y) const;\n\t/* 存活判定 */\n\tbool isAlive(unsigned char chessNo) const;\n\t/* 红子判定 */\n\tbool isRed(unsigned char chessNo) const;\n\t/* 黑子判定 */\n\tbool isBlack(unsigned char chessNo) const;\n\t/* 友方判定 */\n\tbool isFriend(unsigned char chessNo1, unsigned char chessNo2) const;\n\t/* 特定棋子相对位置处是否有子 */\n\tbool relExist(unsigned char chessNo, char x, char y) const;\n\t/* 特定棋子相对位置处是否有红子 */\n\tbool relRedExist(unsigned char chessNo, char x, char y) const;\n\t/* 特定棋子相对位置处是否有黑子 */\n\tbool relBlackExist(unsigned char chessNo, char x, char y) const;\n\t/* 判断当前棋局是否已经结束，即一方的将/帅已经被吃 */\n\tbool isDone() const;\n\t/* 定义一个相等运算符，unordered_map要用 */\n\tbool operator == (const State state) const;\n\t/* 允许KeyHash类访问私有成员 */\n\tfriend class KeyHash;\nprivate:\n\t/* 使用双向索引，加快两个方向的查询速度 */\n\t/* 棋子序号索引的坐标数组：32字节 */\n\tPosition posList[32];\n\t/* 棋盘坐标索引的棋子数组：90字节 */\n\t/* 二维数组的每个单元为一个8位整型数，用来表示坐标占用情况 */\n\t/* 即与坐标数组通用的棋子序号和一个额外的表示空的序号0xff */\n\tunsigned char board[10][9];\n&#125;;\n\n#endif\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 具体方法实现都很简单，就不在这贴代码了。</p>\n<h2 id=\"3-3-走法生成器\"><a href=\"#3-3-走法生成器\" class=\"headerlink\" title=\"3.3 走法生成器\"></a>3.3 走法生成器</h2><p>&nbsp;&nbsp;&nbsp; 这是我认为中国象棋游戏中实现起来最繁琐的一个模块了，这里无法回避中国象棋零散的行棋规则。<br>&nbsp;&nbsp;&nbsp; 将／帅除了直面对方将／帅时可以飞过去吃掉对方，平时只能在己方的“帅府”九宫格中向没有己方棋子且不超出棋盘的位置做下列４种移动：</p>\n<ul>\n<li><code>(x, y) -&gt; (x-1, y)</code></li>\n<li><code>(x, y) -&gt; (x+1, y)</code></li>\n<li><code>(x, y) -&gt; (x, y-1)</code></li>\n<li><code>(x, y) -&gt; (x, y+1)</code></li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 士／仕只能在己方“帅府”九宫格中向没有己方棋子且不超出棋盘的位置做下列４种移动：</p>\n<ul>\n<li><code>(x, y) -&gt; (x-1, y-1)</code></li>\n<li><code>(x, y) -&gt; (x+1, y-1)</code></li>\n<li><code>(x, y) -&gt; (x-1, y+1)</code></li>\n<li><code>(x, y) -&gt; (x+1, y+1)</code></li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 象／相只能在己方阵地的五行内，在不被“遮象眼”的情况下“走田字”，即向没有己方棋子且不超出棋盘的位置做下列４种尝试：</p>\n<ul>\n<li>(x-1, y-1)处无子则<code>(x, y) -&gt; (x-2, y-2)</code></li>\n<li>(x+1, y-1)处无子则<code>(x, y) -&gt; (x+2, y-2)</code></li>\n<li>(x-1, y+1)处无子则<code>(x, y) -&gt; (x-2, y+2)</code></li>\n<li>(x+1, y+1)处无子则<code>(x, y) -&gt; (x+2, y+2)</code></li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 马只能在不被“別马腿”的情况下“走日字”，即向没有己方棋子且不超出棋盘的位置做下列８种尝试：</p>\n<ul>\n<li>(x-1, y)处无子则<code>(x, y) -&gt; (x-2, y-1), (x, y) -&gt; (x-2, y+1)</code></li>\n<li>(x+1, y)处无子则<code>(x, y) -&gt; (x+2, y-1), (x, y) -&gt; (x+2, y+1)</code></li>\n<li>(x, y-1)处无子则<code>(x, y) -&gt; (x-1, y-2), (x, y) -&gt; (x+1, y-2)</code></li>\n<li>(x, y+1)处无子则<code>(x, y) -&gt; (x-1, y+2), (x, y) -&gt; (x+1, y+2)</code></li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 車可以在上、下、左、右四个方向上在不超出棋盘又无棋子阻挡“视线”的前提下尝试移动任意距离，当遇到第一颗阻挡“视线”的棋子，如果棋子归属方不同，还可以吃子，取代那颗棋子的位置。<br>&nbsp;&nbsp;&nbsp; 炮有两种移动模式，即非吃子或吃子。非吃子模式下，炮可以在上、下、左、右四个方向上在不超出棋盘又无棋子阻挡“视线”的前提下尝试移动任意距离；吃子模式下，炮首先要在上、下、左、右四个方向上找到一颗阻挡“视线”的棋子，然后跳过这颗棋子，继续向前寻找阻挡“视线”的第二颗棋子，如果找到阻挡视线的第一颗和第二颗棋子，且第二颗棋子归属方不同，可以吃掉第二颗棋子，取代它的位置。<br>&nbsp;&nbsp;&nbsp; 兵／卒有两种行棋情况，在离开己方阵地的五行之前，只能在前方没有己方棋子的情况下向对方阵地移动一格；在离开己方阵地即进入敌方阵地后，向没有己方棋子且不超出棋盘的位置向前一格、向左一格或向右一格移动。<br>&nbsp;&nbsp;&nbsp; 此外，还要引入局面记录参数，剔除造成重复局面的走法。<br>&nbsp;&nbsp;&nbsp; 文字描述都这么麻烦，程序就更麻烦了，串行的走法生成器我写了700+行，虽然我的缩进比较“宽松”，注释比较多，还是很长了。并行版本如果用多线程还得管理线程队列、线程池，创建线程、监视线程、管理共享资源、做同步互斥什么的，恐怕会更长。多进程也一样。</p>\n<h2 id=\"3-4-搜索核心\"><a href=\"#3-4-搜索核心\" class=\"headerlink\" title=\"3.4 搜索核心\"></a>3.4 搜索核心</h2><h3 id=\"3-4-1-搜索核心通用接口\"><a href=\"#3-4-1-搜索核心通用接口\" class=\"headerlink\" title=\"3.4.1 搜索核心通用接口\"></a>3.4.1 搜索核心通用接口</h3><p>&nbsp;&nbsp;&nbsp; 本着引入复杂类型变量时能用引用或指针就不复制变量的原则，搜索核心通用接口定义了许多成员变量。一个局面状态表示部件currentState用来复制当前状态，我复制了整个部件而非引入一个引用，是因为如果使用引用，构造类的时候不太方便，同样要增加开销。我想过使用指针，但是发现遍历State类成员时会一直报错，没能调顺，只得放弃。同样的理由，局面记录也进行了复制，但是我发现只进行浅复制就不会报错，也就没有深究。估值核心我使用了指针，因为估值核心的实例化发生在搜索核心的构造函数中。此外还有当前搜索深度变量、最大搜索深度变量、最佳走法、评估结点数即搜索树的叶结点树和搜索时间。<br>&nbsp;&nbsp;&nbsp; 搜索核心通用接口定义的方法不多，构造函数中只实例化了评估核心，析构函数负责销毁评估核心，此外只有一个搜索函数和一个获得最佳走法的只读方法。</p>\n<h3 id=\"3-4-2-MTD-f\"><a href=\"#3-4-2-MTD-f\" class=\"headerlink\" title=\"3.4.2 MTD(f)\"></a>3.4.2 MTD(f)</h3><p>&nbsp;&nbsp;&nbsp; 搜索核心的一个实现是MTD(f)算法。MTD(f)的最外层是一个迭代深化的过程，具体说就是由浅到深的尝试搜索同时计时，一旦超过设定的搜索时间阈值就停止搜索。当搜索过程复杂（搜索树剪枝少）实际搜索深度可能无法很深，当搜索过程简单，实际搜索深度则只受玩家设定的最大搜索深度的影响。<br>&nbsp;&nbsp;&nbsp; 迭代深化的下一层是MTD(f)的思想核心，在一个无限大的窗口中，在一个有依据的猜测值附近反复进行类似PVS的空窗探测，并不断向真实的最大局面评估值调整猜测值和窗口，直到窗口上下限闭合。</p>\n<pre><code class=\"hljs\">int MTD_f::mtdf(int firstGuess)\n&#123;\n\t/* MTD(f)窗口上下限 */\n\tint windowTop = WIN;\n\tint windowDown = -WIN;\n\t/* 空窗探测评估值，调整MTD(f)窗口的依据 */\n\tint g = firstGuess;\n\t/* alphaBeta算法的窗口上限 */\n\tint beta;\n\t/* 不断执行空窗探测直到窗口闭合，有hash置换表不怕重复搜索 */\n\twhile(windowDown &lt; windowTop)\n\t&#123;\n\t\t/* 刚调整过窗口下限，更需要通过向上偏移的空窗探测调整窗口上限 */\n\t\tif (g == windowDown)\n\t\t&#123;\n\t\t\t/* 在[g, g+1]区间上进行空窗探测 */\n\t\t\t/* alpha = g */\n\t\t\tbeta = g + 1;\n\t\t&#125;\n\t\t/* 刚调整过窗口上限，更需要通过向下偏移的空窗探测调整窗口下限 */\n\t\telse\n\t\t&#123;\n\t\t\t/* 在[g-1, g]区间上进行空窗探测 */\n\t\t\t/* alpha = g - 1 */\n\t\t\tbeta = g;\n\t\t&#125;\n\t\t/* 利用Fail-Soft AlphaBeta算法做空窗探测 */\n\t\t/* alpha = beta - 1 */\n\t\tg = TTFAlphaBeta(beta - 1, beta, 0);\n\t\t/* 根据新评估值做窗口调整 */\n\t\t/* 新评估值小于空窗口，可以认为猜高了，实际评估值应该更低 */\n\t\tif (g &lt; beta)\n\t\t&#123;\n\t\t\t/* 根据新评估值下调MTD(f)窗口上限 */\n\t\t\twindowTop = g;\n\t\t&#125;\n\t\t/* 新评估值不小于空窗口，可以认为猜低了，实际评估值应该更高 */\n\t\telse\n\t\t&#123;\n\t\t\t/* 根据新评估值上调MTD(f)窗口下限 */\n\t\t\twindowDown = g;\n\t\t&#125;\n\t&#125;\n\treturn g;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 再下一层是一个hash置换表优化的Fail-Soft-AlphaBeta算法，事实上，这个AlphaBeta的窗口大小是０，所以在我看来，MTD(f)的最下层更像一个PVS。</p>\n<h3 id=\"3-4-3-AlphaBeta\"><a href=\"#3-4-3-AlphaBeta\" class=\"headerlink\" title=\"3.4.3 AlphaBeta\"></a>3.4.3 AlphaBeta</h3><p>&nbsp;&nbsp;&nbsp; 搜索核心的另一个实现是AlphaBeta算法，实际上我只是把MTD(f)最下层的PVS拿出来，去掉置换表，把初始窗口定为无限大而已。这从算法实现方式的侧面印证了Maxmin系算法师出同门的事实。</p>\n<h2 id=\"3-5-局面评估核心\"><a href=\"#3-5-局面评估核心\" class=\"headerlink\" title=\"3.5 局面评估核心\"></a>3.5 局面评估核心</h2><p>&nbsp;&nbsp;&nbsp; 现在使用的评估方法是统计局面上棋子的自由度、受威胁程度、棋子基本价值、棋盘位置加成、棋子受保护加成，并进行简单累加。使用了很多常数作为评估依据：</p>\n<pre><code class=\"hljs\">#ifndef _EVALUATOR_H_\n#define _EVALUATOR_H_\n\n#include &quot;State.h&quot;\n#include &quot;Move.h&quot;\n#include &lt;vector&gt;\n\n/* 估值器，提供对每一个局面状态的下特定走法的评分 */\n/* 使用先验知识和一些局面评估因素为局面估值 */\nclass Evaluator\n&#123;\npublic:\n\t/* 评估结点计数 */\n\tunsigned cnt;\n\t/* 估值器构造函数，初始化估值器 */\n\tEvaluator();\n\t/* 估值函数，对给定的局面状态评分 */\n\tint evaluate(State &amp;state);\nprivate:\n\t/* 炮的一些重要坐标的加成 */\n\tconst int ADD_R_CANNON[10][9] =\n\t&#123;\n\t\t&#123;50,\t50,\t0,\t0,\t0,\t0,\t0,\t50,\t50&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t10,\t0,\t10,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t10,\t0,\t0,\t0,\t0,\t0,\t10,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;10,\t0,\t0,\t10,\t50,\t10,\t0,\t0,\t10&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;\n\t&#125;;\n\tconst int ADD_B_CANNON[10][9] =\n\t&#123;\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;10,\t0,\t0,\t10,\t50,\t10,\t0,\t0,\t10&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t10,\t0,\t0,\t0,\t0,\t0,\t10,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t10,\t0,\t10,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;50,\t50,\t0,\t0,\t0,\t0,\t0,\t50,\t50&#125;\n\t&#125;;\n\t/* 马的一些重要坐标的加成 */\n\tconst int ADD_R_KNIGHT[10][9] =\n\t&#123;\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t100,\t0,\t0,\t0,\t100,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t100,\t0,\t100,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t10,\t0,\t0,\t0,\t10,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t10,\t0,\t0,\t0,\t10,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t-100,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;\n\t&#125;;\n\tconst int ADD_B_KNIGHT[10][9] =\n\t&#123;\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t-100,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t10,\t0,\t0,\t0,\t10,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t10,\t0,\t0,\t0,\t10,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t100,\t0,\t100,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t100,\t0,\t0,\t0,\t100,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;\n\t&#125;;\n\t/* 兵的一些重要坐标的加成 */\n\tconst int ADD_R_PAWN[10][9] =\n\t&#123;\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;90,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t90&#125;,\n\t\t&#123;90,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t90&#125;,\n\t\t&#123;70,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t70&#125;,\n\t\t&#123;70,\t70,\t70,\t70,\t70,\t70,\t70,\t70,\t70&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;\n\t&#125;;\n\tconst int ADD_B_PAWN[10][9] =\n\t&#123;\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;,\n\t\t&#123;70,\t70,\t70,\t70,\t70,\t70,\t70,\t70,\t70&#125;,\n\t\t&#123;70,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t70&#125;,\n\t\t&#123;90,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t90&#125;,\n\t\t&#123;90,\t90,\t110,\t120,\t120,\t120,\t110,\t90,\t90&#125;,\n\t\t&#123;0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0&#125;\n\t&#125;;\n\t/* 先验的定义每种棋子的基本价值 */\n\tconst int BASE_VAL[32] =\n\t&#123;\n\t\t10000, 250, 250, 250, 250, 350, 350, 500, 500, 350, 350, 100, 100, 100, 100, 100,\n\t\t10000, 250, 250, 250, 250, 350, 350, 500, 500, 350, 350, 100, 100, 100, 100, 100\n\t&#125;;\n\t/* 棋子灵活度单位价值，即每个可走位置对总自由度的贡献 */\n\tconst int FREE_UNIT[32] =\n\t&#123;\n\t\t0, 1, 1, 1, 1, 12, 12, 6, 6, 6, 6, 15, 15, 15, 15, 15,\n\t\t0, 1, 1, 1, 1, 12, 12, 6, 6, 6, 6, 15, 15, 15, 15, 15\n\t&#125;;\n\t/* 棋子被威胁造成的负分 */\n\tbool threatenScore[32];\n\t/* 棋子被保护造成的加分 */\n\tbool protectScore[32];\n\t/* 棋子评分 */\n\tint chessScore[32];\n\t/* 根据特定的局面状态和当前行动权归属生成所有可能的势力覆盖方式并填充走法容器 */\n\tvoid generate(const State &amp;state);\n\t/* 棋子势力覆盖方式容器 */\n\tstd::vector&lt;Move&gt; coverList;\n&#125;;\n\n#endif\n</code></pre>\n<h1 id=\"4-手工测试\"><a href=\"#4-手工测试\" class=\"headerlink\" title=\"4 手工测试\"></a>4 手工测试</h1><p>&nbsp;&nbsp;&nbsp; 搜索深度为１时，分别使用AlphaBeta算法和MTD(f)算法作为搜索核心，评估结点数和搜索时间并没有明显的不同。两种算法下电脑的走法都很蠢。<br>&nbsp;&nbsp;&nbsp; 搜索深度为２时，使用AlphaBeta算法，绝大多数情况下评估结点数稳定在400<del>700区间内，搜索时间最多达到10^-2秒数量级；使用MTD(f)算法，绝大多数情况下评估结点数稳定在600</del>1000区间内，搜索时间稳定在0.03秒左右。<br>&nbsp;&nbsp;&nbsp; 搜索深度为３时，使用AlphaBeta算法，绝大多数情况下评估结点数稳定在10000附近，搜索时间平均在10^-2秒数量级；使用MTD(f)算法，评估结点数平均在10^3数量级上,偶尔上万，搜索时间平均在10^-2秒数量级，偶尔还会非常小。<br>&nbsp;&nbsp;&nbsp; 搜索深度为４时，使用AlphaBeta算法，评估结点数在10^5数量级上，搜索时间平均在1秒数量级，电脑的走法看起似乎比搜索３层要蠢；使用MTD(f)算法，评估结点数很少再达到10^4数量级以上，搜索时间稳定在1秒数量级，走法也有点蠢。<br>&nbsp;&nbsp;&nbsp; 搜索深度为５时，使用AlphaBeta算法，评估结点数在10^6数量级上，搜索时间平均在８秒，电脑表现比较出色，开始出现游戏崩溃的现象；使用MTD(f)算法，可能是受迭代深化的限制作用影响，评估结点数和搜索时间与搜索深度为４时很接近，但是电脑的走法比４层时更出色，会出现游戏崩溃的现象。<br>&nbsp;&nbsp;&nbsp; 搜索深度为６时，使用AlphaBeta算法，评估结点数达到了10^7数量级，搜索时间也增加到10^2秒数量级，电脑走法却不如５层时优秀，有游戏崩溃现象；使用MTD(f)算法，可能是受迭代深化的限制作用影响，评估结点数和搜索时间与搜索深度为４时很接近，电脑的走法没有比５层明显更优秀，有游戏崩溃的现象。<br>&nbsp;&nbsp;&nbsp; 更深层的搜索时AlphaBeta算法的搜索时间将长到无法忍受，游戏崩溃的现象也将更早出现。<br>&nbsp;&nbsp;&nbsp; 观察表明，使用偶数作为搜索深度时，电脑的走法性能会相对浅一层的奇数层搜索结果有一定的衰减，迭代深化时的层数步进也许设置为２更好。</p>\n<h1 id=\"5-结论与收获\"><a href=\"#5-结论与收获\" class=\"headerlink\" title=\"5 结论与收获\"></a>5 结论与收获</h1><p>&nbsp;&nbsp;&nbsp; 过去谈及棋牌游戏的人机博弈我都只能表示佩服，满怀憧憬的感叹一下，表示做起来可能很麻烦。真的动手做过一个粗糙的练习之后才发现，用的无非还是那些简单算法的扩展或变种，简单说起来也不过是有限搜索树而已。不过种种精细的剪枝与优化还是很磨练人的心性的，当然我还没磨练到位，毕竟初版的优化我都没做彻底就来写博文了。</p>\n<h1 id=\"6-不足与展望\"><a href=\"#6-不足与展望\" class=\"headerlink\" title=\"6 不足与展望\"></a>6 不足与展望</h1><p>&nbsp;&nbsp;&nbsp; 不足：</p>\n<ul>\n<li>当前版本的两个搜索核心都是盲目搜索，即搜索中容易导致剪枝或棋局结束的结点没有优先搜索。</li>\n<li>局面评估核心应该重构，提供一个通用接口，为神经网络优化或其他技术优化的评估核心做准备。</li>\n<li>搜索树的展开过程中仍然存在动态申请内存空间的动作，当搜索深度到达４，偶尔会出现内存申请失败，游戏崩溃的情况，可以尽量静态的一次性的申请内存。</li>\n<li>没有足够优秀的查表优化。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 展望：</p>\n<ul>\n<li>通用部件的数据结构还可以进一步细化优化。</li>\n<li>走法生成器和评估核心的工具函数——棋子影响力覆盖范围生成器都有并行化的优化空间。</li>\n<li>局面评估核心还可以有更优秀的，基于机器学习的优化。</li>\n<li>还可以建立适当规模的开局库、残局库。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 最后，挂<a href=\"https://github.com/bipedalBit/BipedalBit-Chinese-Chess\">Git项目地址</a>。<br>&nbsp;&nbsp;&nbsp; 因为偶尔偷懒，项目代码规范化有些参差不齐，有好的建议欢迎讨论。</p>\n",
            "tags": [
                "Qt",
                "C++",
                "人机博弈",
                "AlphaBeta",
                "MTD(f)"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/10/17/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94c-11%E7%AF%87/",
            "url": "https://blog.bipedalbit.net/2015/10/17/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94c-11%E7%AF%87/",
            "title": "C++多线程初探——c++11篇",
            "date_published": "2015-10-17T06:58:22.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 今天被说C++出身的猿不会多线程跟不会C++有什么分别，于是放下刚到手的Go和R的书，痛定思痛准备来给自己补补课。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; C++新标准c++11出现之前（虽然“新”标准已经发布好几年了），大家用C++写多线程通常有两种方式：Unix&#x2F;Linux下通常使用POSIX标准的pthread.h库，pthread并不是语言本身提供的内置库，gcc编译带pthread的程序时需要加上<code>-lpthread</code>标识参数；Windows下，win系列系统提供了一些线程API，但是由于gcc&#x2F;g++等编译器的跨平台性，其实也可以在win下使用pthread。<br>&nbsp;&nbsp;&nbsp; 然而2011年夏天，c++11标准发布了，新C++有了许多方便的新特性，其中就包括内置的，对多线程的支持。gcc 4.6及以前的版本编译c++11标准的多线程程序时还要加<code>-pthread</code>标识参数（注意与pthread库的<code>-lpthread</code>参数的区别）。后来也默认的支持新C++的内置多线程了，实测gcc 4.8.4除了<code>-std=c++11</code>不加别的参数，能够顺利编译运行c++11的多线程程序。<br>&nbsp;&nbsp;&nbsp; 铺垫了这么多，下面就先来试试c++11的多线程吧。<br>&nbsp;&nbsp;&nbsp; helloWorld.cpp：</p>\n<pre><code class=\"hljs\">/* c++11线程类的所在，下面的std::thread和std::this_thread都在其中 */\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid thread_task()\n&#123;\n\tcout &lt;&lt; &quot;Hello world! My thread ID is &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;\n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n\t// 主线程测试\n\t/* get_id函数是thread类和this_thread类的成员，获取线程ID */\n\tcout &lt;&lt; &quot;I&#39;m the main thread. My thread ID is &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;\n\t// 子线程测试\n\t/* 构造子线程时指派线程任务函数指针 */\n\tthread t1(thread_task);\n\tthread t2(thread_task);\n\tthread t3(thread_task);\n\t/* 主线程创建子线程 */\n\tt1.join();\n\tt2.join();\n\tt3.join();\n\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 最简单的多线程测试看起来运行的很顺利。下面我们稍微详细一点研究下std::thread的<a href=\"http://www.cplusplus.com/reference/thread/thread/\">官方文档</a>。</p>\n<ul>\n<li>thread::id：thread下面有个子类型thread::id，表示线程ID。是thread::get_id和this_thread::get_id的返回值。thread::id的构造函数返回一个non-joinable（不代表任何一个线程，即不与任何一个未终止的线程对应的ID相等）的线程ID。一个活跃的线程的ID会在线程终止后变成non-joinable线程ID。</li>\n<li>thread类的构造有4种形式：</li>\n</ul>\n<ul>\n<li>thread::thread()：默认构造函数，即不带参数的构造函数。构造一个非活跃（不可执行）的线程对象。</li>\n<li>thread::thread (Fn&amp;&amp; fn, Args&amp;&amp;… args)：初始化构造函数，即带足够多参数，足以初始化一个线程的构造函数。初始化构造函数的参数列表包括一个函数指针和这个函数的参数列表。利用迟邦定技术，构造过程与对函数副本的请求同步完成。</li>\n<li>复制构造函数，即从一个线程对象复制而得到一个新的线程对象。实际上，线程对象不允许被复制。</li>\n<li>thread::thread (thread&amp;&amp; x)：移动构造函数，即重新给指定线程分配一个对象（句柄），并释放原来的线程对象（句柄）。注意这并不影响原线程的执行，因为只是释放了对象（句柄），而没有分离原进程、释放资源。参数只有原线程对象。</li>\n</ul>\n<ul>\n<li>thread::~thread()：如果一个活跃线程被释放，首先会调用terminal()方法停止线程的执行。</li>\n<li>thread::operator&#x3D;(thread&amp;&amp; rhs)：作用相当于移动构造函数，原线程句柄被释放，返回一个更换句柄的线程对象。</li>\n<li>thread::get_id()：如果方法的目标线程对象是活跃的，生成一个唯一的ID并返回；如果调用方法的线程对象非活跃，先调用线程的默认构造函数生成一个non-joinable线程对象，然后生成一个唯一的ID并返回。</li>\n<li>thread::joinable()：joinable方法的唯一参数为一个线程ID，它的bool型返回值代表这个线程ID是否对应一个活跃的线程。this_thread下并没有这个方法，因为当前线程如果不为活跃线程，它将不能完成任何线程任务，即不能调用任何方法。</li>\n<li>thread::join()：这个方法将阻塞调用方法的线程（主线程），直到目标线程中的操作全部完成。这个方法返回之后，目标线程对象的状态就变为非活跃并可以被安全的释放了。换句话说，这个方法定义了一组线程同步关系。</li>\n<li>thread::detach()：应该有读者注意到了，detach是join的反义词，该方法的作用是从调用线程（主线程）中分离目标线程，让目标线程可以独立并行执行。调用detach方法后两个线程（调用线程和目标线程）都不会被阻塞或者被同步，而是会并行执行直到各自完成所有操作，谁完成执行谁就释放自己的资源，互不影响。（不是我啰嗦，文档原文就是这么说的）这个方法返回之后，目标线程对象的状态就变为非活跃并可以被安全的释放了。换句话说，这个方法定义了一组线程异步关系。</li>\n<li>thread::swap(thread&amp; x)：文档原文说是交换两个线程对象的<strong>状态</strong>，我表示不明白状态是指什么。实验表明应该是交换了线程与对象（句柄）的映射关系。thread类还重载了一个面向过程风格的swap方法版本：<code>void swap (thread&amp; x, thread&amp; y)</code>。</li>\n<li>thread::hardware_concurrency()：这是个静态成员函数，返回一个无符号整型，返回一个大概的（不一定准确，因为系统可以支持或限制每个进程创建的线程数）基于硬件的最大并行线程数。如果这个试图返回的值没有被系统很好的定义，返回0。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; thread头文件中还有一个与thread并列的<a href=\"http://www.cplusplus.com/reference/thread/this_thread/\">this_thread类</a>，this_thread类非常简单，除了get_id方法只有另外三个方法：</p>\n<ul>\n<li>this_thread::yield()：顾名思义，使当前线程退让，从执行状态变为就绪状态，使同优先级的线程有机会被重新调度进入执行状态。如果当前进程没什么毛病那么使它退让并没有太大意义，甚至可能不会造成事实上的线程执行顺序变化。yield方法应该在当前线程忙等别的线程而又没有被阻塞时执行。</li>\n<li>this_thread::sleep_until(const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)：阻塞当前线程直到特定时间点，使当前线程至少等待到特定时间点后继续执行，参数是一种特定格式的时间点数据。</li>\n<li>this_thread::sleep_for(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time)：阻塞当前线程一段时间，使当前线程至少等待特定时长后继续执行，参数是一种特定格式的时间段数据。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 其实c++11标准下，除了thread，还有其他四个用来支持多线程的辅助头文件：<a href=\"http://www.cplusplus.com/reference/atomic/\">atomic</a>、<a href=\"http://www.cplusplus.com/reference/mutex/\">mutex</a>、<a href=\"http://www.cplusplus.com/reference/condition_variable/\">condition_variable</a>、<a href=\"http://www.cplusplus.com/reference/future/\">future</a>。前三个很好理解，分别提供封装好的原子数据类型、互斥锁设备和条件值，future头文件里提供的是一些对分享的数据资源进行竞争的必须设备（我很迷茫头文件为什么不干脆叫share而是叫future这个让人摸不着头脑的名字）。如果读者熟悉操作系统或者进程调度，一定不会对前面这些东西感到陌生。<br>&nbsp;&nbsp;&nbsp; 我们不难管中窥豹猜测多线程的实质，操作系统实现了完善的进程调度，而同样的事情我们要自己对线程再做一遍。线程的调度（包括同步异步、资源调配等等）也就是多线程编程具体要做的事。（还一片茫然的读者请去看任意一本操作系统课本前两三章的样子补补课）<br>&nbsp;&nbsp;&nbsp; 这篇文主要是科普，入门，建立概念，复杂的多线程实现练习之后再慢慢做，当然也会发文的。下一篇文我准备再科普一下POSIX标准的多线程编程，即pthread库的多线程编程。是的，我不打算研究win下的多线程API了，直言不讳的说，我对Windows有偏见。</p>\n",
            "tags": [
                "C++",
                "c++11",
                "多线程"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/10/11/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84C-%E5%AE%9E%E7%8E%B0/",
            "url": "https://blog.bipedalbit.net/2015/10/11/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84C-%E5%AE%9E%E7%8E%B0/",
            "title": "BP神经网络的C++实现",
            "date_published": "2015-10-10T16:28:00.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 之前说了组里的任务是手写BP神经网络，上一篇文总结了一下BP神经网络的概念，老实说，总结概念前的一个C++实现版本在总结概念之后重新审视时觉得实在是惨不忍睹，于是今晚回炉重写了。这篇文就来挂我的BP神经网络C++实现。</p>\n<span id=\"more\"></span>\n\n<p>&nbsp;&nbsp;&nbsp; 老师提出的具体问题是平面对点集的二分类。ACM战过这么多场，写板子早成了习惯，就把通用的BP认真封装了一下：<br>&nbsp;&nbsp;&nbsp; 头文件里的Data结构体是输入数据的数据结构，可自定义，这里用的是点分类问题的模型，BP.h：</p>\n<pre><code class=\"hljs\">#ifndef _BP_H_\n#define _BP_H_\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n/* 数据样本类 */\nstruct Data\n&#123;\n\t/* 输入参数，包括： */\n\t/* 三维直角坐标系点的坐标(x, y, z) */\n\t/* 三维直角坐标系平面a*x + b*y + c*z + d = 0的4个系数 */\n\tdouble x[7];\n\t/* 期望输出即监督值 */\n\t/* 拟合 */\n\t// double d[1];\n\t/* 分类 */\n\tdouble d[2];\n\t/* 数据构造函数 */\n\tData();\n&#125;;\n\nclass BP\n&#123;\nprivate:\n\t/* ========== 常数 ========== */\n\t/* 输入层节点数 */\n\tint I;\n\t/* 隐含层神经元数 */\n\tint H;\n\t/* 输出层神经元数 */\n\tint O;\n\t/* 权重学习速率 */\n\tdouble LR;\n\t/* 偏置学习速率 */\n\tdouble LR2;\n\t/* 学习速率衰减率（每次衰减与当前LR相乘） */\n\tdouble LRDecay;\n\t/* 误差函数收敛阈值 */\n\tdouble C;\n\t/* ========== 容器 ========== */\n\t/* 训练用数据样本集 */\n\tvector&lt;Data&gt; trainDS;\n\t/* 测使用数据集 */\n\tvector&lt;Data&gt; testDS;\n\t/* 输入层与隐含层间的全连接权重：w[I(包含一个偏置值)][H] */\n\tdouble **w;\n\t/* w修正值 */\n\tdouble *dw;\n\t/* 隐含层阈值 */\n\tdouble *th;\n\t/* 隐含层输入积累即净激活，也存放之后的激活输出值：u[H] */\n\tdouble *u;\n\t/* 隐含层与输出层间的全连接权重：v[H][O] */\n\tdouble **v;\n\t/* v修正值 */\n\tdouble *dv;\n\t/* 输出层阈值 */\n\tdouble *to;\n\t/* 输出层输入积累即净激活，也存放之后的激活输出值：y[O] */\n\tdouble *y;\n\t/* 拟合标识 */\n\tbool regression;\n\t/* ========== 方法 ========== */\n\t/* 填充训练用数据样本集 */\n\tvoid fillTrainDS(int sampleCnt);\n\t/* 清空训练用数据样本集 */\n\tvoid clearTrainDS();\n\t/* 填充测试使用数据集 */\n\tvoid fillTestDS(int sampleCnt);\n\t/* 清空测试使用数据集 */\n\tvoid clearTestDS();\n\t/* 预测 */\n\tvoid forward(int index, bool test = false);\n\t/* 调整 */\n\tvoid backward(int index);\npublic:\n\t/* ========== 接口 ========== */\n\t/*\n\t * 类构造函数，初始化BP神经网络结构和训练参数\n\t * int _I：\t\t输入参数数目。\n\t * int _O：\t\t输出值数目。\n\t * int A：\t\t隐含层调整因子（1~10）。\n\t * double _LR：\t\t权重学习速率（0.01~0.8）。\n\t * double _LR2：\t偏置学习速率（0.01~0.8）。\n\t * double _LRDecay：\t学习速率衰减率（每次衰减与当前LR相乘）。\n\t * double _C：\t\t误差函数收敛阈值。\n\t * bool regression：\t拟合标识。\n\t */\n\tBP(int _I, int _O, int A = 1, double _LR = 0.01, double _LR2 = 0.035, double _LRDecay = 1.0, double _C = 0.01, bool regression = false);\n\t/* 类析构函数，释放容器分配的堆空间 */\n\t~BP();\n\t/* 使用指定数目的样本训练指定数目次循环，返回最后的误差函数值 */\n\tdouble train(int sampleCnt = 1000, int trainCnt = 100);\n\t/*\n\t * 使用指定数目的样本循环训练。\n\t * 误差函数值进入可接受范围判定收敛并停止训练；\n\t * 到达最大训练次数时停止训练。\n\t * 返回是否收敛。\n\t */\n\tbool trainTillConvergent(int sampleCnt = 1000, int maxEpoch = 1000);\n\t/* 生成指定数目组数据测试当前神经网络 */\n\tvoid testNetwork(int testCnt = 1000);\n\t/* 保存当前神经网络，即两个权重数组 */\n\tvoid saveNetwork(string wPath = &quot;wNetwork&quot;, string vPath = &quot;vNetwork&quot;);\n\t/* 载入两个权重数组，还原神经网络 */\n\tvoid loadNetwork(string wPath = &quot;wNetwork&quot;, string vPath = &quot;vNetwork&quot;);\n\t/* 使用指定数据预测输出值并返回输出值 */\n\tvector&lt;double&gt; runNetwork(vector&lt;double&gt; x);\n&#125;;\n\n#endif\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 类实现源码里的Data结构体的构造函数是输入数据的处理和问题模型的建立，可自定义，这里用的是点分类问题的数据处理，BP.cpp：</p>\n<pre><code class=\"hljs\">#include &quot;BP.h&quot;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n\n/* 数据构造函数 */\nData::Data()\n&#123;\n\t/* 归一参数 */\n\tfor(int i = 1 ; i &lt; 8 ; i++)\n\t&#123;\n\t\tx[i] = rand()/(double)RAND_MAX;\n\t&#125;\n\t/* 实际参数 */\n\tdouble _x = x[1]*20 - 10;\n\tdouble y = x[2]*20 - 10;\n\tdouble z = x[3]*20 - 10;\n\tdouble a = x[4]*20 - 10;\n\tdouble b = x[5]*20 - 10;\n\tdouble c = x[6]*20 - 10;\n\tdouble _d = x[7]*20 - 10;\n\t/* 拟合 */\n\t// d[0] = z - (a*_x + b*y + _d)/(-1*c);\n\t/* 分类 */\n\td[0] = z &gt; (a*_x + b*y + _d)/(-1*c) ? 1 : 0;\n\td[1] = d[0] ? 0 : 1;\n&#125;\n\n/* 填充训练用数据样本集 */\nvoid BP::fillTrainDS(int sampleCnt)\n&#123;\n\twhile(sampleCnt--)\n\t&#123;\n\t\ttrainDS.push_back(Data());\n\t&#125;\n&#125;\n\n/* 清空训练用数据样本集 */\nvoid BP::clearTrainDS()\n&#123;\n\tvector&lt;Data&gt; v;\n\ttrainDS.swap(v);\n&#125;\n\n/* 填充测试使用数据集 */\nvoid BP::fillTestDS(int sampleCnt)\n&#123;\n\twhile(sampleCnt--)\n\t&#123;\n\t\ttestDS.push_back(Data());\n\t&#125;\n&#125;\n\n/* 清空测试使用数据集 */\nvoid BP::clearTestDS()\n&#123;\n\tvector&lt;Data&gt; v;\n\ttestDS.swap(v);\n&#125;\n\n/* 预测 */\nvoid BP::forward(int index, bool test)\n&#123;\n\t/* 隐含层 */\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tu[i] = 0;\n\t\tfor(int j = 0 ; j &lt; I ; j++)\n\t\t&#123;\n\t\t\tdouble x = test ? testDS[index].x[j] : trainDS[index].x[j];\n\t\t\t/* 积累输入 */\n\t\t\tu[i] += w[j][i]*x;\n\t\t&#125;\n\t\tu[i] += th[i];\n\t\t/* Sigmoid函数作为激活函数 */\n\t\tu[i] = 1 / (1 + exp(-1*u[i]));\n\t&#125;\n\t/* 输出层 */\n\tfor(int i = 0 ; i &lt; O ; i++)\n\t&#123;\n\t\ty[i] = 0;\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\t/* 积累输入 */\n\t\t\ty[i] += v[j][i]*u[j];\n\t\t&#125;\n\t\ty[i] += to[i];\n\t\t/* 分类：Sigmoid函数作为激活函数 */\n\t\tif (!regression)\n\t\t&#123;\n\t\t\ty[i] = 1 / (1 + exp(-1*y[i]));\n\t\t&#125;\n\t&#125;\n&#125;\n\n/* 调整 */\nvoid BP::backward(int index)\n&#123;\n\t/* 计算隐含层与输出层间权重调整值 */\n\tfor(int i = 0 ; i &lt; O ; i++)\n\t&#123;\n\t\t/* 拟合：计算输出层学习误差 */\n\t\tif (regression)\n\t\t&#123;\n\t\t\tdv[i] = y[i] - trainDS[index].d[i];\n\t\t&#125;\n\t\t/* 分类：计算输出层学习误差 */\n\t\telse\n\t\t&#123;\n\t\t\tdv[i] = (y[i] - trainDS[index].d[i])*y[i]*(1 - y[i]);\n\t\t&#125;\n\t&#125;\n\t/* 计算输入层与隐含层间权重调整值 */\n\tdouble t;\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tt = 0;\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\tt += dv[j]*v[i][j];\n\t\t&#125;\n\t\tdw[i] = t*u[i]*(1 - u[i]);\n\t&#125;\n\t/* 调整隐含层与输出层间权重 */\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\tv[i][j] -= LR*dv[j]*u[i];\n\t\t&#125;\n\t&#125;\n\t/* 调整输出层偏置 */\n\tfor(int i = 0 ; i &lt; O ; i++)\n\t&#123;\n\t\tto[i] -= LR2*dv[i];\n\t&#125;\n\t/* 调整输入层与隐含层间权重 */\n\tfor(int i = 0 ; i &lt; I ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\tw[i][j] -= LR*dw[j]*trainDS[index].x[i];\n\t\t&#125;\n\t&#125;\n\t/* 调整隐含层偏置 */\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tth[i] -= LR2*dw[i];\n\t&#125;\n&#125;\n\n/*\n * 类构造函数，初始化BP神经网络结构和训练参数\n * int _I：\t\t输入参数数目，包括偏置值对应的参数-1。\n * int _O：\t\t输出值数目。\n * int A：\t\t隐含层调整因子（1~10）。\n * double _LR：\t\t权重学习速率（0.01~0.8）。\n * double _LR2：\t偏置学习速率（0.01~0.8）。\n * double _LRDecay：\t学习速率衰减率（每次衰减与当前LR相乘）。\n * double _C：\t\t误差函数收敛阈值。\n * bool regression：\t拟合标识。\n */\nBP::BP(int _I, int _O, int A, double _LR, double _LR2, double _LRDecay, double _C, bool _regression)\n&#123;\n\t/* ========== 初始化常数 ========== */\n\tI = _I;\n\tH = ceil(sqrt(_I + _O)) + A;\n\tO = _O;\n\tLR = _LR;\n\tLR2 = _LR2;\n\tLRDecay = _LRDecay;\n\tC = _C;\n\tregression = _regression;\n\t/* ========== 初始化容器 ========== */\n\tsrand((unsigned)time(NULL));\n\t/* 初始化w */\n\tw = new double*[I];\n\tfor(int i = 0 ; i &lt; I ; i++)\n\t&#123;\n\t\tw[i] = new double[H];\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\tw[i][j] = rand()/(double)RAND_MAX;\n\t\t&#125;\n\t&#125;\n\t/* 初始化dw */\n\tdw = new double[H];\n\t/* 初始化th */\n\tth = new double[H];\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tth[i] = rand()/(double)RAND_MAX;\n\t&#125;\n\t/* 初始化u */\n\tu = new double[H];\n\t/* 初始化v */\n\tv = new double*[H];\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tv[i] = new double[O];\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\tv[i][j] = rand()/(double)RAND_MAX;\n\t\t&#125;\n\t&#125;\n\t/* 初始化dv */\n\tdv = new double[O];\n\t/* 初始化to */\n\tto = new double[O];\n\tfor(int i = 0 ; i &lt; O ; i++)\n\t&#123;\n\t\tto[i] = rand()/(double)RAND_MAX;\n\t&#125;\n\t/* 初始化y */\n\ty = new double[O];\n&#125;\n\n/* 类析构函数，释放容器分配的堆空间 */\nBP::~BP()\n&#123;\n\t/* 释放w */\n\tfor(int i = 0 ; i &lt; I ; i++)\n\t&#123;\n\t\tdelete []w[i];\n\t&#125;\n\tdelete []w;\n\t/* 释放dw */\n\tdelete []dw;\n\t/* 释放th */\n\tdelete []th;\n\t/* 释放u */\n\tdelete []u;\n\t/* 释放v */\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tdelete []v[i];\n\t&#125;\n\tdelete []v;\n\t/* 释放dv */\n\tdelete []dv;\n\t/* 释放to */\n\tdelete []to;\n\t/* 释放y */\n\tdelete []y;\n&#125;\n\n/* 使用指定数目的样本训练指定数目次循环，返回最后的误差函数值 */\ndouble BP::train(int sampleCnt, int trainCnt)\n&#123;\n\tfillTrainDS(sampleCnt);\n\tdouble e;\n\twhile(trainCnt--)\n\t&#123;\n\t\te = 0;\n\t\tfor(int i = 0 ; i &lt; trainDS.size() ; i++)\n\t\t&#123;\n\t\t\t/* 预测 */\n\t\t\tforward(i);\n\t\t\t/* 误差积累 */\n\t\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t\t&#123;\n\t\t\t\te += pow(y[j] - trainDS[i].d[j], 2.0);\n\t\t\t&#125;\n\t\t\t/* 调整 */\n\t\t\tbackward(i);\n\t\t&#125;\n\t\te /= 2*sampleCnt;\n\t\t/* 学习速率衰减 */\n\t\tif (LR &gt; 0.01)\n\t\t&#123;\n\t\t\tLR *= LRDecay;\n\t\t&#125;\n\t&#125;\n\tclearTrainDS();\n\treturn e;\n&#125;\n\n/*\n * 使用指定数目的样本循环训练。\n * 误差函数值进入可接受范围判定收敛并停止训练；\n * 到达最大训练次数时停止训练。\n * 返回是否收敛。\n */\nbool BP::trainTillConvergent(int sampleCnt, int maxEpoch)\n&#123;\n\tfillTrainDS(sampleCnt);\n\tdouble e;\n\tfor(;;)\n\t&#123;\n\t\te = 0;\n\t\tfor(int i = 0 ; i &lt; trainDS.size() ; i++, maxEpoch--)\n\t\t&#123;\n\t\t\tif (!maxEpoch)\n\t\t\t&#123;\n\t\t\t\tclearTrainDS();\n\t\t\t\treturn false;\n\t\t\t&#125;\n\t\t\t/* 预测 */\n\t\t\tforward(i);\n\t\t\t/* 误差积累 */\n\t\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t\t&#123;\n\t\t\t\te += pow(y[j] - trainDS[i].d[j], 2.0);\n\t\t\t&#125;\n\t\t\t/* 调整 */\n\t\t\tbackward(i);\n\t\t&#125;\n\t\t/* 判定收敛，中止训练 */\n\t\tif (e/(2*sampleCnt) &lt; C)\n\t\t&#123;\n\t\t\tclearTrainDS();\n\t\t\treturn true;\n\t\t&#125;\n\t\t/* 学习速率衰减 */\n\t\tif (LR &gt; 0.01)\n\t\t&#123;\n\t\t\tLR *= LRDecay;\n\t\t&#125;\n\t&#125;\n\tclearTrainDS();\n\treturn false;\n&#125;\n\n/* 生成指定数目组数据测试当前神经网络 */\nvoid BP::testNetwork(int testCnt)\n&#123;\n\tfillTestDS(testCnt);\n\tdouble e = 0;\n\tfor(int i = 0 ; i &lt; testCnt ; i++)\n\t&#123;\n\t\tforward(i, true);\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\te += pow(y[j] - testDS[i].d[j], 2.0);\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; testCnt &lt;&lt; &quot;组数据测试预测值相对期望值方差为：&quot; &lt;&lt; e/(2*testCnt) &lt;&lt; endl;\n\tclearTestDS();\n&#125;\n\n/* 保存当前神经网络，即两个权重数组 */\nvoid BP::saveNetwork(string wPath, string vPath)\n&#123;\n\tofstream fout_w(wPath);\n\tif(fout_w == NULL)\n\t&#123;\n\t\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i = 0 ; i &lt; I ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\tfout_w &lt;&lt; w[i][j] &lt;&lt; &#39;\\t&#39;;\n\t\t&#125;\n\t\tfout_w &lt;&lt; &#39;\\n&#39;;\n\t&#125;\n\tfout_w.close();\n\tofstream fout_v(vPath);\n\tif(fout_v == NULL)\n\t&#123;\n\t\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\tfout_v &lt;&lt; v[i][j] &lt;&lt; &#39;\\t&#39;;\n\t\t&#125;\n\t\tfout_v &lt;&lt; &#39;\\n&#39;;\n\t&#125;\n\tfout_v.close();\n&#125;\n\n/* 载入两个权重数组，还原神经网络 */\nvoid BP::loadNetwork(string wPath, string vPath)\n&#123;\n\tifstream fin_w(wPath);\n\tif(fin_w == NULL)\n\t&#123;\n\t\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i = 0 ; i &lt; I ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\tfin_w &gt;&gt; w[i][j];\n\t\t&#125;\n\t&#125;\n\tfin_w.close();\n\tifstream fin_v(vPath);\n\tif(fin_v == NULL)\n\t&#123;\n\t\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tfor(int j = 0 ; j &lt; O ; j++)\n\t\t&#123;\n\t\t\tfin_v &gt;&gt; v[i][j];\n\t\t&#125;\n\t&#125;\n\tfin_v.close();\n&#125;\n\n/* 使用指定数据预测输出值并返回输出值 */\nvector&lt;double&gt; BP::runNetwork(vector&lt;double&gt; x)\n&#123;\n\t/* 隐含层 */\n\tfor(int i = 0 ; i &lt; H ; i++)\n\t&#123;\n\t\tu[i] = 0;\n\t\tfor(int j = 0 ; j &lt; x.size() ; j++)\n\t\t&#123;\n\t\t\t/* 积累输入 */\n\t\t\tu[i] += w[j][i]*x[j];\n\t\t&#125;\n\t\tu[i] += th[i];\n\t\t/* Sigmoid函数作为激活函数 */\n\t\tu[i] = 1 / (1 + exp(-1*u[i]));\n\t&#125;\n\tvector&lt;double&gt; o;\n\tdouble y;\n\t/* 输出层 */\n\tfor(int i = 0 ; i &lt; O ; i++)\n\t&#123;\n\t\ty = 0;\n\t\tfor(int j = 0 ; j &lt; H ; j++)\n\t\t&#123;\n\t\t\t/* 积累输入 */\n\t\t\ty += v[j][i]*u[j];\n\t\t&#125;\n\t\ty += to[i];\n\t\t/* 分类：Sigmoid函数作为激活函数 */\n\t\tif (!regression)\n\t\t&#123;\n\t\t\ty = 1 / (1 + exp(-1*y));\n\t\t&#125;\n\t\to.push_back(y);\n\t&#125;\n\treturn o;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 类的测试方法里无非是根据实际问题初始化类，做一系列的训练，调整参数，慢慢提高预测精度，test.cpp：</p>\n<pre><code class=\"hljs\">#include &quot;BP.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\t/*\n\t * 类构造函数，初始化BP神经网络结构和训练参数\n\t * int _I：\t\t输入参数数目，包括偏置值对应的参数-1。\n\t * int _O：\t\t输出值数目。\n\t * int A：\t\t隐含层调整因子（1~10）。\n\t * double _LR：\t\t学习速率（0.01~0.8）。\n\t * double _LR2：\t偏置学习速率（0.01~0.8）。\n\t * double _LRDecay：\t学习速率衰减率（每次衰减与当前LR相乘）。\n\t * double _C：\t\t误差函数收敛阈值。\n\t * bool regression：\t拟合标识。\n\t */\n\tBP o(7, 2, 8, 0.2, 0.02, 0.99, 3.2e-2, false);\n\n\t// o.loadNetwork();\n\n\t/* 使用指定数目的样本训练指定数目次循环，返回最后的误差函数值 */\n\tfor(int i = 0 ; i &lt; 20 ; i++)\n\t&#123;\n\t\tcout &lt;&lt; &quot;误差函数值：&quot; &lt;&lt; o.train(1000, 2e3) &lt;&lt; endl;\n\t&#125;\n\n\t/*\n\t * 使用指定数目的样本循环训练。\n\t * 误差函数值进入可接受范围判定收敛并停止训练；\n\t * 到达最大训练次数时停止训练。\n\t * 返回是否收敛。\n\t */\n\t// bool success = o.trainTillConvergent(1000, 1e5*1000);\n\t// cout &lt;&lt; &quot;收敛：&quot; &lt;&lt; (success ? &quot;success&quot; : &quot;fail&quot;) &lt;&lt; endl;\n\n\to.testNetwork(1000);\n\n\to.saveNetwork();\n\n\tvector&lt;double&gt; X;\n\tdouble x = 0.1;\n\tdouble y = 0.1;\n\tdouble z = 0.1;\n\tdouble a = 1;\n\tdouble b = 1;\n\tdouble c = 1;\n\tdouble d = -1;\n\tX.push_back((x + 10)/20.0);\n\tX.push_back((y + 10)/20.0);\n\tX.push_back((z + 10)/20.0);\n\tX.push_back((a + 10)/20.0);\n\tX.push_back((b + 10)/20.0);\n\tX.push_back((c + 10)/20.0);\n\tX.push_back((d + 10)/20.0);\n\tvector&lt;double&gt; Y = o.runNetwork(X);\n\t/* 拟合 */\n\t// cout &lt;&lt; &quot;期望值：&quot; &lt;&lt; z - (a*x + b*y + d)/(-c) &lt;&lt; endl;\n\t// cout &lt;&lt; &quot;输出值：&quot; &lt;&lt; Y[0] &lt;&lt; endl;\n\t/* 分类 */\n\tcout &lt;&lt; &quot;期望值：&quot; &lt;&lt; (z &gt; (a*x + b*y + d)/(-c) ? &quot;1\\t0&quot; : &quot;0\\t1&quot;) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;输出值：&quot; &lt;&lt; Y[0] &lt;&lt; &#39;\\t&#39; &lt;&lt; Y[1] &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 点分类问题我先尝试了函数拟合方式，训练情况很糟糕，动辄上十万的方差。后来改用分类方式，降低训练要求，方差立马降下来了。下午例会就要做报告了，我没有训练到充分收敛，但是离平面比较远的点判断正确率已经很高了。下面提供平面分类点集问题当前训练进度下，输入层与隐含层间权重数组、隐含层与输出层间权重数组的保存文件。</p>\n<p>&nbsp;&nbsp;&nbsp; 输入层与隐含层间权重数组wNetwork：</p>\n<pre><code class=\"hljs\">0.15513\t0.56829\t0.461073\t0.27552\t0.44408\t0.144657\t0.95798\t0.335522\t0.325092\t0.254423\t0.79217\n-1.06417\t-0.0241895\t3.99915\t0.228275\t-0.483658\t6.68402\t-1.61574\t0.753689\t4.14272\t-4.58112\t-3.09481\n3.70442\t-3.7423\t0.0852013\t-0.564758\t-4.99619\t1.29436\t-4.19077\t-1.75579\t-0.568722\t-2.57748\t1.20149\n-0.311858\t2.12485\t0.494471\t-3.32854\t-0.393046\t1.12112\t-0.585242\t-3.45739\t-0.687711\t-1.37346\t-0.860532\n1.29214\t0.74987\t4.41025\t-1.37666\t0.268284\t6.72309\t2.0978\t-1.8259\t4.20105\t-6.15165\t5.04569\n-3.76331\t-3.22432\t-0.450262\t1.77063\t-5.89358\t3.40051\t3.64122\t1.30879\t-0.98291\t-0.931413\t-1.72719\n9.53636\t9.64562\t9.82743\t13.4779\t-12.3668\t12.5147\t8.37658\t6.32437\t-10.263\t-13.8476\t-5.31933\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 隐含层与输出层间权重数组vNetwork：</p>\n<pre><code class=\"hljs\">31.4711\t-31.5094\n27.536\t-27.5713\n-25.7692\t25.7999\n-27.4329\t27.467\n-17.6709\t17.6933\n-18.464\t17.5204\n25.8167\t-25.8471\n-23.2151\t23.2434\n27.3533\t-27.387\n26.9126\t-26.9519\n-24.7905\t24.8209\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 这个类我还做过a+b问题的函数拟合，收敛非常顺利，精度很高。<br>&nbsp;&nbsp;&nbsp; <strong>后来，例会上提任务的博士说他明明是要我们寻找分割点集的平面，我把问题泛化成寻找点与平面位置关系规则的问题了，能用泛化能力不太强的BP整的差不多收敛也是不容易。我表示生无可恋……</strong></p>\n<p>&nbsp;&nbsp;&nbsp; <strong>读者注意一下，上一篇BP网络的理论介绍中，隐层与输入层之间的权重调整值的推导有一些问题，少乘了一个wij。推导已经改过来了，但是比较忙没空改代码，有需要的同学请自己参照上一篇博文修改一下代码。OTZ</strong></p>\n",
            "tags": [
                "C++",
                "BP神经网络",
                "机器学习"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "url": "https://blog.bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "title": "C++二进制-十进制转换器",
            "date_published": "2015-10-08T14:05:52.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 布置了二进制-十进制转换器的小作业，本来还要求顺手扩展一下大数的四则运算，我嫌麻烦没做扩展，就只是写来玩玩。也算熟悉一下底层的二进制-十进制转换机制，顺便复习下C++源码规范。注释写了很多，就不多做解释了，只贴代码。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; converter.h:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#ifndef _CONVERTER_H_\n#define _CONVERTER_H_\n\n#include &lt;string&gt;\n\n/*\n * This is a class to offer operations converting radix of number in string.\n */\nclass Converter\n&#123;\nprivate:\n\t/* to store the binary form of picked up number string */\n\tstd::string binVal;\n\t/* to store the decimal form of picked up number string */\n\tstd::string decVal;\n\t/* to sign the number by marking wether it is negtive */\n\tbool negtive;\n\t/* to mark wether the number has a dot */\n\tbool hasDot;\n\t/* to store the index of dot in binary number string */\n\tint binDotIndex;\n\t/* to store the index of dot in decimal number string */\n\tint decDotIndex;\n\t/* max reserved digits sum when float converted from decimal to binary */\n\tint binFloatPrecision;\n\t/*\n\t * Convert the binary number to decimal form then fill this-&gt;decVal.\n\t */\n\tvoid bin2Dec();\n\t/*\n\t * Convert the decimal number to binary form then fill this-&gt;binVal.\n\t */\n\tvoid dec2Bin();\npublic:\n\t/*\n\t * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n\t */\n\tConverter(std::string str, int radix, int binFloatPrecision = 20);\n\t/*\n\t * Get the the number string with specified radix.\n\t */\n\tstd::string getNum(int radix);\n&#125;;\n\n#endif\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; converter.cpp:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n #include &quot;converter.h&quot;\n #include &lt;iostream&gt;\n #include &lt;stdexcept&gt;\n\n/*\n * name: Converter\n * args:\n *\tstring str: the original string containing target number\n *\tint radix: the radix of the number to pick up form str\n *\tint binFloatPrecision: max reserved digits sum when float converted from decimal to binary\n *\t\twhose default value is 20\n * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n */\n Converter::Converter(std::string str, int radix, int binFloatPrecision)\n&#123;\n\t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* check binFloatPrecision */\n\tif (binFloatPrecision &lt; 1)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: binFloatPrecision should be greater than 0.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* fill this-&gt;binFloatPrecision */\n\tthis-&gt;binFloatPrecision = binFloatPrecision;\n\t/* assistant variables for traversing the original string */\n\tint len = str.size();\n\tint i = 0;\n\t/* mark wether there&#39;s a dot in the number */\n\tbool hasDot = false;\n\t/* store number string temporarily */\n\tstd::string tmp = &quot;&quot;;\n\tif (len &gt; 0)\n\t&#123;\n\t\t/* handle binary radix */\n\t\tif (radix == 2)\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get &#39;0&#39;s and &#39;1&#39;s only */\n\t\t\t\tif (str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\t/* handle decimal radix */\n\t\telse\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; !(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get all arabic numerals */\n\t\t\t\tif(!(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t/* if no number picked up set 0 */\n\tif(tmp == &quot;&quot;)\n\t&#123;\n\t\ttmp = &quot;0&quot;;\n\t&#125;\n\t/* add &#39;0&#39; if necessary */\n\tif (tmp[0] == &#39;.&#39;)\n\t&#123;\n\t\ttmp = &#39;0&#39; + tmp;\n\t&#125;\n\t/* mark wether the number has a dot */\n\tthis-&gt;hasDot = hasDot;\n\t/* fill corresponding number form */\n\tif (radix == 2)\n\t&#123;\n\t\tthis-&gt;binVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of binary form */\n\t\t\tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tbin2Dec();\n\t&#125;\n\telse\n\t&#123;\n\t\tthis-&gt;decVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of decimal form */\n\t\t\tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tdec2Bin();\n\t&#125;\n\t/* have a test */\n/*\n\tstd::cout &lt;&lt; &quot;radix: 2&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;binVal &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; &quot;radix: 10&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;decVal &lt;&lt; std::endl;\n*/\n&#125;\n\n/*\n * name: getNum\n * arguments:\n *\tint radix: spedify a radix to find which form number is to got\n * return: the number string with specified form\n * access: public\n * Get the the number string with specified radix.\n */\n std::string Converter::getNum(int radix)\n &#123;\n \t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn NULL;\n\t&#125;\n \tstd::string tmp = &quot;&quot;;\n \t/* add the &#39;-&#39; character if necessary */\n \tif (this-&gt;negtive)\n \t&#123;\n \t\ttmp += &#39;-&#39;;\n \t&#125;\n \t/* add the binary form number */\n \tif (radix == 2)\n \t&#123;\n \t\ttmp += this-&gt;binVal;\n \t&#125;\n \t/* add the decimal form number */\n \telse\n \t&#123;\n \t\ttmp += this-&gt;decVal;\n \t&#125;\n \treturn tmp;\n &#125;\n\n/*\n * name: bin2Dec\n * access: private\n * Convert the binary number to decimal form then fill this-&gt;decVal.\n */\n void Converter::bin2Dec()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the binary number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;binDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;binVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint decLen;\n \t/* convert radix digit by digit while traversing the int part of the binary number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new binary digit into carry */\n \t\tcarry += this-&gt;binVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tdecLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 2 and add carries */\n \t\tfor(int j = decLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\ttmp[j] = tmp[j]*2+carry;\n \t\t\tif (tmp[j] &gt; 9)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/10;\n \t\t\t\t/* limit digit within 10 */\n \t\t\t\ttmp[j] %= 10;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%10)+tmp;\n \t\t\tcarry /= 10;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* get the length except the float part */\n \t\tint decIntLen = tmp.size();\n \t\t/* get the length of the whole binary number string */\n \t\tint binLen = this-&gt;binVal.size();\n \t\t/* convert radix digit by digit while traversing the float part of the binary number string */\n \t\tfor(int i = binLen-1 ; i &gt; intLen ; i--)\n \t\t&#123;\n \t\t\t/* carry to first float digit if occur a &#39;1&#39; */\n \t\t\tcarry = (this-&gt;binVal[i] == &#39;1&#39; ? 5 : 0);\n \t\t\t/* update tmp&#39;s length */\n \t\t\tdecLen = tmp.size();\n \t\t\t/* traverse tmp to divide each digit by 2 and add carries */\n \t\t\tfor(int j = decIntLen ; j &lt; decLen ; j++)\n \t\t\t&#123;\n \t\t\t\tif (tmp[j] &amp; 1)\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 5;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* expand digit if necessary */\n \t\t\tif (carry)\n \t\t\t&#123;\n \t\t\t\ttmp += carry;\n \t\t\t&#125;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;decVal and this-&gt;decDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;decVal = tmp;\n \tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n\n/*\n * name: dec2Bin\n * access: private\n * Convert the decimal number to binary form then fill this-&gt;binVal.\n */\n void Converter::dec2Bin()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the decimal number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;decDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;decVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint binLen;\n \t/* convert radix digit by digit while traversing the int part of the decimal number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new decimal digit into carry */\n \t\tcarry += this-&gt;decVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tbinLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 10 and add carries */\n \t\tfor(int j = binLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\t/*\n \t\t\t * Type of tmp[] is char[] and MAX_CHAR = 127 &gt; 99.\n \t\t\t * So the assignment statement below will work safely.\n \t\t\t */\n \t\t\ttmp[j] = tmp[j]*10+carry;\n \t\t\tif (tmp[j] &gt; 1)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/2;\n \t\t\t\t/* limit digit within 2 */\n \t\t\t\ttmp[j] &amp;= 1;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%2)+tmp;\n \t\t\tcarry /= 2;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n\tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* may need carry while traversing digits */\n \t\tcarry = 0;\n \t\t/* get the length of the whole decimal number string */\n \t\tint decLen = this-&gt;decVal.size();\n \t\t/* get the length of the float part of the decimal number string */\n \t\tint floatLen = decLen-intLen-1;\n \t\t/* get a copy of the float part of the decimal number string */\n \t\tstd::string tmp2 = this-&gt;decVal.substr(intLen+1, floatLen);\n \t\t/* adjust tmp2 to prepare for algorithm below */\n \t\tfor(int i = 0 ; i &lt; floatLen ; i++)\n \t\t&#123;\n \t\t\ttmp2[i] -= &#39;0&#39;;\n \t\t&#125;\n \t\t/*\n \t\t * asume:   B = b1*2^-1 + b2*2^-2 + b3*2^-3 + ...\n \t\t *            2*B = b1 + b2*2^-1 + b3*2^-2 + ... \t// take b1 as first digit\n \t\t * 2*(2*B-b1) = b2 + b3*2^-1 + ... \t\t// take b2 as second digit\n \t\t * \t\t...\n \t\t * so the binary float will got digit by digit in order\n \t\t */\n \t\tfor(int i = 0 ; i &lt; this-&gt;binFloatPrecision ; i++)\n \t\t&#123;\n \t\t\t/* traverse tmp2 to multiply each digit by 2 and add carries */\n \t\t\tfor(int j = floatLen-1 ; j &gt;= 0 ; j--)\n \t\t\t&#123;\n \t\t\t\ttmp2[j] = tmp2[j]*2+carry;\n \t\t\t\tif (tmp2[j] &gt; 9)\n \t\t\t\t&#123;\n \t\t\t\t\t/* update carry */\n \t\t\t\t\tcarry = tmp2[j]/10;\n \t\t\t\t\t/* limit digit within 10 */\n \t\t\t\t\ttmp2[j] %= 10;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* get the last carry as new digit of binary float */\n \t\t\ttmp += carry;\n \t\t\t/* reset carry */\n \t\t\tcarry = 0;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;binVal and this-&gt;binDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;binVal = tmp;\n \tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; test.cpp:</p>\n<pre><code class=\"hljs\">#include &quot;converter.h&quot;\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\t//Converter c(&quot;0.625&quot;, 10);\n\tConverter c(&quot;ujsgdfksagrua0.10100000000000000000&quot;, 2);\n\tcout &lt;&lt; c.getNum(10) &lt;&lt; endl;\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 都过500行了，会不会写得有点啰嗦？</p>\n",
            "tags": [
                "C++",
                "进制转换"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/10/08/C-cin%E3%80%81cout%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%84/",
            "url": "https://blog.bipedalbit.net/2015/10/08/C-cin%E3%80%81cout%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%84/",
            "title": "C++ cin、cout的优化及测评",
            "date_published": "2015-10-08T11:56:46.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 参加过ACM比赛和部分自己做过测评的人想必不难发现，C++的cin和cout虽然比起C的scanf和printf来方便很多，但是速度似乎会打很大折扣。于是不求甚解的人们一拍脑门，认定因为C更“底层”，封装程度更低，所以势必比C++的输入输出执行效率更高。然而如若C++有知，恐怕要苦笑了。因为C++正是为了兼容C的输入输出才要在cin、cout中进行指针同步，降低了执行效率。那么可能挽回这种效率损失吗？答案是可以。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; C++中提供了解除指针同步的方法：<code>ios::sync_with_stdio(false)</code>。如字面意思，这个方法用来设置输入输出流是否与C的stdio同步。那么解除同步之后能有多大效果呢？毕竟C++确实因为封装程度比C高多多少少损失了一些执行效率。我动手进行了一系列测评，下面是源码。</p>\n<p>&nbsp;&nbsp;&nbsp; 这里我统一对输入输出做了重定向，不论是输入数据来源还是输入数据目标都是“data”文件。所有的输入&#x2F;输出测试都是读或写10^7次字符串与整型数的组合数据，每种输入&#x2F;输出测试都进行10次并取平均耗时作为评估值。</p>\n<p>&nbsp;&nbsp;&nbsp; 首先是C的输入输出。</p>\n<p>&nbsp;&nbsp;&nbsp; scanf.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tfreopen(&quot;data&quot;, &quot;r&quot;, stdin);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tchar s[20];\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tscanf(&quot;%s&quot;, s);\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tprintf(&quot;average cost: %lfs\\n&quot;, t_sum/testCnt);\n\tfclose(stdin);\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; printf.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tfreopen(&quot;data&quot;, &quot;w&quot;, stdout);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;string%d\\n&quot;, i);\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tprintf(&quot;average cost: %lfs\\n&quot;, t_sum/testCnt);\n\tfclose(stdout);\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 然后是不解锁同步的cin、cout方法。</p>\n<p>&nbsp;&nbsp;&nbsp; cin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tifstream fin(&quot;data&quot;);\n\tstreambuf *_cin =  cin.rdbuf(fin.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcin.rdbuf(_cin);\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; cout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tofstream fout(&quot;data&quot;);\n\tstreambuf *_cout =  cout.rdbuf(fout.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcout.rdbuf(_cout);\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 接下来是解锁同步的cin、cout方法。</p>\n<p>&nbsp;&nbsp;&nbsp; optimized_cin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tios::sync_with_stdio(false);\n\tifstream fin(&quot;data&quot;);\n\tstreambuf *_cin =  cin.rdbuf(fin.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcin.rdbuf(_cin);\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; optimized_cout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tios::sync_with_stdio(false);\n\tofstream fout(&quot;data&quot;);\n\tstreambuf *_cout =  cout.rdbuf(fout.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcout.rdbuf(_cout);\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 同时测试C++直接读写文件的方法。</p>\n<p>&nbsp;&nbsp;&nbsp; fin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tifstream fin(&quot;data&quot;);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tfin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; fout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tofstream fout(&quot;data&quot;);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tfout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 下面是测试结果：</p>\n<table><tr><th></th><th>scanf与printf</th><th>cin与cout</th><th>优化的cin与cout</th>\t<th>fin与fout</th></tr><tr><td>输入</td><td>1.125694s</td><td>2.46949s</td><td>0.950055s</td><td>0.834976s</td></tr><tr><td>输出</td><td>1.304706s</td><td>1.46059s</td><td>1.41783s</td><td>1.41298s</td></tr></table>\n\n<p>&nbsp;&nbsp;&nbsp; 可以看到，事实上，解开同步之前，cin耗时是scanf的两倍还多，cout则比printf略慢。解开枷锁的cin执行效率与直接读文件接近，甚至比C的scanf还要快。至于输出，解开同步的cout执行效率略有提高，同样接近直接写文件，但是确实还是比C的printf略慢一点。</p>\n",
            "tags": [
                "C++",
                "cin",
                "cout",
                "scanf",
                "printf"
            ]
        },
        {
            "id": "https://blog.bipedalbit.net/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/",
            "url": "https://blog.bipedalbit.net/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/",
            "title": "Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置",
            "date_published": "2015-08-16T14:45:46.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 不自己动手为Sublime配个C&#x2F;C++的通用Makefile脚本吗？不能自动编译链接多文件的编辑器不是好IDE。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 首先我们需要了解几个事实：</p>\n<p>&nbsp;&nbsp;&nbsp; 1.Sublime自带的C&#x2F;C++编译+执行配置使用的是g++编译器，此外这套配置只针对单文件程序。如果要编译多文件，只能采用入口函数所在文件包含需要的源文件而非头文件的方式。比起我们熟悉的几种IDE，这显然无法令人接受。</p>\n<p>&nbsp;&nbsp;&nbsp; 2.Linux下的C&#x2F;C++程序员应该熟悉Makefile，Makefile可以算是一种脚本，执行关键字是一般是make，它可以设计多文件程序的编译+链接过程，生成.o文件和可执行文件。</p>\n<p>&nbsp;&nbsp;&nbsp; 3.Sublime也有默认的Make配置，但是第一，Sublime没有提供通用的C&#x2F;C++的Makefile脚本（自动组织而非每次手动重写），第二点是个小瑕疵，Sublime提供的Make配置只有编译、链接、清理功能，执行程序需要手动。</p>\n<p>&nbsp;&nbsp;&nbsp; 之前重写红黑树最重要的副产品就是一个通用的C&#x2F;C++的Makefile脚本。每次使用基本只需要改改输出的可执行文件名，或者干脆想个默认文件名以后都不改了，gcc&#x2F;g++编译器的选择是自动的，当然也可以手动配置一些编译选项，这个自己看脚本注释就好。上干货：</p>\n<pre><code class=\"hljs\">#############################################################\n# Generic Makefile for C/C++ Program\n#\n# License: GPL (General Public License)\n# Author:  whyglinux &lt;whyglinux AT gmail DOT com&gt;\n# Date:    2006/03/04 (version 0.1)\n#          2007/03/24 (version 0.2)\n#          2007/04/09 (version 0.3)\n#          2007/06/26 (version 0.4)\n#          2008/04/05 (version 0.5)\n#\n# Description:\n# ------------\n# This is an easily customizable makefile template. The purpose is to\n# provide an instant building environment for C/C++ programs.\n#\n# It searches all the C/C++ source files in the specified directories,\n# makes dependencies, compiles and links to form an executable.\n#\n# Besides its default ability to build C/C++ programs which use only\n# standard C/C++ libraries, you can customize the Makefile to build\n# those using other libraries. Once done, without any changes you can\n# then build programs using the same or less libraries, even if source\n# files are renamed, added or removed. Therefore, it is particularly\n# convenient to use it to build codes for experimental or study use.\n#\n# GNU make is expected to use the Makefile. Other versions of makes\n# may or may not work.\n#\n# Usage:\n# ------\n# 1. Copy the Makefile to your program directory.\n# 2. Customize in the &quot;Customizable Section&quot; only if necessary:\n#    * to use non-standard C/C++ libraries, set pre-processor or compiler\n#      options to &lt;MY_CFLAGS&gt; and linker ones to &lt;MY_LIBS&gt;\n#      (See Makefile.gtk+-2.0 for an example)\n#    * to search sources in more directories, set to &lt;SRCDIRS&gt;\n#    * to specify your favorite program name, set to &lt;PROGRAM&gt;\n# 3. Type make to start building your program.\n#\n# Make Target:\n# ------------\n# The Makefile provides the following targets to make:\n#   $ make           compile and link\n#   $ make NODEP=yes compile and link without generating dependencies\n#   $ make objs      compile only (no linking)\n#   $ make tags      create tags for Emacs editor\n#   $ make ctags     create ctags for VI editor\n#   $ make clean     clean objects and the executable file\n#   $ make distclean clean objects, the executable and dependencies\n#   $ make help      get the usage of the makefile\n#\n#===========================================================================\n\n## Customizable Section: adapt those variables to suit your program.\n##==========================================================================\n\n# The pre-processor and compiler options.\nMY_CFLAGS =\n\n# The linker options.\nMY_LIBS   =\n\n# The pre-processor options used by the cpp (man cpp for more).\n# CPPFLAGS  = -Wall\n\n# The options used in linking as well as in any direct use of ld.\nLDFLAGS   =\n\n# The directories in which source files reside.\n# If not specified, only the current directory will be serached.\nSRCDIRS   =\n\n# The executable file name.\n# If not specified, current directory name or `a.out&#39; will be used.\nPROGRAM   = test\n\n## Implicit Section: change the following only when necessary.\n##==========================================================================\n\n# The source file types (headers excluded).\n# .c indicates C source files, and others C++ ones.\nSRCEXTS = .c .C .cc .cpp .CPP .c++ .cxx .cp\n\n# The header file types.\nHDREXTS = .h .H .hh .hpp .HPP .h++ .hxx .hp\n\n# The pre-processor and compiler options.\n# Users can override those variables from the command line.\n# CFLAGS  = -g -O2\n# CXXFLAGS= -g -O2\n\n# The C program compiler.\n# CC     = gcc\n\n# The C++ program compiler.\n#CXX    = g++\n\n# Un-comment the following line to compile C programs as C++ ones.\n#CC     = $(CXX)\n\n# The command used to delete file.\n#RM     = rm -f\n\nETAGS = etags\nETAGSFLAGS =\n\nCTAGS = ctags\nCTAGSFLAGS =\n\n## Stable Section: usually no need to be changed. But you can add more.\n##==========================================================================\nSHELL   = /bin/sh\nEMPTY   =\nSPACE   = $(EMPTY) $(EMPTY)\nifeq ($(PROGRAM),)\n  CUR_PATH_NAMES = $(subst /,$(SPACE),$(subst $(SPACE),_,$(CURDIR)))\n  PROGRAM = $(word $(words $(CUR_PATH_NAMES)),$(CUR_PATH_NAMES))\n  ifeq ($(PROGRAM),)\n    PROGRAM = a.out\n  endif\nendif\nifeq ($(SRCDIRS),)\n  SRCDIRS = .\nendif\nSOURCES = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(SRCEXTS))))\nHEADERS = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(HDREXTS))))\nSRC_CXX = $(filter-out %.c,$(SOURCES))\nOBJS    = $(addsuffix .o, $(basename $(SOURCES)))\nDEPS    = $(OBJS:.o=.d)\n\n## Define some useful variables.\nDEP_OPT = $(shell if `$(CC) --version | grep &quot;GCC&quot; &gt;/dev/null`; then \\\n                  echo &quot;-MM -MP&quot;; else echo &quot;-M&quot;; fi )\nDEPEND      = $(CC)  $(DEP_OPT)  $(MY_CFLAGS) $(CFLAGS) $(CPPFLAGS)\nDEPEND.d    = $(subst -g ,,$(DEPEND))\nCOMPILE.c   = $(CC)  $(MY_CFLAGS) $(CFLAGS)   $(CPPFLAGS) -c\nCOMPILE.cxx = $(CXX) $(MY_CFLAGS) $(CXXFLAGS) $(CPPFLAGS) -c\nLINK.c      = $(CC)  $(MY_CFLAGS) $(CFLAGS)   $(CPPFLAGS) $(LDFLAGS)\nLINK.cxx    = $(CXX) $(MY_CFLAGS) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS)\n\n.PHONY: all objs tags ctags clean distclean help show\n\n# Delete the default suffixes\n.SUFFIXES:\n\nall: $(PROGRAM)\n\n# Rules for creating dependency files (.d).\n#------------------------------------------\n\n%.d:%.c\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.C\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cc\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cpp\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.CPP\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.c++\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cp\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cxx\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n# Rules for generating object files (.o).\n#----------------------------------------\nobjs:$(OBJS)\n\n%.o:%.c\n    $(COMPILE.c) $&lt; -o $@\n\n%.o:%.C\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cc\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cpp\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.CPP\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.c++\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cp\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cxx\n    $(COMPILE.cxx) $&lt; -o $@\n\n# Rules for generating the tags.\n#-------------------------------------\ntags: $(HEADERS) $(SOURCES)\n    $(ETAGS) $(ETAGSFLAGS) $(HEADERS) $(SOURCES)\n\nctags: $(HEADERS) $(SOURCES)\n    $(CTAGS) $(CTAGSFLAGS) $(HEADERS) $(SOURCES)\n\n# Rules for generating the executable.\n#-------------------------------------\n$(PROGRAM):$(OBJS)\nifeq ($(SRC_CXX),)              # C program\n    $(LINK.c)   $(OBJS) $(MY_LIBS) -o $@\n    @echo Type ./$@ to execute the program.\nelse                            # C++ program\n    $(LINK.cxx) $(OBJS) $(MY_LIBS) -o $@\n    @echo Type ./$@ to execute the program.\nendif\n\nifndef NODEP\nifneq ($(DEPS),)\n  sinclude $(DEPS)\nendif\nendif\n\nclean:\n    $(RM) $(OBJS) $(PROGRAM) $(PROGRAM).exe\n\ndistclean: clean\n    $(RM) $(DEPS) TAGS\n\n# Show help.\nhelp:\n    @echo &#39;Generic Makefile for C/C++ Programs (gcmakefile) version 0.5&#39;\n    @echo &#39;Copyright (C) 2007, 2008 whyglinux &lt;whyglinux@hotmail.com&gt;&#39;\n    @echo\n    @echo &#39;Usage: make [TARGET]&#39;\n    @echo &#39;TARGETS:&#39;\n    @echo &#39;  all       (=make) compile and link.&#39;\n    @echo &#39;  NODEP=yes make without generating dependencies.&#39;\n    @echo &#39;  objs      compile only (no linking).&#39;\n    @echo &#39;  tags      create tags for Emacs editor.&#39;\n    @echo &#39;  ctags     create ctags for VI editor.&#39;\n    @echo &#39;  clean     clean objects and the executable file.&#39;\n    @echo &#39;  distclean clean objects, the executable and dependencies.&#39;\n    @echo &#39;  show      show variables (for debug use only).&#39;\n    @echo &#39;  help      print this message.&#39;\n    @echo\n    @echo &#39;Report bugs to &lt;whyglinux AT gmail DOT com&gt;.&#39;\n\n# Show variables (for debug use only.)\nshow:\n    @echo &#39;PROGRAM     :&#39; $(PROGRAM)\n    @echo &#39;SRCDIRS     :&#39; $(SRCDIRS)\n    @echo &#39;HEADERS     :&#39; $(HEADERS)\n    @echo &#39;SOURCES     :&#39; $(SOURCES)\n    @echo &#39;SRC_CXX     :&#39; $(SRC_CXX)\n    @echo &#39;OBJS        :&#39; $(OBJS)\n    @echo &#39;DEPS        :&#39; $(DEPS)\n    @echo &#39;DEPEND      :&#39; $(DEPEND)\n    @echo &#39;COMPILE.c   :&#39; $(COMPILE.c)\n    @echo &#39;COMPILE.cxx :&#39; $(COMPILE.cxx)\n    @echo &#39;link.c      :&#39; $(LINK.c)\n    @echo &#39;link.cxx    :&#39; $(LINK.cxx)\n\n## End of the Makefile ##  Suggestions are welcome  ## All rights reserved ##\n##############################################################\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 感谢whyglinux大大！然后上Sublime的配置C C++ Multiple Files.sublime-build：</p>\n<pre><code class=\"hljs\">&#123;\n    &quot;shell_cmd&quot;: &quot;make&quot;,\n    &quot;file_regex&quot;: &quot;^(..[^:\\n]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,\n    &quot;working_dir&quot;: &quot;$&#123;folder:$&#123;project_path:$&#123;file_path&#125;&#125;&#125;&quot;,\n    &quot;selector&quot;: &quot;source.c, source.cpp&quot;,\n    &quot;syntax&quot;: &quot;Packages/Makefile/Make.build-language&quot;,\n    &quot;keyfiles&quot;: [&quot;Makefile&quot;, &quot;makefile&quot;],\n\n    &quot;variants&quot;:\n    [\n        &#123;\n            &quot;name&quot;: &quot;Clean&quot;,\n            &quot;shell_cmd&quot;: &quot;make clean&quot;\n        &#125;,\n        &#123;\n            &quot;name&quot;: &quot;Run&quot;,\n            &quot;shell_cmd&quot;: &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;\n        &#125;\n    ]\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 你们大可以配成执行时自动弹出终端，这样还能交互。我为了解决Sublime里中文输入法的问题用了gtk2，但是gnome-terminal用的是gtk3，不兼容了。写写控制台程序也不用那么多交互，懒得折腾了，你们随意。</p>\n",
            "tags": [
                "C",
                "sublime",
                "C++",
                "makefile"
            ]
        }
    ]
}