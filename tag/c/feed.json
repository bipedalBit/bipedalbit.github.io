{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hacking to the gate! • All posts by \"c\" tag",
    "description": "Bipedal Bit's blog",
    "home_page_url": "https://bipedalbit.net",
    "items": [
        {
            "id": "https://bipedalbit.net/2015/08/18/%E3%80%90%E4%BA%94%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "https://bipedalbit.net/2015/08/18/%E3%80%90%E4%BA%94%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "【五】nginx的数据结构(3)——扩展红黑树",
            "date_published": "2015-08-17T18:04:43.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 基础版的红黑树写完之后总觉得有些辅助功能不补充一下就难以体现红黑树在统计方面的优越性，于是我又写了红黑树扩展版。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 发扬我一贯的支线任务狂魔的作风，一晚上就完成了之前设想的红黑树扩展版本。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.2\n */\n\n#ifndef _RBTREE_H_INCLUDED_\n#define _RBTREE_H_INCLUDED_\n\n/* the node structure of the red-black tree */\ntypedef struct rbtree_node_s rbtree_node_t;\n/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */\ntypedef int rbtree_key_t;\n/* Abstract type is complicated to achieve with C so I use char* instead. */\ntypedef char* rbtree_data_t;\n\nstruct rbtree_node_s\n&#123;\n    /* key of the node */\n    rbtree_key_t    key;\n    /* pointer of the parent of the node */\n    rbtree_node_t*  parent;\n    /* pointer of the left kid of the node */\n    rbtree_node_t*  left;\n    /* pointer of the right kid of the node */\n    rbtree_node_t*  right;\n    /* color of the node */\n    unsigned char   color;\n    /* pointer of the value of the node corresponding to the key */\n    rbtree_data_t   value;\n    /* count of nodes in the subtree whose root is the current node */\n    int node_cnt;\n&#125;;\n\n/* the tree object stucture of the red-black tree */\ntypedef struct rbtree_s rbtree_t;\n/* foundational insert function pointer */\ntypedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);\n/* foundational visit function pointer */\ntypedef void (*rbtree_visit_p) (rbtree_node_t* node);\n\nstruct rbtree_s\n&#123;\n    /* the pointer of the root node of the tree */\n    rbtree_node_t* root;\n    /* black leaf nodes as sentinel */\n    rbtree_node_t* sentinel;\n    /* the polymorphic insert function pointer */\n    rbtree_insert_p insert;\n&#125;;\n\n/* macros */\n#define rbtree_init(tree, s, i)     \\\nrbtree_sentinel_init(s);            \\\n(tree)-&gt;root = s;               \\\n(tree)-&gt;sentinel = s;           \\\n(tree)-&gt;insert = i\n\n#define rbtree_red(node)    ((node)-&gt;color = 1)\n#define rbtree_black(node)  ((node)-&gt;color = 0)\n#define rbtree_is_red(node) ((node)-&gt;color)\n#define rbtree_is_black(node)   (!rbtree_is_red(node))\n /* copy n2&#39;s color to n1 */\n#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)\n/* sentinel must be black cuz it&#39;s leaf node */\n#define rbtree_sentinel_init(node)  \\\nrbtree_black(node);         \\\n(node)-&gt;node_cnt = 0\n\n/* statements of public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node);\n/* get node by key */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);\n/* get node by order number */\nrbtree_node_t* rbtree_index(rbtree_t* tree, int index);\nint rbtree_height(rbtree_t* tree, rbtree_node_t* node);\nint rbtree_count(rbtree_t* tree);\nvoid rbtree_visit(rbtree_node_t* node);\nvoid rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p);\n\n#endif  /* _RBTREE_H_INCLUDED_ */\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 可以看到，我增加了按序号查找结点、求树高、求结点数、可重写访问节点方法的遍历，这么几个功能。<br>&nbsp;&nbsp;&nbsp; 为了提高按序号查找结点的效率，我增加了一个结点项node_cnt，代表当前结点为根的子树上的结点总数。这样按序号查找结点的过程将是一个二分查找，时间效率与按key查找相同，都是O(log2n)。<br>&nbsp;&nbsp;&nbsp; 遍历方法使用递归的中序遍历，默认的结点访问方法是个空方法，用户可以自行重写。<br>&nbsp;&nbsp;&nbsp; rbtree.c：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.2\n */\n\n#include &lt;stddef.h&gt;\n#include &quot;rbtree.h&quot;\n\n/* inline methods */\n/* get the node with the minimum key in a subtree of the red-black tree */\nstatic inline rbtree_node_t*\nrbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)\n&#123;\n    while(node-&gt;left != sentinel)\n    &#123;\n        node = node-&gt;left;\n    &#125;\n\n    return node;\n&#125;\n\n/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */\nstatic inline void rbtree_replace(rbtree_t* tree,\n    rbtree_node_t* node, rbtree_node_t* tmp)\n&#123;\n    /* upward: p[node] &lt;- p[tmp] */\n    tmp-&gt;parent = node-&gt;parent;\n\n    if (node == tree-&gt;root)\n    &#123;\n        tree-&gt;root = tmp;\n    &#125;\n    else if (node == node-&gt;parent-&gt;left)\n    &#123;\n        /* downward: left[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;left = tmp;\n    &#125;\n    else\n    &#123;\n        /* downward: right[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;right = tmp;\n    &#125;\n\n    node-&gt;parent = tmp;\n&#125;\n\n/* change the topologic structure of the tree keeping the order of the nodes */\nstatic inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* node as the var x in CLRS while tmp as the var y */\n    rbtree_node_t* tmp = node-&gt;right;\n\n    /* fix node_cnt */\n    node-&gt;node_cnt = node-&gt;left-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;\n    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;\n\n    /* replace y with left[y] */\n    /* downward: right[x] &lt;- left[y] */\n    node-&gt;right = tmp-&gt;left;\n    /* if left[[y] is not NIL it has a parent */\n    if (tmp-&gt;left != tree-&gt;sentinel)\n    &#123;\n        /* upward: p[left[y]] &lt;- x */\n        tmp-&gt;left-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;left = node;\n&#125;\n\nstatic inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* tmp = node-&gt;left;\n\n    /* fix node_cnt */\n    node-&gt;node_cnt = node-&gt;right-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;\n    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;\n\n    /* replace y with right[y] */\n    node-&gt;left = tmp-&gt;right;\n    if (tmp-&gt;right != tree-&gt;sentinel)\n    &#123;\n        tmp-&gt;right-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;right = node;\n&#125;\n\n/* static methods */\n/* fix the red-black tree after the new node inserted */\nstatic void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    while(rbtree_is_red(node-&gt;parent))\n    &#123;\n        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)\n        &#123;\n            /* case 1: node&#39;s uncle is red */\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n                /* Then we can consider the whole subtree */\n                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */\n                /* and keep looping till &quot;node&quot; become the root. */\n            &#125;\n            /* case 2: node&#39;s uncle is black */\n            else\n            &#123;\n                /* ensure node is the left kid of its parent */\n                if (node == node-&gt;parent-&gt;right)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_left_rotate(tree, node);\n                &#125;\n                /* case 2 -&gt; case 1 */\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (node == node-&gt;parent-&gt;left)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_right_rotate(tree, node);\n                &#125;\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n    &#125;\n    /* ensure the root node being black */\n    rbtree_black(tree-&gt;root);\n&#125;\n\nstatic void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* brother = NULL;\n\n    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))\n    &#123;\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            brother = node-&gt;parent-&gt;right;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* update brother after topologic change of the tree */\n                brother = node-&gt;parent-&gt;right;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                /* go upward and keep on fixing color */\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;right))\n                &#123;\n                    rbtree_black(brother-&gt;left);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    /* update brother after topologic change of the tree */\n                    brother = node-&gt;parent-&gt;right;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;right);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* end the loop and ensure root is black */\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            brother = node-&gt;parent-&gt;left;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                brother = node-&gt;parent-&gt;left;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;left))\n                &#123;\n                    rbtree_black(brother-&gt;right);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    brother = node-&gt;parent-&gt;left;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;left);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n    &#125;\n\n    rbtree_black(node);\n&#125;\n\n/* public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* Using ** to know wether the new node will be a left kid */\n    /* or a right kid of its parent node. */\n    rbtree_node_t** tmp = &amp;tree-&gt;root;\n    rbtree_node_t* parent;\n\n    while(*tmp != tree-&gt;sentinel)\n    &#123;\n        parent = *tmp;\n\n        /* update node_cnt */\n        (parent-&gt;node_cnt)++;\n\n        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;\n    &#125;\n\n    /* The pointer knows wether the node should be on the left side */\n    /* or on the right one. */\n    *tmp = node;\n    node-&gt;parent = parent;\n    node-&gt;left = tree-&gt;sentinel;\n    node-&gt;right = tree-&gt;sentinel;\n    rbtree_red(node);\n&#125;\n\nvoid rbtree_visit(rbtree_node_t* node)\n&#123;\n    /* visiting the current node */\n&#125;\n\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n\n    /* if the tree is empty */\n    if (tree-&gt;root == sentinel)\n    &#123;\n        tree-&gt;root = node;\n        node-&gt;parent = sentinel;\n        node-&gt;left = sentinel;\n        node-&gt;right = sentinel;\n        rbtree_black(node);\n\n        return;\n    &#125;\n\n    /* generally */\n    tree-&gt;insert(tree, node);\n    rbtree_insert_fixup(tree, node);\n&#125;\n\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n    /* wether &quot;node&quot; is on the left side or the right one */\n    rbtree_node_t** ptr_to_node = NULL;\n    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */\n    rbtree_node_t* cover = NULL;\n    /* wether we lossing a red node on the edge of the tree */\n    int loss_red = rbtree_is_red(node);\n    int is_root = (node == tree-&gt;root);\n\n    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */\n    /* sentinel in &quot;node&quot;&#39;s kids */\n    if (node-&gt;left == sentinel)\n    &#123;\n        cover = node-&gt;right;\n    &#125;\n    else if (node-&gt;right == sentinel)\n    &#123;\n        cover = node-&gt;left;\n    &#125;\n    /* &quot;node&quot;&#39;s kids are both non-sentinel */\n    else\n    &#123;\n        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */\n        cover = rbtree_subtree_min(node-&gt;right, sentinel);\n        node-&gt;key = cover-&gt;key;\n        node-&gt;value = cover-&gt;value;\n        node = cover;\n        loss_red = rbtree_is_red(node);\n        is_root = 0;\n        /* move &quot;cover&quot;&#39;s kids */\n        /* &quot;cover&quot; can only be a left kid */\n        /* and can only have a right non-sentinel kid */\n        /* because of function &quot;rbtree_subtree_min&quot; */\n        cover = node-&gt;right;\n    &#125;\n\n    if (is_root)\n    &#123;\n        /* update root */\n        tree-&gt;root = cover;\n    &#125;\n    else\n    &#123;\n        /* downward link */\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            node-&gt;parent-&gt;left = cover;\n        &#125;\n        else\n        &#123;\n            node-&gt;parent-&gt;right = cover;\n        &#125;\n    &#125;\n    /* upward link */\n    cover-&gt;parent = node-&gt;parent;\n    /* &quot;cover&quot; may be a sentinel */\n    if (cover != sentinel)\n    &#123;\n        /* set &quot;cover&quot; */\n        cover-&gt;left = node-&gt;left;\n        cover-&gt;right = node-&gt;right;\n        rbtree_copy_color(cover, node);\n    &#125;\n\n    /* clear &quot;node&quot; since it&#39;s useless */\n    node-&gt;key = -1;\n    node-&gt;parent = NULL;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    node-&gt;value = NULL;\n\n    /* update node_cnt */\n    rbtree_node_t* tmp = cover-&gt;parent;\n    while(tmp != sentinel)\n    &#123;\n        (tmp-&gt;node_cnt)--;\n        tmp = tmp-&gt;parent;\n    &#125;\n\n    if (loss_red)\n    &#123;\n        return;\n    &#125;\n\n    /* When lossing a black node on edge */\n    /* the fifth rule of red-black tree will be broke. */\n    /* So the tree need to be fixed. */\n    rbtree_delete_fixup(tree, cover);\n&#125;\n\n/* find the node in the tree corresponding to the given key value */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)\n&#123;\n    rbtree_node_t* tmp = tree-&gt;root;\n    /* next line is just fot test */\n    // int step_cnt = 0;\n\n    /* search the binary tree */\n    while(tmp != tree-&gt;sentinel)\n    &#123;\n        /* next line is just fot test */\n        // step_cnt++;\n        if(key == tmp-&gt;key)\n        &#123;\n            /* next line is just for test */\n            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);\n            return tmp;\n        &#125;\n\n        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;\n    &#125;\n\n    return NULL;\n&#125;\n\n/* find the node in the tree corresponding to the given order number */\nrbtree_node_t* rbtree_index(rbtree_t* tree, int index)\n&#123;\n    if (index &lt; 0 || index &gt;= rbtree_count(tree))\n    &#123;\n        return NULL;\n    &#125;\n\n    rbtree_node_t* tmp = tree-&gt;root;\n    int left_cnt = 0;\n    int sub_left_cnt;\n\n    while(tmp-&gt;node_cnt &gt; 0)\n    &#123;\n        sub_left_cnt = tmp-&gt;left-&gt;node_cnt;\n        if (left_cnt + sub_left_cnt == index)\n        &#123;\n            return tmp;\n        &#125;\n\n        if (left_cnt + sub_left_cnt &lt; index)\n        &#123;\n            left_cnt += sub_left_cnt + 1;\n            tmp = tmp-&gt;right;\n        &#125;\n        else\n        &#123;\n            tmp = tmp-&gt;left;\n        &#125;\n    &#125;\n&#125;\n\n/* get the height of the subtree */\nint rbtree_height(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    if (node == tree-&gt;sentinel)\n    &#123;\n        return 0;\n    &#125;\n\n    int left_height = rbtree_height(tree, node-&gt;left);\n    int right_height = rbtree_height(tree, node-&gt;right);\n    int sub_height = (left_height &gt; right_height) ? left_height : right_height;\n    return sub_height+1;\n&#125;\n\n/* get the count of nodes in the tree */\nint rbtree_count(rbtree_t* tree)\n&#123;\n    return tree-&gt;root-&gt;node_cnt;\n&#125;\n\n/* visit every node of the subtree whose root is given in order */\nvoid rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p visit)\n&#123;\n    if (node != tree-&gt;sentinel)\n    &#123;\n        rbtree_traversal(tree, node-&gt;left, visit);\n        visit(node);\n        rbtree_traversal(tree, node-&gt;right, visit);\n    &#125;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 还是做个压力测试。<br>&nbsp;&nbsp;&nbsp; test.c：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    double duration;\n    double room;\n\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 1&lt;&lt;20;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */\n    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */\n    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));\n    int i;\n\n    long time1 = clock();\n\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i%10];\n        n[i].node_cnt = 1;\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    srand( (unsigned int)time(0) );\n    int no = rand()%cnt;\n    printf(&quot;n[%d]-&gt;key = %d\\n&quot;, no, rbtree_index(&amp;t, no)-&gt;key);\n\n    long time2 = clock();\n    room = 48.0*cnt/(1&lt;&lt;20);\n    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;\n    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\\n&quot;, cnt, room, duration);\n\n    const int search_cnt = 1&lt;&lt;10;\n    for( i = 0 ; i &lt; search_cnt ; i++ )\n    &#123;\n        rbtree_find(&amp;t, (rand()%cnt)+1);\n    &#125;\n\n    long time3 = clock();\n    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;\n    printf(&quot;Searching %d nodes among %d spends %f seconds.\\n&quot;, search_cnt, cnt, duration);\n\n    const int index_cnt = 1&lt;&lt;10;\n    for( i = 0 ; i &lt; index_cnt ; i++ )\n    &#123;\n        rbtree_index(&amp;t, (rand()%cnt));\n    &#125;\n\n    long time4 = clock();\n    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;\n    printf(&quot;Indexing %d nodes among %d spends %f seconds.\\n&quot;, index_cnt, cnt, duration);\n\n    const int delete_cnt = 1&lt;&lt;10;\n    int nums[delete_cnt];\n    int num;\n    /* Let&#39;s hash! */\n    char* mark = (char*)calloc(cnt, sizeof(char));\n    memset(mark, 0, cnt*sizeof(char));\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        for(;;)\n        &#123;\n            num = rand()%cnt;\n            if (mark[num] == 0)\n            &#123;\n                mark[num] = 1;\n                nums[i] = num;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    long time5 = clock();\n    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;\n    printf(&quot;Hash %d times spends %f seconds.\\n&quot;, delete_cnt, duration);\n\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        rbtree_delete(&amp;t, &amp;n[nums[i]]);\n    &#125;\n\n    long time6 = clock();\n    duration = (double)(time6 - time5) / CLOCKS_PER_SEC;\n    printf(&quot;Deleting %d nodes among %d spends %f seconds.\\n&quot;, delete_cnt, cnt, duration);\n    free(mark);\n\n    int h = rbtree_height(&amp;t, t.root);\n    long time7 = clock();\n    duration = (double)(time7 - time6) / CLOCKS_PER_SEC;\n    printf(&quot;The height of the tree is %d. Getting it spends %f seconds.\\n&quot;, h, duration);\n\n    rbtree_traversal(&amp;t, t.root, rbtree_visit);\n    long time8 = clock();\n    duration = (double)(time8 - time7) / CLOCKS_PER_SEC;\n    printf(&quot;Traversal the tree spends %f seconds.\\n&quot;, duration);\n\n    printf(&quot;Count of nodes in the tree is %d.\\n&quot;, rbtree_count(&amp;t));\n\n    free(n);\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 上一个版本的压力测试结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.\nSearching 1024 nodes among 1048576 spends 0.001140 seconds.\nHash 1024 times spends 0.000334 seconds.\nDeleting 1024 nodes among 1048576 spends 0.000783 seconds.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 扩展版本的压力测试结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.467859 seconds.\nSearching 1024 nodes among 1048576 spends 0.001188 seconds.\nIndexing 1024 nodes among 1048576 spends 0.001484 seconds.\nHash 1024 times spends 0.000355 seconds.\nDeleting 1024 nodes among 1048576 spends 0.001417 seconds.\nThe height of the tree is 28. Getting it spends 0.021669 seconds.\nTraversal the tree spends 0.023913 seconds.\nCount of nodes in the tree is 1047552.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 比较一下可以发现：<br>&nbsp;&nbsp;&nbsp; 1.插入结点略慢了一点，因为插入时多维护了一个node_cnt项。<br>&nbsp;&nbsp;&nbsp; 2.按key查找结点速度没有变化。<br>&nbsp;&nbsp;&nbsp; 3.哈希查找速度没有变化。<br>&nbsp;&nbsp;&nbsp; 4.删除结点花的时间几乎是原来的两倍，因为每次删除后都要一路向上更新node_cnt，几乎相当于包含了一次按key查询。<br>&nbsp;&nbsp;&nbsp; 5.按序号查询比按key查询略慢，因为每次进入右子树需要多做一次加法。<br>&nbsp;&nbsp;&nbsp; 6.遍历花的时间与求树高相同，因为它们的实质都是遍历树，时间效率O(n)数量级，具体点为2n次结点访问，分别为结点入栈和出栈时。<br>&nbsp;&nbsp;&nbsp; 别问我max、min、mid在哪，能按序号查询了这些还是问题吗？</p>\n",
            "tags": [
                "nginx",
                "rbtree",
                "C"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/",
            "url": "https://bipedalbit.net/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/",
            "title": "Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置",
            "date_published": "2015-08-16T14:45:46.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 不自己动手为Sublime配个C&#x2F;C++的通用Makefile脚本吗？不能自动编译链接多文件的编辑器不是好IDE。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 首先我们需要了解几个事实：</p>\n<p>&nbsp;&nbsp;&nbsp; 1.Sublime自带的C&#x2F;C++编译+执行配置使用的是g++编译器，此外这套配置只针对单文件程序。如果要编译多文件，只能采用入口函数所在文件包含需要的源文件而非头文件的方式。比起我们熟悉的几种IDE，这显然无法令人接受。</p>\n<p>&nbsp;&nbsp;&nbsp; 2.Linux下的C&#x2F;C++程序员应该熟悉Makefile，Makefile可以算是一种脚本，执行关键字是一般是make，它可以设计多文件程序的编译+链接过程，生成.o文件和可执行文件。</p>\n<p>&nbsp;&nbsp;&nbsp; 3.Sublime也有默认的Make配置，但是第一，Sublime没有提供通用的C&#x2F;C++的Makefile脚本（自动组织而非每次手动重写），第二点是个小瑕疵，Sublime提供的Make配置只有编译、链接、清理功能，执行程序需要手动。</p>\n<p>&nbsp;&nbsp;&nbsp; 之前重写红黑树最重要的副产品就是一个通用的C&#x2F;C++的Makefile脚本。每次使用基本只需要改改输出的可执行文件名，或者干脆想个默认文件名以后都不改了，gcc&#x2F;g++编译器的选择是自动的，当然也可以手动配置一些编译选项，这个自己看脚本注释就好。上干货：</p>\n<pre><code class=\"hljs\">#############################################################\n# Generic Makefile for C/C++ Program\n#\n# License: GPL (General Public License)\n# Author:  whyglinux &lt;whyglinux AT gmail DOT com&gt;\n# Date:    2006/03/04 (version 0.1)\n#          2007/03/24 (version 0.2)\n#          2007/04/09 (version 0.3)\n#          2007/06/26 (version 0.4)\n#          2008/04/05 (version 0.5)\n#\n# Description:\n# ------------\n# This is an easily customizable makefile template. The purpose is to\n# provide an instant building environment for C/C++ programs.\n#\n# It searches all the C/C++ source files in the specified directories,\n# makes dependencies, compiles and links to form an executable.\n#\n# Besides its default ability to build C/C++ programs which use only\n# standard C/C++ libraries, you can customize the Makefile to build\n# those using other libraries. Once done, without any changes you can\n# then build programs using the same or less libraries, even if source\n# files are renamed, added or removed. Therefore, it is particularly\n# convenient to use it to build codes for experimental or study use.\n#\n# GNU make is expected to use the Makefile. Other versions of makes\n# may or may not work.\n#\n# Usage:\n# ------\n# 1. Copy the Makefile to your program directory.\n# 2. Customize in the &quot;Customizable Section&quot; only if necessary:\n#    * to use non-standard C/C++ libraries, set pre-processor or compiler\n#      options to &lt;MY_CFLAGS&gt; and linker ones to &lt;MY_LIBS&gt;\n#      (See Makefile.gtk+-2.0 for an example)\n#    * to search sources in more directories, set to &lt;SRCDIRS&gt;\n#    * to specify your favorite program name, set to &lt;PROGRAM&gt;\n# 3. Type make to start building your program.\n#\n# Make Target:\n# ------------\n# The Makefile provides the following targets to make:\n#   $ make           compile and link\n#   $ make NODEP=yes compile and link without generating dependencies\n#   $ make objs      compile only (no linking)\n#   $ make tags      create tags for Emacs editor\n#   $ make ctags     create ctags for VI editor\n#   $ make clean     clean objects and the executable file\n#   $ make distclean clean objects, the executable and dependencies\n#   $ make help      get the usage of the makefile\n#\n#===========================================================================\n\n## Customizable Section: adapt those variables to suit your program.\n##==========================================================================\n\n# The pre-processor and compiler options.\nMY_CFLAGS =\n\n# The linker options.\nMY_LIBS   =\n\n# The pre-processor options used by the cpp (man cpp for more).\n# CPPFLAGS  = -Wall\n\n# The options used in linking as well as in any direct use of ld.\nLDFLAGS   =\n\n# The directories in which source files reside.\n# If not specified, only the current directory will be serached.\nSRCDIRS   =\n\n# The executable file name.\n# If not specified, current directory name or `a.out&#39; will be used.\nPROGRAM   = test\n\n## Implicit Section: change the following only when necessary.\n##==========================================================================\n\n# The source file types (headers excluded).\n# .c indicates C source files, and others C++ ones.\nSRCEXTS = .c .C .cc .cpp .CPP .c++ .cxx .cp\n\n# The header file types.\nHDREXTS = .h .H .hh .hpp .HPP .h++ .hxx .hp\n\n# The pre-processor and compiler options.\n# Users can override those variables from the command line.\n# CFLAGS  = -g -O2\n# CXXFLAGS= -g -O2\n\n# The C program compiler.\n# CC     = gcc\n\n# The C++ program compiler.\n#CXX    = g++\n\n# Un-comment the following line to compile C programs as C++ ones.\n#CC     = $(CXX)\n\n# The command used to delete file.\n#RM     = rm -f\n\nETAGS = etags\nETAGSFLAGS =\n\nCTAGS = ctags\nCTAGSFLAGS =\n\n## Stable Section: usually no need to be changed. But you can add more.\n##==========================================================================\nSHELL   = /bin/sh\nEMPTY   =\nSPACE   = $(EMPTY) $(EMPTY)\nifeq ($(PROGRAM),)\n  CUR_PATH_NAMES = $(subst /,$(SPACE),$(subst $(SPACE),_,$(CURDIR)))\n  PROGRAM = $(word $(words $(CUR_PATH_NAMES)),$(CUR_PATH_NAMES))\n  ifeq ($(PROGRAM),)\n    PROGRAM = a.out\n  endif\nendif\nifeq ($(SRCDIRS),)\n  SRCDIRS = .\nendif\nSOURCES = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(SRCEXTS))))\nHEADERS = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(HDREXTS))))\nSRC_CXX = $(filter-out %.c,$(SOURCES))\nOBJS    = $(addsuffix .o, $(basename $(SOURCES)))\nDEPS    = $(OBJS:.o=.d)\n\n## Define some useful variables.\nDEP_OPT = $(shell if `$(CC) --version | grep &quot;GCC&quot; &gt;/dev/null`; then \\\n                  echo &quot;-MM -MP&quot;; else echo &quot;-M&quot;; fi )\nDEPEND      = $(CC)  $(DEP_OPT)  $(MY_CFLAGS) $(CFLAGS) $(CPPFLAGS)\nDEPEND.d    = $(subst -g ,,$(DEPEND))\nCOMPILE.c   = $(CC)  $(MY_CFLAGS) $(CFLAGS)   $(CPPFLAGS) -c\nCOMPILE.cxx = $(CXX) $(MY_CFLAGS) $(CXXFLAGS) $(CPPFLAGS) -c\nLINK.c      = $(CC)  $(MY_CFLAGS) $(CFLAGS)   $(CPPFLAGS) $(LDFLAGS)\nLINK.cxx    = $(CXX) $(MY_CFLAGS) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS)\n\n.PHONY: all objs tags ctags clean distclean help show\n\n# Delete the default suffixes\n.SUFFIXES:\n\nall: $(PROGRAM)\n\n# Rules for creating dependency files (.d).\n#------------------------------------------\n\n%.d:%.c\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.C\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cc\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cpp\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.CPP\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.c++\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cp\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n%.d:%.cxx\n    @echo -n $(dir $&lt;) &gt; $@\n    @$(DEPEND.d) $&lt; &gt;&gt; $@\n\n# Rules for generating object files (.o).\n#----------------------------------------\nobjs:$(OBJS)\n\n%.o:%.c\n    $(COMPILE.c) $&lt; -o $@\n\n%.o:%.C\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cc\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cpp\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.CPP\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.c++\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cp\n    $(COMPILE.cxx) $&lt; -o $@\n\n%.o:%.cxx\n    $(COMPILE.cxx) $&lt; -o $@\n\n# Rules for generating the tags.\n#-------------------------------------\ntags: $(HEADERS) $(SOURCES)\n    $(ETAGS) $(ETAGSFLAGS) $(HEADERS) $(SOURCES)\n\nctags: $(HEADERS) $(SOURCES)\n    $(CTAGS) $(CTAGSFLAGS) $(HEADERS) $(SOURCES)\n\n# Rules for generating the executable.\n#-------------------------------------\n$(PROGRAM):$(OBJS)\nifeq ($(SRC_CXX),)              # C program\n    $(LINK.c)   $(OBJS) $(MY_LIBS) -o $@\n    @echo Type ./$@ to execute the program.\nelse                            # C++ program\n    $(LINK.cxx) $(OBJS) $(MY_LIBS) -o $@\n    @echo Type ./$@ to execute the program.\nendif\n\nifndef NODEP\nifneq ($(DEPS),)\n  sinclude $(DEPS)\nendif\nendif\n\nclean:\n    $(RM) $(OBJS) $(PROGRAM) $(PROGRAM).exe\n\ndistclean: clean\n    $(RM) $(DEPS) TAGS\n\n# Show help.\nhelp:\n    @echo &#39;Generic Makefile for C/C++ Programs (gcmakefile) version 0.5&#39;\n    @echo &#39;Copyright (C) 2007, 2008 whyglinux &lt;whyglinux@hotmail.com&gt;&#39;\n    @echo\n    @echo &#39;Usage: make [TARGET]&#39;\n    @echo &#39;TARGETS:&#39;\n    @echo &#39;  all       (=make) compile and link.&#39;\n    @echo &#39;  NODEP=yes make without generating dependencies.&#39;\n    @echo &#39;  objs      compile only (no linking).&#39;\n    @echo &#39;  tags      create tags for Emacs editor.&#39;\n    @echo &#39;  ctags     create ctags for VI editor.&#39;\n    @echo &#39;  clean     clean objects and the executable file.&#39;\n    @echo &#39;  distclean clean objects, the executable and dependencies.&#39;\n    @echo &#39;  show      show variables (for debug use only).&#39;\n    @echo &#39;  help      print this message.&#39;\n    @echo\n    @echo &#39;Report bugs to &lt;whyglinux AT gmail DOT com&gt;.&#39;\n\n# Show variables (for debug use only.)\nshow:\n    @echo &#39;PROGRAM     :&#39; $(PROGRAM)\n    @echo &#39;SRCDIRS     :&#39; $(SRCDIRS)\n    @echo &#39;HEADERS     :&#39; $(HEADERS)\n    @echo &#39;SOURCES     :&#39; $(SOURCES)\n    @echo &#39;SRC_CXX     :&#39; $(SRC_CXX)\n    @echo &#39;OBJS        :&#39; $(OBJS)\n    @echo &#39;DEPS        :&#39; $(DEPS)\n    @echo &#39;DEPEND      :&#39; $(DEPEND)\n    @echo &#39;COMPILE.c   :&#39; $(COMPILE.c)\n    @echo &#39;COMPILE.cxx :&#39; $(COMPILE.cxx)\n    @echo &#39;link.c      :&#39; $(LINK.c)\n    @echo &#39;link.cxx    :&#39; $(LINK.cxx)\n\n## End of the Makefile ##  Suggestions are welcome  ## All rights reserved ##\n##############################################################\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 感谢whyglinux大大！然后上Sublime的配置C C++ Multiple Files.sublime-build：</p>\n<pre><code class=\"hljs\">&#123;\n    &quot;shell_cmd&quot;: &quot;make&quot;,\n    &quot;file_regex&quot;: &quot;^(..[^:\\n]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,\n    &quot;working_dir&quot;: &quot;$&#123;folder:$&#123;project_path:$&#123;file_path&#125;&#125;&#125;&quot;,\n    &quot;selector&quot;: &quot;source.c, source.cpp&quot;,\n    &quot;syntax&quot;: &quot;Packages/Makefile/Make.build-language&quot;,\n    &quot;keyfiles&quot;: [&quot;Makefile&quot;, &quot;makefile&quot;],\n\n    &quot;variants&quot;:\n    [\n        &#123;\n            &quot;name&quot;: &quot;Clean&quot;,\n            &quot;shell_cmd&quot;: &quot;make clean&quot;\n        &#125;,\n        &#123;\n            &quot;name&quot;: &quot;Run&quot;,\n            &quot;shell_cmd&quot;: &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;\n        &#125;\n    ]\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 你们大可以配成执行时自动弹出终端，这样还能交互。我为了解决Sublime里中文输入法的问题用了gtk2，但是gnome-terminal用的是gtk3，不兼容了。写写控制台程序也不用那么多交互，懒得折腾了，你们随意。</p>\n",
            "tags": [
                "C",
                "sublime",
                "C++",
                "makefile"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/08/16/%E3%80%90%E5%9B%9B%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "https://bipedalbit.net/2015/08/16/%E3%80%90%E5%9B%9B%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "【四】nginx的数据结构(2)——自己动手重写红黑树",
            "date_published": "2015-08-16T14:06:30.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 不管看了多少遍有多滚瓜烂熟，数据结构或者算法的代码如果不亲自码一遍，我总是不敢说自己懂了。这次就来自己动手重写红黑树。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 费话不多说，上重写代码，这次姑且用英语写的注释当复习英语了。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#ifndef _RBTREE_H_INCLUDED_\n#define _RBTREE_H_INCLUDED_\n\n/* the node structure of the red-black tree */\ntypedef struct rbtree_node_s rbtree_node_t;\n/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */\ntypedef int rbtree_key_t;\n/* Abstract type is complicated to achieve with C so I use char* instead. */\ntypedef char* rbtree_data_t;\n\nstruct rbtree_node_s\n&#123;\n    /* key of the node */\n    rbtree_key_t    key;\n    /* pointer of the parent of the node */\n    rbtree_node_t*  parent;\n    /* pointer of the left kid of the node */\n    rbtree_node_t*  left;\n    /* pointer of the right kid of the node */\n    rbtree_node_t*  right;\n    /* color of the node */\n    unsigned char   color;\n    /* pointer of the value of the node corresponding to the key */\n    rbtree_data_t   value;\n&#125;;\n\n/* the tree object stucture of the red-black tree */\ntypedef struct rbtree_s rbtree_t;\n/* foundational insert function pointer*/\ntypedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);\n\nstruct rbtree_s\n&#123;\n    /* the pointer of the root node of the tree */\n    rbtree_node_t* root;\n    /* black leaf nodes as sentinel */\n    rbtree_node_t* sentinel;\n    /* the polymorphic insert function pointer */\n    rbtree_insert_p insert;\n&#125;;\n\n/* macros */\n#define rbtree_init(tree, s, i)     \\\nrbtree_sentinel_init(s);            \\\n(tree)-&gt;root = s;               \\\n(tree)-&gt;sentinel = s;           \\\n(tree)-&gt;insert = i\n\n#define rbtree_red(node)    ((node)-&gt;color = 1)\n#define rbtree_black(node)  ((node)-&gt;color = 0)\n#define rbtree_is_red(node) ((node)-&gt;color)\n#define rbtree_is_black(node)   (!rbtree_is_red(node))\n /* copy n2&#39;s color to n1 */\n#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)\n/* sentinel must be black cuz it&#39;s leaf node */\n#define rbtree_sentinel_init(node)  rbtree_black(node)\n\n/* statements of public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node);\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node);\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);\n\n#endif  /* _RBTREE_H_INCLUDED_ */\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 看过nginx源码的有心人会发现，我的头文件相对于ngx_rbree.h改动不大，非常像。<br>&nbsp;&nbsp;&nbsp; 关键的rbtree.c：</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#include &lt;stddef.h&gt;\n#include &quot;rbtree.h&quot;\n\n/* inline methods */\n/* get the node with the minimum key in a subtree of the red-black tree */\nstatic inline rbtree_node_t*\nrbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)\n&#123;\n    while(node-&gt;left != sentinel)\n    &#123;\n        node = node-&gt;left;\n    &#125;\n\n    return node;\n&#125;\n\n/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */\nstatic inline void rbtree_replace(rbtree_t* tree,\n    rbtree_node_t* node, rbtree_node_t* tmp)\n&#123;\n    /* upward: p[node] &lt;- p[tmp] */\n    tmp-&gt;parent = node-&gt;parent;\n\n    if (node == tree-&gt;root)\n    &#123;\n        tree-&gt;root = tmp;\n    &#125;\n    else if (node == node-&gt;parent-&gt;left)\n    &#123;\n        /* downward: left[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;left = tmp;\n    &#125;\n    else\n    &#123;\n        /* downward: right[p[node]] &lt;- tmp */\n        node-&gt;parent-&gt;right = tmp;\n    &#125;\n\n    node-&gt;parent = tmp;\n&#125;\n\n/* change the topologic structure of the tree keeping the order of the nodes */\nstatic inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* node as the var x in CLRS while tmp as the var y */\n    rbtree_node_t* tmp = node-&gt;right;\n\n    /* replace y with left[y] */\n    /* downward: right[x] &lt;- left[y] */\n    node-&gt;right = tmp-&gt;left;\n    /* if left[[y] is not NIL it has a parent */\n    if (tmp-&gt;left != tree-&gt;sentinel)\n    &#123;\n        /* upward: p[left[y]] &lt;- x */\n        tmp-&gt;left-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;left = node;\n&#125;\n\nstatic inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* tmp = node-&gt;left;\n\n    /* replace y with right[y] */\n    node-&gt;left = tmp-&gt;right;\n    if (tmp-&gt;right != tree-&gt;sentinel)\n    &#123;\n        tmp-&gt;right-&gt;parent = node;\n    &#125;\n\n    /* replace x with y */\n    rbtree_replace(tree, node, tmp);\n    tmp-&gt;right = node;\n&#125;\n\n/* static methods */\n/* fix the red-black tree after the new node inserted */\nstatic void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    while(rbtree_is_red(node-&gt;parent))\n    &#123;\n        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)\n        &#123;\n            /* case 1: node&#39;s uncle is red */\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n                /* Then we can consider the whole subtree */\n                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */\n                /* and keep looping till &quot;node&quot; become the root. */\n            &#125;\n            /* case 2: node&#39;s uncle is black */\n            else\n            &#123;\n                /* ensure node is the left kid of its parent */\n                if (node == node-&gt;parent-&gt;right)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_left_rotate(tree, node);\n                &#125;\n                /* case 2 -&gt; case 1 */\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))\n            &#123;\n                rbtree_black(node-&gt;parent);\n                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                node = node-&gt;parent-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (node == node-&gt;parent-&gt;left)\n                &#123;\n                    node = node-&gt;parent;\n                    rbtree_right_rotate(tree, node);\n                &#125;\n                rbtree_black(node-&gt;parent);\n                rbtree_red(node-&gt;parent-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);\n            &#125;\n        &#125;\n    &#125;\n    /* ensure the root node being black */\n    rbtree_black(tree-&gt;root);\n&#125;\n\nstatic void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* brother = NULL;\n\n    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))\n    &#123;\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            brother = node-&gt;parent-&gt;right;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* update brother after topologic change of the tree */\n                brother = node-&gt;parent-&gt;right;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                /* go upward and keep on fixing color */\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;right))\n                &#123;\n                    rbtree_black(brother-&gt;left);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    /* update brother after topologic change of the tree */\n                    brother = node-&gt;parent-&gt;right;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;right);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                /* end the loop and ensure root is black */\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */\n        else\n        &#123;\n            brother = node-&gt;parent-&gt;left;\n            if (rbtree_is_red(brother))\n            &#123;\n                rbtree_black(brother);\n                rbtree_red(node-&gt;parent);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                brother = node-&gt;parent-&gt;left;\n            &#125;\n\n            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))\n            &#123;\n                rbtree_red(brother);\n                node = node-&gt;parent;\n            &#125;\n            else\n            &#123;\n                if (rbtree_is_black(brother-&gt;left))\n                &#123;\n                    rbtree_black(brother-&gt;right);\n                    rbtree_red(brother);\n                    rbtree_right_rotate(tree, brother);\n                    brother = node-&gt;parent-&gt;left;\n                &#125;\n                rbtree_copy_color(brother, node-&gt;parent);\n                rbtree_black(node-&gt;parent);\n                rbtree_black(brother-&gt;left);\n                rbtree_left_rotate(tree, node-&gt;parent);\n                node = tree-&gt;root;\n            &#125;\n        &#125;\n    &#125;\n\n    rbtree_black(node);\n&#125;\n\n/* public methods */\nvoid rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    /* Using ** to know wether the new node will be a left kid */\n    /* or a right kid of its parent node. */\n    rbtree_node_t** tmp = &amp;tree-&gt;root;\n    rbtree_node_t* parent;\n\n    while(*tmp != tree-&gt;sentinel)\n    &#123;\n        parent = *tmp;\n        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;\n    &#125;\n\n    /* The pointer knows wether the node should be on the left side */\n    /* or on the right one. */\n    *tmp = node;\n    node-&gt;parent = parent;\n    node-&gt;left = tree-&gt;sentinel;\n    node-&gt;right = tree-&gt;sentinel;\n    rbtree_red(node);\n&#125;\n\nvoid rbtree_insert(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n\n    /* if the tree is empty */\n    if (tree-&gt;root == sentinel)\n    &#123;\n        tree-&gt;root = node;\n        node-&gt;parent = sentinel;\n        node-&gt;left = sentinel;\n        node-&gt;right = sentinel;\n        rbtree_black(node);\n\n        return;\n    &#125;\n\n    /* generally */\n    tree-&gt;insert(tree, node);\n    rbtree_insert_fixup(tree, node);\n&#125;\n\nvoid rbtree_delete(rbtree_t* tree, rbtree_node_t* node)\n&#123;\n    rbtree_node_t* sentinel = tree-&gt;sentinel;\n    /* wether &quot;node&quot; is on the left side or the right one */\n    rbtree_node_t** ptr_to_node = NULL;\n    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */\n    rbtree_node_t* cover = NULL;\n    /* wether we lossing a red node on the edge of the tree */\n    int loss_red = rbtree_is_red(node);\n    int is_root = (node == tree-&gt;root);\n\n    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */\n    /* sentinel in &quot;node&quot;&#39;s kids */\n    if (node-&gt;left == sentinel)\n    &#123;\n        cover = node-&gt;right;\n    &#125;\n    else if (node-&gt;right == sentinel)\n    &#123;\n        cover = node-&gt;left;\n    &#125;\n    /* &quot;node&quot;&#39;s kids are both non-sentinel */\n    else\n    &#123;\n        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */\n        cover = rbtree_subtree_min(node-&gt;right, sentinel);\n        node-&gt;key = cover-&gt;key;\n        node-&gt;value = cover-&gt;value;\n        node = cover;\n        loss_red = rbtree_is_red(node);\n        is_root = 0;\n        /* move &quot;cover&quot;&#39;s kids */\n        /* &quot;cover&quot; can only be a left kid */\n        /* and can only have a right non-sentinel kid */\n        /* because of function &quot;rbtree_subtree_min&quot; */\n        cover = node-&gt;right;\n    &#125;\n\n    if (is_root)\n    &#123;\n        /* update root */\n        tree-&gt;root = cover;\n    &#125;\n    else\n    &#123;\n        /* downward link */\n        if (node == node-&gt;parent-&gt;left)\n        &#123;\n            node-&gt;parent-&gt;left = cover;\n        &#125;\n        else\n        &#123;\n            node-&gt;parent-&gt;right = cover;\n        &#125;\n    &#125;\n    /* upward link */\n    cover-&gt;parent = node-&gt;parent;\n    /* &quot;cover&quot; may be a sentinel */\n    if (cover != sentinel)\n    &#123;\n        /* set &quot;cover&quot; */\n        cover-&gt;left = node-&gt;left;\n        cover-&gt;right = node-&gt;right;\n        rbtree_copy_color(cover, node);\n    &#125;\n\n    /* clear &quot;node&quot; since it&#39;s useless */\n    node-&gt;key = -1;\n    node-&gt;parent = NULL;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    node-&gt;value = NULL;\n\n    if (loss_red)\n    &#123;\n        return;\n    &#125;\n\n    /* When lossing a black node on edge */\n    /* the fifth rule of red-black tree will be broke. */\n    /* So the tree need to be fixed. */\n    rbtree_delete_fixup(tree, cover);\n&#125;\n\n/* find the node in the tree corresponding to the given key value */\nrbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)\n&#123;\n    rbtree_node_t* tmp = tree-&gt;root;\n    int step_cnt = 0;\n\n    /* search the binary tree */\n    while(tmp != tree-&gt;sentinel)\n    &#123;\n        /* next line is just fot test */\n        // step_cnt++;\n        if(key == tmp-&gt;key)\n        &#123;\n            /* next line is just for test */\n            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);\n            return tmp;\n        &#125;\n\n        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;\n    &#125;\n\n    return NULL;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp;  虽然明白nginx源码中100+行的长函数体也是一种避免太多函数调用增加时间空间开销的优化，我还是把所有函数都分类分割成100行以下。增加可读性是一方面，可能也是有点强迫症吧。之后会扩展几个统计方法，像max、min和mid，还会扩展一个遍历方法。<br>&nbsp;&nbsp;&nbsp; 下面是调用测试，test.c：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 10;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    rbtree_node_t n[cnt];\n    int i;\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i];\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    rbtree_node_t* p[cnt];\n\n    for (i = 1; i &lt;= cnt; i++)\n    &#123;\n        printf(&quot;key: %d\\n&quot;, i);\n        p[i] = rbtree_find(&amp;t, i);\n        printf(&quot;value: %s\\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);\n    &#125;\n\n    rbtree_delete(&amp;t, &amp;n[5]);\n\n    printf(&quot;\\nafter delete 6-&gt;mango:\\n\\n&quot;);\n\n    for (i = 1; i &lt;= cnt; i++)\n    &#123;\n        printf(&quot;key: %d\\n&quot;, i);\n        p[i] = rbtree_find(&amp;t, i);\n        printf(&quot;value: %s\\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 解开rbtree_find方法里的测试行注释，顺利执行：</p>\n<pre><code class=\"hljs\">key: 1\nstep count: 3, color: black, value: apple\nkey: 2\nstep count: 2, color: black, value: banana\nkey: 3\nstep count: 3, color: black, value: cherry\nkey: 4\nstep count: 1, color: black, value: grape\nkey: 5\nstep count: 3, color: black, value: lemon\nkey: 6\nstep count: 2, color: black, value: mango\nkey: 7\nstep count: 4, color: black, value: pear\nkey: 8\nstep count: 3, color: red, value: pineapple\nkey: 9\nstep count: 4, color: black, value: strawberry\nkey: 10\nstep count: 5, color: red, value: watermelon\n\nafter delete 6-&gt;mango:\n\nkey: 1\nstep count: 3, color: black, value: apple\nkey: 2\nstep count: 2, color: black, value: banana\nkey: 3\nstep count: 3, color: black, value: cherry\nkey: 4\nstep count: 1, color: black, value: grape\nkey: 5\nstep count: 3, color: black, value: lemon\nkey: 6\nvalue: ?\nkey: 7\nstep count: 2, color: black, value: pear\nkey: 8\nstep count: 4, color: black, value: pineapple\nkey: 9\nstep count: 3, color: red, value: strawberry\nkey: 10\nstep count: 4, color: black, value: watermelon\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 下面分别是删除6-&gt;mango前的红黑树和删除后的红黑树示意图：<br><img src=\"http://img.blog.csdn.net/20150816200143108\" alt=\"\" height=\"422\" width=\"400\" /><br><img src=\"http://img.blog.csdn.net/20150816200200052\" alt=\"\" height=\"331\" width=\"400\" /><br>&nbsp;&nbsp;&nbsp; 下面我们来做个大量数据的压力测试，注意把rbtree_find方法里的测试行注释掉，不然后果恐怕会比较吓人：</p>\n<pre><code class=\"hljs\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &quot;rbtree.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    double duration;\n    double room;\n\n    rbtree_t t = &#123;&#125;;\n    rbtree_node_t s = &#123;&#125;;\n    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);\n\n    const int cnt = 1&lt;&lt;20;\n    const int max_len = 15;\n\n#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;\n\n    /* for gcc */\n    char* v[] = TEST_VALUES;\n    /* for g++ */\n    // char v[][max_len] = TEST_VALUES;\n\n    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */\n    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */\n    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));\n    int i;\n\n    long time1 = clock();\n\n    for (i = 0; i &lt; cnt; i++)\n    &#123;\n        n[i].key = i+1;\n        n[i].value = v[i%10];\n        rbtree_insert(&amp;t, &amp;n[i]);\n    &#125;\n\n    long time2 = clock();\n    room = 48.0*cnt/(1&lt;&lt;20);\n    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;\n    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\\n&quot;, cnt, room, duration);\n\n    const int search_cnt = 1&lt;&lt;10;\n    srand( (unsigned int)time(0) );\n    for( i = 0 ; i &lt; search_cnt ; i++ )\n    &#123;\n        rbtree_find(&amp;t, (rand()%cnt)+1);\n    &#125;\n\n    long time3 = clock();\n    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;\n    printf(&quot;Searching %d nodes among %d spends %f seconds.\\n&quot;, search_cnt, cnt, duration);\n\n    const int delete_cnt = 1&lt;&lt;10;\n    int nums[delete_cnt];\n    int num;\n    /* Let&#39;s hash! */\n    char* mark = (char*)calloc(cnt, sizeof(char));\n    memset(mark, 0, cnt*sizeof(char));\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        for(;;)\n        &#123;\n            num = rand()%cnt;\n            if (mark[num] == 0)\n            &#123;\n                mark[num] = 1;\n                nums[i] = num;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    long time4 = clock();\n    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;\n    printf(&quot;Hash %d times spends %f seconds.\\n&quot;, delete_cnt, duration);\n\n    for(i = 0; i &lt; delete_cnt; i++)\n    &#123;\n        rbtree_delete(&amp;t, &amp;n[nums[i]]);\n    &#125;\n\n    long time5 = clock();\n    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;\n    printf(&quot;Deleting %d nodes among %d spends %f seconds.\\n&quot;, delete_cnt, cnt, duration);\n    free(mark);\n    free(n);\n\n    return 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 来看看结果：</p>\n<pre><code class=\"hljs\">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.\nSearching 1024 nodes among 1048576 spends 0.001140 seconds.\nHash 1024 times spends 0.000334 seconds.\nDeleting 1024 nodes among 1048576 spends 0.000783 seconds.\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 删除比查找还快，耗时只有哈希查找的两倍多点，上百万的插入也耗时不足半秒，嗯我还挺满意的。<br>&nbsp;&nbsp;&nbsp; 写统计和遍历方法去了。</p>\n",
            "tags": [
                "nginx",
                "rbtree",
                "C"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/08/11/C%E8%AF%AD%E8%A8%80%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/",
            "url": "https://bipedalbit.net/2015/08/11/C%E8%AF%AD%E8%A8%80%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/",
            "title": "C语言的static关键字",
            "date_published": "2015-08-11T12:09:08.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; static这个关键字可谓熟悉又陌生，要比较系统地理解它，更好地使用它，需要对它有更加深入的了解。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; C程序一直由下列部分组成：<br>&nbsp;&nbsp;&nbsp; 1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令。<br>&nbsp;&nbsp;&nbsp; 2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。<br>&nbsp;&nbsp;&nbsp; 3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。<br>&nbsp;&nbsp;&nbsp; 4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址、环境信息）。<br>&nbsp;&nbsp;&nbsp; 5）堆——动态存储分配的内存。</p>\n<p><span style=\"color:#FF0000;\"><span style=\"color:#000000;\">1.</span>全局静态变量</span></p>\n<p>&nbsp;&nbsp;&nbsp; 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。<br>&nbsp;&nbsp;&nbsp; 1）内存中的位置：静态存储区。（静态存储区在整个程序运行期间都存在）<br>&nbsp;&nbsp;&nbsp; 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0。（自动对象的值是任意的，除非他被显示初始化）<br>&nbsp;&nbsp;&nbsp; 3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</p>\n<p>&nbsp;&nbsp;&nbsp; 定义全局静态变量的好处：<br>&nbsp;&nbsp;&nbsp; 1）不会被其他文件所访问，修改。<br>&nbsp;&nbsp;&nbsp; 2）其他文件中可以使用相同名字的变量，不会发生冲突。</p>\n<p><span style=\"color:#FF0000;\"><span style=\"color:#000000;\">2.</span>局部静态变量</span></p>\n<p>&nbsp;&nbsp;&nbsp; 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。<br>&nbsp;&nbsp;&nbsp; 1）内存中的位置：静态存储区。<br>&nbsp;&nbsp;&nbsp; 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0。（自动对象的值是任意的，除非他被显示初始化）<br>&nbsp;&nbsp;&nbsp; 3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>\n<p>&nbsp;&nbsp;&nbsp;<span style=\"color:#FF0000;\">注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</span><br>&nbsp;&nbsp;&nbsp; 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。</p>\n<p>3.<span style=\"color:#FF0000;\">静态函数</span><br>&nbsp;&nbsp;&nbsp; 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。<br>&nbsp;&nbsp;&nbsp; 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>\n<p>&nbsp;&nbsp;&nbsp; 定义静态函数的好处：<br>&nbsp;&nbsp;&nbsp; 1）其他文件中可以定义相同名字的函数，不会发生冲突<br>&nbsp;&nbsp;&nbsp; 2）静态函数不能被其他文件所用。存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出该程序块时撤销。</p>\n<p>&nbsp;&nbsp;&nbsp; 关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期（static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。</p>\n<p>&nbsp;&nbsp;&nbsp; 由于static变量的以上特性，可实现一些特定功能。</p>\n<p>&nbsp;&nbsp;&nbsp; 统计次数功能：<br>&nbsp;&nbsp;&nbsp; 声明函数的一个局部变量，并设为static类型，作为一个计数器，这样函数每次被调用的时候就可以进行计数。这是统计函数被调用次数的最好的办法，因为这个变量是和函数息息相关的，而函数可能在多个不同的地方被调用，所以从调用者的角度来统计比较困难。</p>\n<p><span style=\"color:#FF0000;\">&nbsp;&nbsp;&nbsp; 使用静态函数的好处：<br>&nbsp;&nbsp;&nbsp; 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。<br>&nbsp;&nbsp;&nbsp; 关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。</span></p>\n",
            "tags": [
                "C",
                "static",
                "内存分布"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/08/06/%E3%80%90%E4%B8%89%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E2%80%94%E2%80%94ngx-int-t%E4%B8%8Engx-rbtree-t/",
            "url": "https://bipedalbit.net/2015/08/06/%E3%80%90%E4%B8%89%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E2%80%94%E2%80%94ngx-int-t%E4%B8%8Engx-rbtree-t/",
            "title": "【三】nginx的数据结构(1)——ngx_int_t与ngx_rbtree_t",
            "date_published": "2015-08-05T23:18:00.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 就来挑两个特别的数据结构ngx_int_t、ngx_rbtree_t作为研读nginx源码的开始吧。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 面对<span style=\"font-family:Times New Roman;\">.&#x2F;src&#x2F;core</span><span style=\"font-family:宋体;\">子目录中</span><span style=\"font-family:Times New Roman;\">71</span><span style=\"font-family:宋体;\">个源文件，有点无从下手。浏览包含主函数的</span><span style=\"font-family:Times New Roman;\">nginx.c</span><span style=\"font-family:宋体;\">文件，发现</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">使用了很多自行封装的数据结构，不弄清楚这是些什么样的数据结构就很难理解主函数中操作的意义。于是我们挑看起来基础的数据结构开始研究。组织</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">所有数据结构的是</span><span style=\"font-family:Times New Roman;\">ngx_core.h</span><span style=\"font-family:宋体;\">文件。它首先包含了</span><span style=\"font-family:Times New Roman;\">ngx_config.h</span><span style=\"font-family:宋体;\">，我们在</span><span style=\"font-family:Times New Roman;\">ngx_config.h</span><span style=\"font-family:宋体;\">中发现了三个类型定义。</span></p>\n<h1 id=\"1-ngx-int-t、ngx-uint-t、ngx-flag-t\"><a href=\"#1-ngx-int-t、ngx-uint-t、ngx-flag-t\" class=\"headerlink\" title=\"1. ngx_int_t、ngx_uint_t、ngx_flag_t\"></a>1. ngx_int_t<span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">ngx_uint_t</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">ngx_flag_t</span></h1><p>&nbsp;&nbsp;&nbsp; nginx.c<span style=\"font-family:宋体;\">中看到的第一个陌生数据类型是</span><span style=\"font-family:Times New Roman;\">ngx_int_t</span><span style=\"font-family:宋体;\">，在</span><span style=\"font-family:Times New Roman;\">nginx_config.h</span><span style=\"font-family:宋体;\">中找到了它的定义。</span></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">intptr_t</span> <span class=\"hljs-type\">ngx_int_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">uintptr_t</span> <span class=\"hljs-type\">ngx_uint_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">intptr_t</span> <span class=\"hljs-type\">ngx_flag_t</span>;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 顺藤摸瓜找到了三个数据类型的定义。本科<span style=\"font-family:Times New Roman;\">c</span><span style=\"font-family:宋体;\">入门教学中并没有对</span><span style=\"font-family:Times New Roman;\">intptr_t&#x2F;uintptr_t</span><span style=\"font-family:宋体;\">的介绍，我在</span><span style=\"font-family:Times New Roman;\">c</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">stdint.h</span><span style=\"font-family:宋体;\">头文件中发现了它们的定义。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* Types for `void *&#x27; pointers.  */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> __WORDSIZE == 64</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> __intptr_t_defined</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>    <span class=\"hljs-type\">intptr_t</span>;<br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> __intptr_t_defined</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>   <span class=\"hljs-type\">uintptr_t</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> __intptr_t_defined</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">intptr_t</span>;<br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> __intptr_t_defined</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>    <span class=\"hljs-type\">uintptr_t</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 首先注释说这两种类型是<span style=\"font-family:Times New Roman;\">“void&nbsp;*”</span><span style=\"font-family:宋体;\">的指针类型，尽管字面上看，</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">确实是整型指针类型和无符号整型指针类型，但是让人摸不着头脑，为什么要使用整型作为整型的指针类型呢？先放一放，看后面的宏，机器是</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位字长则</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">long&nbsp;int</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;long&nbsp;int</span><span style=\"font-family:宋体;\">，正好我机器上是</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位编译器，</span><span style=\"font-family:Times New Roman;\">sizeof()</span><span style=\"font-family:宋体;\">了一下，是</span><span style=\"font-family:Times New Roman;\">8</span><span style=\"font-family:宋体;\">个字节</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位，小于</span><span style=\"font-family:Times New Roman;\">64</span><span style=\"font-family:宋体;\">位字长的</span><span style=\"font-family:Times New Roman;\">intptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">uintptr_t</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;int</span><span style=\"font-family:宋体;\">，查表得知</span><span style=\"font-family:Times New Roman;\">32</span><span style=\"font-family:宋体;\">位编译器下</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">unsigned</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">4</span><span style=\"font-family:宋体;\">个字节，</span><span style=\"font-family:Times New Roman;\">16</span><span style=\"font-family:宋体;\">位编译器下为</span><span style=\"font-family:Times New Roman;\">2</span><span style=\"font-family:宋体;\">个字节。那么</span><span style=\"font-family:Times New Roman;\">intptr_t&#x2F;uintptr_t</span><span style=\"font-family:宋体;\">应该是会随着平台字长变化而发生对应变化的整型类型。经过了解，发现《深入分析</span><span style=\"font-family:Times New Roman;\">Linux</span><span style=\"font-family:宋体;\">内核源码》中对此的解释是，系统内核在操作内存时，将内存当做一个大数组，而指针就是数组索引</span><span style=\"font-family:Times New Roman;\">&#x2F;</span><span style=\"font-family:宋体;\">下标，内核程序员使用这种特殊的整型来接受内存地址值、操作内存相比使用指针更加直观，不容易犯错。看起来，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">中，只是单纯的想要使用一些平台相关的</span><span style=\"font-family:Times New Roman;\">int</span><span style=\"font-family:宋体;\">、</span><span style=\"font-family:Times New Roman;\">unsigned&nbsp;int</span><span style=\"font-family:宋体;\">类型变量而已。</span></p>\n<h1 id=\"2-ngx-rbtree-t\"><a href=\"#2-ngx-rbtree-t\" class=\"headerlink\" title=\"2. ngx_rbtree_t\"></a>2. ngx_rbtree_t</h1><h2 id=\"2-1-什么是红黑树\"><a href=\"#2-1-什么是红黑树\" class=\"headerlink\" title=\"2.1 什么是红黑树\"></a>2.1 <span style=\"font-family:宋体;\">什么是红黑树</span></h2><p>&nbsp;&nbsp;&nbsp; 作为一个曾经常年在<span style=\"font-family:Times New Roman;\">ACM</span><span style=\"font-family:宋体;\">比赛里划水的退役队员，对红黑树这样的有名数据结构还是比较敏感的。红黑树是一种特殊约束形式下的平衡二叉查找树实现。学过数据结构课的同学应该知道，课本上的最早的自平衡二叉树</span><span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树严格的要求子树的高度差不超过</span><span style=\"font-family:Times New Roman;\">2</span><span style=\"font-family:宋体;\">，以获得根结点到所有叶结点距离基本相同（平衡）的特性。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 红黑树不追求严格的平衡，而是通过<span style=\"font-family:Times New Roman;\">5</span><span style=\"font-family:宋体;\">个约束实现基本平衡：</span><br>&nbsp;&nbsp;&nbsp; ①结点是红色或黑色；<br>&nbsp;&nbsp;&nbsp; ②根是黑色；<br>&nbsp;&nbsp;&nbsp; ③叶结点是黑色；<br>&nbsp;&nbsp;&nbsp; ④红色结点的子结点都是黑色；<br>&nbsp;&nbsp;&nbsp; ⑤任一结点到其叶结点的简单路径中黑色结点数相同。</p>\n<p>&nbsp;&nbsp;&nbsp; AVL树根到叶结点最长距离与最短距离的比不超过2。红黑树的约束也保证了这一特性（最长路径是红黑相间，最短路径是全黑，这种情况下最长路径刚好是最短路径的2倍长）。</p>\n<p>&nbsp;&nbsp;&nbsp; 既然是平衡二叉查找树的一种实现，那么红黑树自然是内部有序的，同时跟AVL树一样支持O(log2n)时间复杂度的查找、插入和删除。</p>\n<p>&nbsp;&nbsp;&nbsp; 相比AVL树，红黑可以保证在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个结点。尽管最坏情况下需对O(log2n)个结点重染色，但就分摊意义（平均效率）而言，仅为O(1)个。但是因为没有严格约束树的平衡特性，红黑树的左右子树高度差比AVL树要大。</p>\n<h2 id=\"2-2-ngx-rbtree-h\"><a href=\"#2-2-ngx-rbtree-h\" class=\"headerlink\" title=\"2.2 ngx_rbtree.h\"></a>2.2 ngx_rbtree.h</h2><p>&nbsp;&nbsp;&nbsp; 机会难得，我们就把nginx的源码作为素材来深入了解一下红黑树的实现。首先是结点的结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">ngx_uint_t</span> <span class=\"hljs-type\">ngx_rbtree_key_t</span>;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">ngx_int_t</span> <span class=\"hljs-type\">ngx_rbtree_key_int_t</span>;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_node_s</span> <span class=\"hljs-type\">ngx_rbtree_node_t</span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_node_s</span> &#123;<br>    <span class=\"hljs-type\">ngx_rbtree_key_t</span>    key;<span class=\"hljs-comment\">//平台相关的无符号整型关键字</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *left;<span class=\"hljs-comment\">//左子结点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *right;<span class=\"hljs-comment\">//&lt;span style=&amp;quot;font-family:宋体;&amp;quot;&gt;右&lt;/span&gt;子结点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>   *parent;<span class=\"hljs-comment\">//父结点指针</span><br>    u_char          color;<span class=\"hljs-comment\">//结点颜色</span><br>    u_char          data;<span class=\"hljs-comment\">//结点数据</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 然后是红黑树的结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_s</span>  <span class=\"hljs-type\">ngx_rbtree_t</span>;  <span class=\"hljs-comment\">//“_s”是结构体“_t”是类型</span><br><span class=\"hljs-comment\">//下面是一个函数指针变量类型的定义，是红黑树插入函数的指针</span><br><span class=\"hljs-comment\">//参数有树根结点、插入结点和哨兵结点的指针</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*ngx_rbtree_insert_pt)</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *root,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ngx_rbtree_s</span> &#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *root;    <span class=\"hljs-comment\">//根节点指针</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel;    <span class=\"hljs-comment\">//哨兵结点指针</span><br>    ngx_rbtree_insert_pt   insert;  <span class=\"hljs-comment\">//插入函数指针</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 将函数指针变量作为结构体成员变量以达成可以把结构体当做类来使用（既有成员变量又有成员方法）的效果，这种手法在<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">的源码中相当普遍。关于函数，</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">还有一种更神奇的手段</span><span style=\"font-family:Times New Roman;\">——</span><span style=\"font-family:宋体;\">宏：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbtree_init(tree, s, i)                 \\</span><br><span class=\"hljs-meta\">    ngx_rbtree_sentinel_init(s);                \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;root = s;                       \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;sentinel = s;                   \\</span><br><span class=\"hljs-meta\">    (tree)-&gt;insert = i<span class=\"hljs-comment\">//这里insert函数指针的赋值实现了多态</span></span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 借助宏来达成内联函数的效果（函数实现如果比较简单，就干脆把实现过程整个搬到类中），令人费解的是，<span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">不是没有内联关键字，甚至同一个头文件中就有一个内联函数的定义。研究内联函数之前，下面还有几个宏要看一看：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_red(node)           ((node)-&gt;color = 1)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_black(node)         ((node)-&gt;color = 0)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_is_red(node)            ((node)-&gt;color)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_is_black(node)          (!ngx_rbt_is_red(node))</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbt_copy_color(n1, n2)      (n1-&gt;color = n2-&gt;color)</span><br><br><span class=\"hljs-comment\">/* a sentinel must be black */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ngx_rbtree_sentinel_init(node)  ngx_rbt_black(node)</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; nginx<span style=\"font-family:宋体;\">源码中的变量都很容易看懂以至于我们不怎么需要查资料或找注释。</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">置</span><span style=\"font-family:Times New Roman;\">1</span><span style=\"font-family:宋体;\">染红置</span><span style=\"font-family:Times New Roman;\">0</span><span style=\"font-family:宋体;\">染黑，</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">1</span><span style=\"font-family:宋体;\">则结点为红色，不为红色的则为黑色，复制结点颜色即复制</span><span style=\"font-family:Times New Roman;\">color</span><span style=\"font-family:宋体;\">值，哨兵结点一定要染成黑色。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ngx_inline <span class=\"hljs-type\">ngx_rbtree_node_t</span> *</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_min</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *node, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (node-&gt;left != sentinel) &#123;<br>        node = node-&gt;left;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; ngx_inline是一个宏，实际值就是关键字inline。这个内联函数非常好懂，目的看起来是寻找以任意结点为根结点的子树中结点值最小的结点。实现方法是找到红黑树子树最边缘的左子结点。那么我们有理由猜测，哨兵结点是空结点或边缘标识。</p>\n<h2 id=\"2-3-红黑树的结点插入\"><a href=\"#2-3-红黑树的结点插入\" class=\"headerlink\" title=\"2.3 红黑树的结点插入\"></a><span style=\"font-family:宋体;\">2.3 红黑树的结点插入</span></h2><p>&nbsp;&nbsp;&nbsp; 接下来我们来深入<span style=\"font-family:Times New Roman;\">ngx_rbtree.c</span><span style=\"font-family:宋体;\">看看</span><span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">如何实现几个关键的红黑树方法。</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_t</span> *tree, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//根结点指针的指针，或者根结点指针数组，会有多个根结点吗，令人费解</span><br>    <span class=\"hljs-comment\">//临时结点指针</span><br>    <span class=\"hljs-comment\">//哨兵结点指针，推测哨兵在每次查询时可能都不一样，也许指待插位置</span><br>    <span class=\"hljs-comment\">//变量不分行，我写注释都很不方便</span><br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  **root, *temp, *sentinel;<br><br>    <span class=\"hljs-comment\">/* a binary tree insert */</span><br><br>    root = (<span class=\"hljs-type\">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<span class=\"hljs-comment\">//树根指针的指针赋给了root</span><br>    sentinel = tree-&gt;sentinel;<span class=\"hljs-comment\">//哨兵指针赋给了哨兵指针</span><br><br>    <span class=\"hljs-keyword\">if</span> (*root == sentinel) &#123;<span class=\"hljs-comment\">//特判，如果根是哨兵，即树是空的</span><br>        node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<span class=\"hljs-comment\">//新插入的结点变成了根</span><br>        node-&gt;left = sentinel;<span class=\"hljs-comment\">//新结点的左子结点是哨兵</span><br>        node-&gt;right = sentinel;<span class=\"hljs-comment\">//新结点的右子结点也是哨兵</span><br>        <span class=\"hljs-built_in\">ngx_rbt_black</span>(node);<span class=\"hljs-comment\">//新根染黑</span><br>        *root = node;<span class=\"hljs-comment\">//确认新结点为新根</span><br><br>        <span class=\"hljs-keyword\">return</span>;<span class=\"hljs-comment\">//插入结束</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">//树初始化时给了insert指针一个函数地址</span><br>    <span class=\"hljs-comment\">//查看前面的宏ngx_rbtree_init(tree, s, i)</span><br>    <span class=\"hljs-comment\">//发现只是把指定结点染黑，同时赋为根和哨兵，给insert指针指定一个函数</span><br>    <span class=\"hljs-comment\">//ngx_rbtree.c中有两个参数表符合的可选函数：插入值、插入计时器值</span><br>    <span class=\"hljs-comment\">//稍后来看两种插入分别如何实现又有什么区别</span><br>    tree-&gt;<span class=\"hljs-built_in\">insert</span>(*root, node, sentinel);<br><br>    <span class=\"hljs-comment\">/* re-balance tree */</span><br>    <span class=\"hljs-comment\">//如果新结点不是根且其父结点是红的，循环</span><br>    <span class=\"hljs-keyword\">while</span> (node != *root &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_red</span>(node-&gt;parent)) &#123;<br>        <span class=\"hljs-comment\">//如果父结点是左子结点，获得父结点的右兄弟</span><br>        <span class=\"hljs-keyword\">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left) &#123;<br>            temp = node-&gt;parent-&gt;parent-&gt;right;<br>            <span class=\"hljs-comment\">//如果父结点的右兄弟是红的</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(temp)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//父结点染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//父结点的右兄弟染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//父结点的父结点染红</span><br>                node = node-&gt;parent-&gt;parent;<span class=\"hljs-comment\">//父结点的父结点成为当前结点</span><br><br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点的右兄弟是黑的</span><br>                <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;right) &#123;<span class=\"hljs-comment\">//如果新结点是右子结点</span><br>                    node = node-&gt;parent;<span class=\"hljs-comment\">//父结点成为新node</span><br>                    <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, node);<span class=\"hljs-comment\">//node左旋</span><br><br>                &#125;<br><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//node的父结点染黑</span><br>                <span class=\"hljs-comment\">//node的父结点的父结点染红</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<br>                <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//node的父结点的父结点右旋</span><br>            &#125;<br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点是右子结点，获得父结点的左兄弟</span><br>            temp = node-&gt;parent-&gt;parent-&gt;left;<br>            <span class=\"hljs-comment\">//如果父结点的左兄弟是红的</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(temp)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//父结点染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//父结点的左兄弟染黑</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//父结点的父结点染红</span><br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果父结点的左兄弟是黑的</span><br>                <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果新结点是左子结点</span><br>                    node = node-&gt;parent;<span class=\"hljs-comment\">//父结点成为当前结点</span><br>                    <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, node);<br>                    <span class=\"hljs-comment\">//当前结点右旋</span><br>                &#125;<br><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(node-&gt;parent);<span class=\"hljs-comment\">//当前结点染黑</span><br>                <span class=\"hljs-comment\">//当前结点父结点的父结点染红</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(node-&gt;parent-&gt;parent);<br>                <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, node-&gt;parent-&gt;parent);<span class=\"hljs-comment\">//当前结点的父结点的父结点左旋</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-built_in\">ngx_rbt_black</span>(*root);<span class=\"hljs-comment\">//根结点染黑</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 然后是对应ngx_rbtree_insert_pt指针的基础的结点插入函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_insert_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> *temp, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  **p;<span class=\"hljs-comment\">//虽然无关紧要，但两层指针令人费解</span><br><br>    <span class=\"hljs-keyword\">for</span> ( ;; ) &#123;<span class=\"hljs-comment\">//无条件循环或者说死循环，等同于while(1)但节省了一个字符</span><br><br>        p = (node-&gt;key &lt; temp-&gt;key) ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class=\"hljs-keyword\">if</span> (*p == sentinel) &#123;<span class=\"hljs-comment\">//在二叉树中查找新结点合适的叶结点位置</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br>    <span class=\"hljs-comment\">//令新结点占据合适的哨兵位置成为新的叶结点，染红，产生新哨兵</span><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    <span class=\"hljs-built_in\">ngx_rbt_red</span>(node);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; ngx_rbtree_insert_timer_value<span style=\"font-family:宋体;\">函数跟</span><span style=\"font-family:Times New Roman;\">ngx_rbtree_insert_value</span><span style=\"font-family:宋体;\">函数唯一区别就是判断大小时，采用了两个值相减，避免溢出。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 以上是插入结点涉及的函数，老实说我不太喜欢这么长的函数实现，换我自己写肯定分块了。分支操作太多，看代码逻辑已经乱了，我们需要画几个图。首先，如果树为空：</p>\n<p><img src=\"http://img.blog.csdn.net/20150806074055339\" alt=\"\" /><br /></p>\n<p>&nbsp;&nbsp;&nbsp; 如果树中只有一个根结点：</p>\n<img src=\"http://img.blog.csdn.net/20150806074132691\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">C&gt;A</span><span style=\"font-family:宋体;\">：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074207378\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">C&lt;B&lt;A</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">染红，</span><span style=\"font-family:Times New Roman;\">B</span><span style=\"font-family:宋体;\">染黑</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">染红，</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">右旋。右旋函数如下：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ngx_inline <span class=\"hljs-type\">void</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">ngx_rbtree_right_rotate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">ngx_rbtree_node_t</span> **root, <span class=\"hljs-type\">ngx_rbtree_node_t</span> *sentinel,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">ngx_rbtree_node_t</span> *node)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;left;<br>    node-&gt;left = temp-&gt;right;<span class=\"hljs-comment\">//左子结点指向原左子结点的右结点</span><br><br>    <span class=\"hljs-keyword\">if</span> (temp-&gt;right != sentinel) &#123;<span class=\"hljs-comment\">//如果左子结点的右结点不为哨兵</span><br>        temp-&gt;right-&gt;parent = node;<span class=\"hljs-comment\">//左子结点的右子结点挂在右旋结点上</span><br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<span class=\"hljs-comment\">//左子结点挂在右旋结点的父结点上</span><br><br>    <span class=\"hljs-keyword\">if</span> (node == *root) &#123;<span class=\"hljs-comment\">//如果右旋结点为根节点</span><br>        *root = temp;<span class=\"hljs-comment\">//根节点赋为左子结点</span><br><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;right) &#123;<span class=\"hljs-comment\">//如果右旋结点为右子结点</span><br>        node-&gt;parent-&gt;right = temp;<span class=\"hljs-comment\">//左子结点挂父结点右边</span><br><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//否则左子结点挂父结点左边</span><br>        node-&gt;parent-&gt;left = temp;<br>    &#125;<br><br>    temp-&gt;right = node;<span class=\"hljs-comment\">//右旋结点挂左子结点右边</span><br>    node-&gt;parent = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 显然<span style=\"font-family:Times New Roman;\">B</span><span style=\"font-family:宋体;\">将成为新的根，左</span><span style=\"font-family:Times New Roman;\">C</span><span style=\"font-family:宋体;\">右</span><span style=\"font-family:Times New Roman;\">A</span><span style=\"font-family:宋体;\">：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074443292\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 如果<span style=\"font-family:Times New Roman;\">B&lt;C&lt;A</span><span style=\"font-family:宋体;\">，会先做一次左旋再做一次右旋，其实除开染色过程，我觉得这跟</span><span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树的插入过程没有什么区别：</span></p>\n<img src=\"http://img.blog.csdn.net/20150806074520668\" alt=\"\" />\n\n<p>&nbsp;&nbsp;&nbsp; 其他的插入情景要么与以上几个对称，要么发生在树的其他子树中，实际过程完全一样。LL<span style=\"font-family:宋体;\">型右旋，</span><span style=\"font-family:Times New Roman;\">RR</span><span style=\"font-family:宋体;\">型左旋，</span><span style=\"font-family:Times New Roman;\">LR</span><span style=\"font-family:宋体;\">型先右旋后左旋，</span><span style=\"font-family:Times New Roman;\">RL</span><span style=\"font-family:宋体;\">型先左旋后右旋。</span>与<span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树不同的是，插入结点时红黑树左旋或右旋的判定条件明确为附近一两个结点的颜色，其他过程没有任何区别。</span></p>\n<h2 id=\"2-4-红黑树的结点删除\"><a href=\"#2-4-红黑树的结点删除\" class=\"headerlink\" title=\"2.4 红黑树的结点删除\"></a>2.4 红黑树的结点删除</h2><p>&nbsp;&nbsp;&nbsp; 据说红黑树和<span style=\"font-family:Times New Roman;\">AVL</span><span style=\"font-family:宋体;\">树的区别主要体现在删除节点时，我们就来看一看。</span>我刚说什么来着，删除结点的函数体更长了，足足<span style=\"font-family:Times New Roman;\">165</span><span style=\"font-family:宋体;\">行，我决定分段研究，</span>先看第一部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (node-&gt;left == sentinel) &#123;<span class=\"hljs-comment\">//如果左子结点是哨兵或左右子结点都是哨兵</span><br>    temp = node-&gt;right;<span class=\"hljs-comment\">//获得右子结点，后面让它接替node位置</span><br>    subst = node;<span class=\"hljs-comment\">//node赋给subst</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node-&gt;right == sentinel) &#123;<span class=\"hljs-comment\">//如果右子结点是哨兵</span><br>    temp = node-&gt;left;<span class=\"hljs-comment\">//获得左子结点，后面让它接替node位置</span><br>    subst = node;<span class=\"hljs-comment\">//node赋给subst</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果左右子结点都不是哨兵</span><br>    subst = <span class=\"hljs-built_in\">ngx_rbtree_min</span>(node-&gt;right, sentinel);<span class=\"hljs-comment\">//获得右子树中最小的结点</span><br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;left != sentinel) &#123;<span class=\"hljs-comment\">//如果右子树的最小结点的左子结点不是哨兵</span><br>        temp = subst-&gt;left;<span class=\"hljs-comment\">//获得右子树的最小结点的左子结点</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//否则获得右子树最小结点的右子结点</span><br>        temp = subst-&gt;right;<br>    &#125;<span class=\"hljs-comment\">//看起来subst将被从原位置删掉然后接替node的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 下面我们来看看<span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">要干什么用：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (subst == *root) &#123;<span class=\"hljs-comment\">//如果subst是根</span><br>    *root = temp;<span class=\"hljs-comment\">//temp接替根</span><br>    <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//染黑temp</span><br><br>    <span class=\"hljs-comment\">/* DEBUG stuff */</span><br>    node-&gt;left = <span class=\"hljs-literal\">NULL</span>;<span class=\"hljs-comment\">//清空了待删结点</span><br>    node-&gt;right = <span class=\"hljs-literal\">NULL</span>;<br>    node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<br>    node-&gt;key = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br>red = <span class=\"hljs-built_in\">ngx_rbt_is_red</span>(subst);<span class=\"hljs-comment\">//获得subst是否是红色</span><br><br><span class=\"hljs-keyword\">if</span> (subst == subst-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果subst是左子结点</span><br>    subst-&gt;parent-&gt;left = temp;<span class=\"hljs-comment\">//把接替结点挂到subst位置</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果subst是右子结点</span><br>    subst-&gt;parent-&gt;right = temp;<span class=\"hljs-comment\">//把接替结点挂到subst位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 下一段：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span> (subst == node) &#123;<span class=\"hljs-comment\">//如果subst是待删结点</span><br>    temp-&gt;parent = subst-&gt;parent;<span class=\"hljs-comment\">//接替结点直接接替，删除完成</span><br><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果subst不是待删结点</span><br>     <span class=\"hljs-keyword\">if</span> (subst-&gt;parent == node) &#123;<span class=\"hljs-comment\">//如果subst的父结点就是待删结点</span><br>        temp-&gt;parent = subst;<span class=\"hljs-comment\">//接替结点挂在subst上</span><br>     &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果待删结点比subst的父结点更高</span><br>        temp-&gt;parent = subst-&gt;parent;<span class=\"hljs-comment\">//把接替结点挂在subst的父结点上</span><br>    &#125;<br>    <span class=\"hljs-comment\">//subst接替待删结点node的位置，复制待删结点跟周围结点的关系</span><br>    subst-&gt;left = node-&gt;left;<br>    subst-&gt;right = node-&gt;right;<br>    subst-&gt;parent = node-&gt;parent;<br>    <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(subst, node);<span class=\"hljs-comment\">//复制颜色</span><br><br>    <span class=\"hljs-keyword\">if</span> (node == *root) &#123;<span class=\"hljs-comment\">//如果待删结点是根</span><br>        *root = subst;<span class=\"hljs-comment\">//subst接替根</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果待删结点不是根，subst接替它</span><br>        <span class=\"hljs-keyword\">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>            node-&gt;parent-&gt;left = subst;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            node-&gt;parent-&gt;right = subst;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;left != sentinel) &#123;<span class=\"hljs-comment\">//如果subst左子结点不是哨兵</span><br>        subst-&gt;left-&gt;parent = subst;<span class=\"hljs-comment\">//subst的左子结点放弃node，挂上来</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (subst-&gt;right != sentinel) &#123;<span class=\"hljs-comment\">//如果subst右子结点不是哨兵</span><br>        subst-&gt;right-&gt;parent = subst;<span class=\"hljs-comment\">//subst右子结点放弃node，挂上来</span><br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//清空待删结点node</span><br><span class=\"hljs-comment\">/* DEBUG stuff */</span><br>node-&gt;left = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;right = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;parent = <span class=\"hljs-literal\">NULL</span>;<br>node-&gt;key = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">//如果subst是红色，红黑树约束依然被遵守，删除工作就可以结束了</span><br><span class=\"hljs-keyword\">if</span> (red) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 看起来结点的删除过程已经顺利完成了，但是如果<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是黑色，我们需要修复红黑树的约束。下面这一段代码的主角是接替</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">位置的</span><span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">结点：</span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//当subst的接替结点不是根且为黑色，循环</span><br><span class=\"hljs-keyword\">while</span> (temp != *root &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(temp)) &#123;<br>    <span class=\"hljs-keyword\">if</span> (temp == temp-&gt;parent-&gt;left) &#123;<span class=\"hljs-comment\">//如果temp是左子结点</span><br>        w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得其右兄弟</span><br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(w)) &#123;<span class=\"hljs-comment\">//如果temp的右兄弟是红色</span><br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w);<span class=\"hljs-comment\">//染黑temp的右兄弟</span><br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(temp-&gt;parent);<span class=\"hljs-comment\">//染红temp的父结点</span><br>            <span class=\"hljs-comment\">//temp的父结点左旋</span><br>            <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, temp-&gt;parent);<br>            w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得temp的新右兄弟</span><br>        &#125;<br>        <span class=\"hljs-comment\">//如果temp右兄弟的左右子结点都是黑的</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left) &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<span class=\"hljs-comment\">//染红temp的右兄弟</span><br>            temp = temp-&gt;parent;<span class=\"hljs-comment\">//获得temp的父结点为新temp</span><br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果temp右兄弟的子结点不全为黑</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<span class=\"hljs-comment\">//如果其右子结点是黑色</span><br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;left);<span class=\"hljs-comment\">//染黑左子结点</span><br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<span class=\"hljs-comment\">//染红temp的右兄弟</span><br>                <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, w);<span class=\"hljs-comment\">//右兄弟右旋</span><br>                w = temp-&gt;parent-&gt;right;<span class=\"hljs-comment\">//获得temp的新右兄弟</span><br>            &#125;<br>            <span class=\"hljs-comment\">//temp右兄弟复制temp父结点颜色</span><br>            <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(w, temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp-&gt;parent);<span class=\"hljs-comment\">//染黑temp父结点</span><br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;right);<span class=\"hljs-comment\">//染黑temp右兄弟的右子结点</span><br>            <span class=\"hljs-comment\">//temp父结点左旋</span><br>            <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, temp-&gt;parent);<br>            temp = *root;<span class=\"hljs-comment\">//获得根</span><br>        &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//如果temp是右子结点，做对称的事</span><br>        w = temp-&gt;parent-&gt;left;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_red</span>(w)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w);<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, temp-&gt;parent);<br>            w = temp-&gt;parent-&gt;left;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left) &amp;&amp; <span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;right)) &#123;<br>            <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<br>            temp = temp-&gt;parent;<br><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">ngx_rbt_is_black</span>(w-&gt;left)) &#123;<br>                <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;right);<br>                <span class=\"hljs-built_in\">ngx_rbt_red</span>(w);<br>                <span class=\"hljs-built_in\">ngx_rbtree_left_rotate</span>(root, sentinel, w);<br>                w = temp-&gt;parent-&gt;left;<br>            &#125;<br><br>            <span class=\"hljs-built_in\">ngx_rbt_copy_color</span>(w, temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(temp-&gt;parent);<br>            <span class=\"hljs-built_in\">ngx_rbt_black</span>(w-&gt;left);<br>            <span class=\"hljs-built_in\">ngx_rbtree_right_rotate</span>(root, sentinel, temp-&gt;parent);<br>            temp = *root;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">ngx_rbt_black</span>(temp);<span class=\"hljs-comment\">//染黑当前temp</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 跟插入结点时一样乱，我们梳理一下。</p>\n<p>&nbsp;&nbsp;&nbsp; 首先忽略红黑树的约束进行删除：<br>&nbsp;&nbsp;&nbsp; ①如果删除的是一个叶结点，即没有后继或后继全为哨兵的结点，直接删除即可；<br>&nbsp;&nbsp;&nbsp; ②如果只有一个后继，让其替换待删除结点即可；<br>&nbsp;&nbsp;&nbsp; ③如果有两个后继，需要从树的边缘选择一个结点，有两种等价的选择，待删结点左子树的最大结点和右子树的最小结点，<span style=\"font-family:Times New Roman;\">nginx</span><span style=\"font-family:宋体;\">选择的是后者，以这个结点的键与值（</span><span style=\"font-family:Times New Roman;\">key</span><span style=\"font-family:宋体;\">与</span><span style=\"font-family:Times New Roman;\">value&#x2F;data</span><span style=\"font-family:宋体;\">）替换待删结点的键与值，然后删除这个替身。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 不论是①、②情景中的待删结点还是③情景中替身，在源码中都是subst。下面要围绕着它来进行讨论。</p>\n<p>&nbsp;&nbsp;&nbsp; 以上是不考虑红黑树平衡性的纯拓扑结构变动。下面要考虑是否调整树的拓扑结构使树重新平衡，是否调整结点的颜色使树重新符合红黑树的约束条件。我们知道红黑树有一条关键约束是任意结点到其子树中叶结点的简单路径中黑色结点数相同。那么如果<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是一个红色结点，我们不需要对红黑树做任何调整，它仍是一棵红黑树；如果</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是黑色的，所有经过</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">的简单路径上都会少一个黑色结点数，所以需要进行调整。</span></p>\n<p>&nbsp;&nbsp;&nbsp; 下面来根据不同情景分情况讨论，因为二叉树的情景左右颠倒时调整方式也可以左右颠倒，我们只讨论<span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">是左子结点的情况。设刚接替</span><span style=\"font-family:Times New Roman;\">subst</span><span style=\"font-family:宋体;\">的</span><span style=\"font-family:Times New Roman;\">temp</span><span style=\"font-family:宋体;\">为</span><span style=\"font-family:Times New Roman;\">X</span><span style=\"font-family:宋体;\">，</span><span style=\"font-family:Times New Roman;\">X</span><span style=\"font-family:宋体;\">的新右兄弟为</span><span style=\"font-family:Times New Roman;\">W</span><span style=\"font-family:宋体;\">。从经过简化的源码来看，关于结点颜色的变化很令人费解，我们不妨先来看一看：</span><br>&nbsp;&nbsp;&nbsp; ①W为红色：将W染黑，将X与W的父结点X-&gt;parent染红，X-&gt;parent左旋，W重设为X的新右兄弟，然后转入情景①、②或③；<br>&nbsp;&nbsp;&nbsp; ②W为黑色，W两个后继都是黑色：将W染红，X重设为X-&gt;parent；<br>&nbsp;&nbsp;&nbsp; ③W为黑色，W右子结点为黑色：将W左子结点染黑，将W染红，W右旋，W重设为X的新右兄弟，然后将X-&gt;parent的颜色赋给W，将X-&gt;parent染黑，X-&gt;parent左旋，根赋给temp；<br>&nbsp;&nbsp;&nbsp; ④W为黑色，W右子结点为红色：将W左子结点染黑，将W染红，W右旋，W重设为X的新右兄弟，然后将X-&gt;parent的颜色赋给W，将X-&gt;parent染黑，将W右子结点染黑，X-&gt;parent左旋，根赋给temp。</p>\n<p>&nbsp;&nbsp;&nbsp; 最后还要把temp染黑。我们可以看到情景①中进行了一次左旋，情景②只进行了染色，情景③、④都进行了一次右旋和一次左旋。情景①处理结束时一定还要转入别的情景，情景②、③、④的出现则标志着本次调整的结束。那么，红黑树删除结点后的调整过程中，依情景①循环出现的次数，调整过程中旋转的最多见的次数将是1次、2次、3次，再往上次数越多越罕见（依情景①循环出现的次数），最多旋转次数将可能到达树高即log2n次。生产环境中，删除结点后平均每次调整中旋转的次数就像分析源码之前提到的，将是常数规模的。</p>\n<p>&nbsp;&nbsp;&nbsp; 接下来我打算以逐步翻新版本的方式重写红黑树，更精细、直观地了解红黑树这一数据结构。而在重写之前，我们需要了解，nginx的红黑中所有的叶结点，都是哨兵（sentinel），这在调整红黑树时达成了对红黑树的一种优化。通过增加一层全黑的子结点，红黑树中实际有值的子树里，就允许在子结点出现红色结点了。虽然我没有证明，但这常数规模地增加了删除结点时的旋转次数，也促进了插入新结点时进行调整的概率（增加了在红色结点下插入新结点的概率），同样增加了旋转的次数。而旋转将压缩红黑树子树的高度，提高查询效率。</p>\n<p>&nbsp;&nbsp;&nbsp; 在由朴素到精致地重写红黑树的过程中，我将由少到多地考虑使用nginx对红黑树的优化，或者加入我自己的优化。</p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">从杭州回来后翻了CLRS（算法导论），发现：<br>&nbsp;&nbsp;&nbsp; 首先，nginx的红黑树中，sentinel结点并非独创的优化手段，CLRS的红黑树也是带哨兵的，可以说，一般的，我们令红黑树带哨兵。目的是更直截了当的满足红黑树的叶结点全黑约束，同时更方便标识树的边缘。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">其次，所有的叶结点都是由同一个哨兵结点代表，节省了空间开销，省去了叶结点逐一染色的麻烦。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">另外，之前我感到迷惑的static inline组合用法，在oschina.net获得了解释：<br>&nbsp;&nbsp;&nbsp; 1.inline函数是不能像传统的函数那样放在.c中然后在.h中给出接口在其余文件中调用的,因为inline函数其实是跟宏定义类似，被调用时尝试在调用处直接展开整个函数体，不存在所谓的函数入口。<br>&nbsp;&nbsp;&nbsp; 2.因为第一点，会出现一个问题，如果inline函数在两个不同的文件中出现。也就是说一个头文件被两个不同的源文件包含，则会出现重名，链接失败。static inline 的用法就能很好的解决这个问题。使用static修饰符，函数仅在文件内部可见，不会污染命名空间。可以理解为一个inline函数在不同的源文件里面生成了不同的实例，而且名字是完全相同的 。</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">总结一下。功能上，我们需要微型函数被大量调用时尝试内联展开以节省压栈弹栈的开销；实践中，为了防止不同文件中函数同名时的链接错误，我们需要加上static关键字的限制。（尽管inline关键字的效果有所不同，c99标准和gcc下static inline组合是兼容的，效果相同）</span></p>\n<p>&nbsp;&nbsp;&nbsp; <span style=\"color:#FF0000;\">之前看到nginx源码中函数参数有双重指针一直很费解，今天研究了一下才发现原因。ngx_rbtree_t中，root经常使用双重结点指针，也就是根结点地址的地址。如果树的修改过程中，根结点地址被别的结点地址替换掉，需要重新设置根的地址<em>root。假设ngx_rbtree_t中的根地址参数是</em>root单层指针，进入函数体时将是一个值传递，出函数体时无论函数体中如何更改根的地址，都是无效的，只有对根结点内容的修改能保留下来。所以要么使用双重指针作为根地址的参数，要么提供树结构体的地址，变相提供双重指针作为参数，当然可以提供树的结构体对象本身作为参数，但是值传递是要复制整个值对象的，显然当结构体比较大时这样做将明显增加开销。nginx选择双重指针而非结构体指针来避免树结构体内的变量遍历寻址，进一步提高效率。</span></p>\n",
            "tags": [
                "nginx",
                "ngx_int_t",
                "rbtree",
                "C"
            ]
        }
    ]
}