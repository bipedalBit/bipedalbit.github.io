{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hacking to the gate! • All posts by \"c++\" category",
    "description": "Bipedal Bit's blog",
    "home_page_url": "https://bipedalbit.net",
    "items": [
        {
            "id": "https://bipedalbit.net/2015/12/01/C-%E7%9A%84%E4%BD%8D%E4%BC%98%E5%8C%96/",
            "url": "https://bipedalbit.net/2015/12/01/C-%E7%9A%84%E4%BD%8D%E4%BC%98%E5%8C%96/",
            "title": "C++的位优化",
            "date_published": "2015-12-01T02:53:29.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 之前的中国象棋初版重在实现，老实说不论是时空效率还是健壮性都不太拿得出手，于是导师要求继续优化改进。考虑和调查过后，时间效率上可以借助之前设想的并行计算得到小幅优化，此外使用类似bool数组的手段也可以在走法生成器中小幅优化边界判断过程，最重要的时间效率优化手段是把博弈机改造成查表器，即以查表为主博弈为辅改变重心。以上都是时间效率优化，这篇文中暂且不展开，我的中国象棋初版在搜索深度大时（大于等于４层）开始出现程序崩溃的现象，暴露了空间效率问题。作为空间效率优化的铺垫，这次我来做个C++位优化的自科普。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; 关于空间效率优化，从前顶多考虑到基本变量类型选择的程度，然而C++提供了一些更精细的特性，供程序员进行位级别的内存微操——位域、bitset、vector&lt;bool&gt;。</p>\n<h1 id=\"1-位域\"><a href=\"#1-位域\" class=\"headerlink\" title=\"1 位域\"></a>1 位域</h1><h2 id=\"1-1-字节对齐\"><a href=\"#1-1-字节对齐\" class=\"headerlink\" title=\"1.1 字节对齐\"></a>1.1 字节对齐</h2><p>&nbsp;&nbsp;&nbsp; 介绍位域之前，还需要做一点铺垫。业界C&#x2F;C++面试、笔试题中，经常考到结构体的字节对齐问题。比如，可能会问下面两个结构体分别占多大内存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s2</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; <code>sizeof(s1)</code>和<code>sizeof(s2)</code>分别为56字节和40字节。先不管为什么装着同样变量的结构体占用的内存大小会不同，如果结构体中变量紧密排列，应该占多大内存？ａ：1字节，ｂ：4字节，ｃ：9字节，ｄ：2字节，ｅ：4字节，ｆ：8字节，ｇ：8字节，共36字节。显然这些变量实际上不是紧密排列的，存在一些对齐、填充字节的规则：</p>\n<ul>\n<li>有效对齐值默认为结构体最宽<em>基本类型</em>成员的大小，注意结构体的结构体成员必须到内部寻找基本类型成员变量计算有效对齐值；</li>\n<li>结构体变量的首地址能够被其有效对齐值所整除；</li>\n<li>结构体每个成员相对于结构体首地址的偏移量都是其本身大小的整数倍，如有需要编译器会在成员之间加上填充字节；</li>\n<li>结构体的总大小为结构体有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节；</li>\n<li>存在指定对齐值（<code>#pragma pack (value)</code>中的value）时，<code>有效对齐值 = min&#123;默认对齐值, 指定对齐值&#125;</code>。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 至于为什么要做字节对齐，这与CPU取数方式有关，尤其与CPU与内存间数据总线宽度（现在除了单片机通常为32位）有关。因为数据总线宽度是硬件相关，所以一次取数的位数是固定的，假设总线宽度32位，那么一次取数的数据大小就为4字节，那么CPU读取内存数据就将以内存首地址为基址，以4个字节为偏移量单位。如果结构体中有一个char型和一个int型变量，紧密排列存储在内存中，读char型变量时照样取了结构体的前4个字节，其中高8位的哪个字节是存储着char型变量，会经过一些位运算后被提取出来（比如按位右移24位，这仅仅是猜测），到此为止看不出什么不好的。可是当读int型变量时问题就来了，CPU无法一次读取到整个int变量了，原因前面提到了：<em>CPU读取内存数据就将以内存首地址为基址，以4个字节为偏移量单位</em>。经过两次取数才能获得被分割在两个字（32位内存单位）中完整的int型变量，这还不算完，还要分别从两个字中提取恰当的位并进行拼接，这很浪费时间。<br>&nbsp;&nbsp;&nbsp; 按特定规则进行字节对齐后，虽然浪费了一些填充字节的内存空间，情况还是好多了。以s1为例，有效对齐值是double型和long long型的8字节即两个字，这里称其为一个对齐空间，装填a（填充7个字节），装填f，装填b（填充4个字节），装填g，装填c（一个对齐空间内放不下，第二个空间中也放了1个字节，填充7个字节），装填e，装填d，结构体整体填充2字节，填满对齐空间的整数倍。<br>&nbsp;&nbsp;&nbsp; 同理也可求得s2的内存占用，至于两个结构体的内存占用不一样的原因，是它们的成员变量排列顺序不同，而结构体给成员变量分配内存的顺序与定义变量的顺序相同。<br>&nbsp;&nbsp;&nbsp; 当指定对齐值小于默认对齐值，可令结构体的成员变量排列更紧密，更省空间，但可能降低取数效率。特别的，当指定对齐值为1，结构体成员变量完全紧密排列。</p>\n<h2 id=\"1-2-位域与其利弊\"><a href=\"#1-2-位域与其利弊\" class=\"headerlink\" title=\"1.2 位域与其利弊\"></a>1.2 位域与其利弊</h2><p>&nbsp;&nbsp;&nbsp; 不管是为数据结构的成员变量设计合适的排列顺序，还是指定合适的字节对齐值，都是在字节的层次上优化程序空间效率。而使用位域，可以在位的层次上优化程序空间效率。<br>&nbsp;&nbsp;&nbsp; 还是以1.1节中的s1为例，只在字节层面上优化，以不损失时间效率为前提，最佳策略如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(4)</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g;<br>\t<span class=\"hljs-type\">int</span> b;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>&#125;;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack()</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 实际上就是保证按32位字（4字节）对齐，变量按大小降序排列。此时的<code>sizeof(s1)</code>为36字节，空间开销等同变量成员紧密排列，时间效率没有受到影响。<br>&nbsp;&nbsp;&nbsp; 下面这种写法不知读者见过没有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(4)</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">s1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> f;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> g: <span class=\"hljs-number\">21</span>;<br>\t<span class=\"hljs-type\">int</span> b: <span class=\"hljs-number\">7</span>;<br>\t<span class=\"hljs-type\">float</span> e;<br>\t<span class=\"hljs-type\">short</span> d;<br>\t<span class=\"hljs-type\">char</span> a;<br>\t<span class=\"hljs-type\">char</span> c[<span class=\"hljs-number\">9</span>];<br>&#125;;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack()</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 对这样定义的结构体s1，<code>sizeof(s1)</code>是28字节。变量b、g后面的‘:’和数字就是位域的描述方式。位域的作用是把一些用不到当前类型变量中所有位的变量做进一步压缩，比如这里的s1结构体中的g变量，原来占用64位，使用位域压缩后g变量只使用原内存空间的高21位，填充3位补满3个字节后，原long long变量的后5个字节就可以自由分配了；b变量，原来占用32位，使用位域压缩后b变量只使用原内存空间的高7位，填充1位填满1个字节后，原int变量的后3个字节的内存空间就可以自由分配了。b、g压缩过后刚好占据4个字节一个32位字，比原来少占８个字节。<br>&nbsp;&nbsp;&nbsp; 于是，借由位域压缩技术，C++得以进行位层次的空间效率优化了。然而位域的使用有着诸多限制和缺陷：</p>\n<ul>\n<li>位域不可以用于浮点型变量的压缩；</li>\n<li>位域压缩有符号数时，由于其存储变量的编码方式是源码而非平常变量的补码，变量符号将可能出现不可预料的状态；</li>\n<li>位域压缩将局部解除变量间原有的的字节对齐规范，即使位域压缩的变量与相邻变量紧密排列，这可能引起取数时间效率的损失。</li>\n</ul>\n<h1 id=\"2-bitset\"><a href=\"#2-bitset\" class=\"headerlink\" title=\"2 bitset\"></a>2 bitset</h1><p>&nbsp;&nbsp;&nbsp; 这一节我要介绍的是比特集，正如字面意思，它是一种比特的集合的特殊数据结构。位域是C遗留下来的特性，存在很多不完备和妥协的地方,C++中推荐的替换方案之一就是bitset。它的具体使用方法我不想细讲，这里只做个概念介绍，想了解更多可以看<a href=\"http://www.cplusplus.com/reference/bitset/bitset/\">标准C++手册</a>，<del>其实是我困了懒得写</del>。<br>&nbsp;&nbsp;&nbsp; 比特集维护一个静态定义其长度的比特串，内存占用以系统字长（通常为<em>机器字长</em>，即CPU中寄存器的位数，即CPU进行数据计算的单位位宽，而非前面提到的数据总线宽度，但机器字长一定是数据总线宽度的整数倍）为单位长度，当然如果读者使用64位的机器却安装32位的系统则是把机器当做32位机使用，每个CPU寄存器只使用一半的位数。比特集可以通过包含‘０’、‘１’的字符串来构造，也可以通过无符号的整型变量来构造。为什么是无符号数？因为比特的集合本来就是逻辑的、离散的，符号在比特集中没有意义。当然如果想用某个逻辑位来作为符号位也随用户喜欢。相应的，比特集也可以转换成‘０’、‘１’字符串或者整型数。理所当然的，比特集类封装了一系列位运算符号和逻辑位操作方法，注意比特集的位操作符号两边都应该是比特集，位移操作符除外。<br>&nbsp;&nbsp;&nbsp; 也许有读者想了解bitset的内存占用情况，我进行了下面的一系列测试：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">10</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">20</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">40</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//8</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">80</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//16</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">160</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//24</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">320</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//40</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">640</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//80</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(bitset&lt;<span class=\"hljs-number\">1280</span>&gt;) &lt;&lt; endl;\t<span class=\"hljs-comment\">//160</span><br></code></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp; 测试结果我写在注释里了，可以看到，bitset的存储单位是8个字节，而我的这台笔记本电脑正是64位机器字长的，测试环境是64位的Ubuntu 14.04版本操作系统。<br>&nbsp;&nbsp;&nbsp; 同样的，比特bitset也有它的不足之处，比如它不能再与普通整型数直接进行位运算，且它一经构造，不可以改变长度。至于时间效率，可以充分相信它不比普通整型的同类操作慢。</p>\n<h1 id=\"3-vector\"><a href=\"#3-vector\" class=\"headerlink\" title=\"3 vector&lt;bool&gt;\"></a>3 vector&lt;bool&gt;</h1><p>&nbsp;&nbsp;&nbsp; 当我第一次在手册中看见vector&lt;bool&gt;时我并没有留意，虽然也对bool型的vector容器为什么有一套独立的API感到了一丝困惑。后来在查找bitset相关资料时发现有人写了vector&lt;bool&gt;与bitset的比较文章，这才知道，vector&lt;bool&gt;是C++提供的bitset之外的另一种位层次数据结构微操方案，同等长度的两者的内存占用几乎一样。vector&lt;bool&gt;的具体用法读者依旧可以查看<a href=\"http://www.cplusplus.com/reference/vector/vector-bool/\">手册</a>，<del>是的我又偷懒了XDDD</del>。<br>&nbsp;&nbsp;&nbsp; 既然vector&lt;bool&gt;实现在vector库文件中，想必读者也能猜到它与bitset最大的不同，没错它是可变长的。相应的，作为牺牲，考虑数组与vector的区别，也不难猜到，vector&lt;bool&gt;比bitset慢。首先它的位操作也比bitset少得多，其次vector&lt;bool&gt;中的位不再能够用下标随机存取，而需要使用迭代器来访问。其实比起bitset的变长版本，我觉得说vector&lt;bool&gt;是bool型vector的空间优化版本更合适一些。</p>\n<p>&nbsp;&nbsp;&nbsp; 以上就完成了简单的位层面程序空间效率优化的相关概念引入，下面会继续跟进我的中国象棋的改进版本。</p>\n",
            "tags": [
                "C++",
                "位域",
                "bitset",
                "vector&lt;bool&gt;"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/10/17/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94c-11%E7%AF%87/",
            "url": "https://bipedalbit.net/2015/10/17/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94c-11%E7%AF%87/",
            "title": "C++多线程初探——c++11篇",
            "date_published": "2015-10-17T06:58:22.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 今天被说C++出身的猿不会多线程跟不会C++有什么分别，于是放下刚到手的Go和R的书，痛定思痛准备来给自己补补课。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; C++新标准c++11出现之前（虽然“新”标准已经发布好几年了），大家用C++写多线程通常有两种方式：Unix&#x2F;Linux下通常使用POSIX标准的pthread.h库，pthread并不是语言本身提供的内置库，gcc编译带pthread的程序时需要加上<code>-lpthread</code>标识参数；Windows下，win系列系统提供了一些线程API，但是由于gcc&#x2F;g++等编译器的跨平台性，其实也可以在win下使用pthread。<br>&nbsp;&nbsp;&nbsp; 然而2011年夏天，c++11标准发布了，新C++有了许多方便的新特性，其中就包括内置的，对多线程的支持。gcc 4.6及以前的版本编译c++11标准的多线程程序时还要加<code>-pthread</code>标识参数（注意与pthread库的<code>-lpthread</code>参数的区别）。后来也默认的支持新C++的内置多线程了，实测gcc 4.8.4除了<code>-std=c++11</code>不加别的参数，能够顺利编译运行c++11的多线程程序。<br>&nbsp;&nbsp;&nbsp; 铺垫了这么多，下面就先来试试c++11的多线程吧。<br>&nbsp;&nbsp;&nbsp; helloWorld.cpp：</p>\n<pre><code class=\"hljs\">/* c++11线程类的所在，下面的std::thread和std::this_thread都在其中 */\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid thread_task()\n&#123;\n\tcout &lt;&lt; &quot;Hello world! My thread ID is &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;\n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n\t// 主线程测试\n\t/* get_id函数是thread类和this_thread类的成员，获取线程ID */\n\tcout &lt;&lt; &quot;I&#39;m the main thread. My thread ID is &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;\n\t// 子线程测试\n\t/* 构造子线程时指派线程任务函数指针 */\n\tthread t1(thread_task);\n\tthread t2(thread_task);\n\tthread t3(thread_task);\n\t/* 主线程创建子线程 */\n\tt1.join();\n\tt2.join();\n\tt3.join();\n\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 最简单的多线程测试看起来运行的很顺利。下面我们稍微详细一点研究下std::thread的<a href=\"http://www.cplusplus.com/reference/thread/thread/\">官方文档</a>。</p>\n<ul>\n<li>thread::id：thread下面有个子类型thread::id，表示线程ID。是thread::get_id和this_thread::get_id的返回值。thread::id的构造函数返回一个non-joinable（不代表任何一个线程，即不与任何一个未终止的线程对应的ID相等）的线程ID。一个活跃的线程的ID会在线程终止后变成non-joinable线程ID。</li>\n<li>thread类的构造有4种形式：</li>\n</ul>\n<ul>\n<li>thread::thread()：默认构造函数，即不带参数的构造函数。构造一个非活跃（不可执行）的线程对象。</li>\n<li>thread::thread (Fn&amp;&amp; fn, Args&amp;&amp;… args)：初始化构造函数，即带足够多参数，足以初始化一个线程的构造函数。初始化构造函数的参数列表包括一个函数指针和这个函数的参数列表。利用迟邦定技术，构造过程与对函数副本的请求同步完成。</li>\n<li>复制构造函数，即从一个线程对象复制而得到一个新的线程对象。实际上，线程对象不允许被复制。</li>\n<li>thread::thread (thread&amp;&amp; x)：移动构造函数，即重新给指定线程分配一个对象（句柄），并释放原来的线程对象（句柄）。注意这并不影响原线程的执行，因为只是释放了对象（句柄），而没有分离原进程、释放资源。参数只有原线程对象。</li>\n</ul>\n<ul>\n<li>thread::~thread()：如果一个活跃线程被释放，首先会调用terminal()方法停止线程的执行。</li>\n<li>thread::operator&#x3D;(thread&amp;&amp; rhs)：作用相当于移动构造函数，原线程句柄被释放，返回一个更换句柄的线程对象。</li>\n<li>thread::get_id()：如果方法的目标线程对象是活跃的，生成一个唯一的ID并返回；如果调用方法的线程对象非活跃，先调用线程的默认构造函数生成一个non-joinable线程对象，然后生成一个唯一的ID并返回。</li>\n<li>thread::joinable()：joinable方法的唯一参数为一个线程ID，它的bool型返回值代表这个线程ID是否对应一个活跃的线程。this_thread下并没有这个方法，因为当前线程如果不为活跃线程，它将不能完成任何线程任务，即不能调用任何方法。</li>\n<li>thread::join()：这个方法将阻塞调用方法的线程（主线程），直到目标线程中的操作全部完成。这个方法返回之后，目标线程对象的状态就变为非活跃并可以被安全的释放了。换句话说，这个方法定义了一组线程同步关系。</li>\n<li>thread::detach()：应该有读者注意到了，detach是join的反义词，该方法的作用是从调用线程（主线程）中分离目标线程，让目标线程可以独立并行执行。调用detach方法后两个线程（调用线程和目标线程）都不会被阻塞或者被同步，而是会并行执行直到各自完成所有操作，谁完成执行谁就释放自己的资源，互不影响。（不是我啰嗦，文档原文就是这么说的）这个方法返回之后，目标线程对象的状态就变为非活跃并可以被安全的释放了。换句话说，这个方法定义了一组线程异步关系。</li>\n<li>thread::swap(thread&amp; x)：文档原文说是交换两个线程对象的<strong>状态</strong>，我表示不明白状态是指什么。实验表明应该是交换了线程与对象（句柄）的映射关系。thread类还重载了一个面向过程风格的swap方法版本：<code>void swap (thread&amp; x, thread&amp; y)</code>。</li>\n<li>thread::hardware_concurrency()：这是个静态成员函数，返回一个无符号整型，返回一个大概的（不一定准确，因为系统可以支持或限制每个进程创建的线程数）基于硬件的最大并行线程数。如果这个试图返回的值没有被系统很好的定义，返回0。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; thread头文件中还有一个与thread并列的<a href=\"http://www.cplusplus.com/reference/thread/this_thread/\">this_thread类</a>，this_thread类非常简单，除了get_id方法只有另外三个方法：</p>\n<ul>\n<li>this_thread::yield()：顾名思义，使当前线程退让，从执行状态变为就绪状态，使同优先级的线程有机会被重新调度进入执行状态。如果当前进程没什么毛病那么使它退让并没有太大意义，甚至可能不会造成事实上的线程执行顺序变化。yield方法应该在当前线程忙等别的线程而又没有被阻塞时执行。</li>\n<li>this_thread::sleep_until(const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)：阻塞当前线程直到特定时间点，使当前线程至少等待到特定时间点后继续执行，参数是一种特定格式的时间点数据。</li>\n<li>this_thread::sleep_for(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time)：阻塞当前线程一段时间，使当前线程至少等待特定时长后继续执行，参数是一种特定格式的时间段数据。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp; 其实c++11标准下，除了thread，还有其他四个用来支持多线程的辅助头文件：<a href=\"http://www.cplusplus.com/reference/atomic/\">atomic</a>、<a href=\"http://www.cplusplus.com/reference/mutex/\">mutex</a>、<a href=\"http://www.cplusplus.com/reference/condition_variable/\">condition_variable</a>、<a href=\"http://www.cplusplus.com/reference/future/\">future</a>。前三个很好理解，分别提供封装好的原子数据类型、互斥锁设备和条件值，future头文件里提供的是一些对分享的数据资源进行竞争的必须设备（我很迷茫头文件为什么不干脆叫share而是叫future这个让人摸不着头脑的名字）。如果读者熟悉操作系统或者进程调度，一定不会对前面这些东西感到陌生。<br>&nbsp;&nbsp;&nbsp; 我们不难管中窥豹猜测多线程的实质，操作系统实现了完善的进程调度，而同样的事情我们要自己对线程再做一遍。线程的调度（包括同步异步、资源调配等等）也就是多线程编程具体要做的事。（还一片茫然的读者请去看任意一本操作系统课本前两三章的样子补补课）<br>&nbsp;&nbsp;&nbsp; 这篇文主要是科普，入门，建立概念，复杂的多线程实现练习之后再慢慢做，当然也会发文的。下一篇文我准备再科普一下POSIX标准的多线程编程，即pthread库的多线程编程。是的，我不打算研究win下的多线程API了，直言不讳的说，我对Windows有偏见。</p>\n",
            "tags": [
                "C++",
                "c++11",
                "多线程"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "url": "https://bipedalbit.net/2015/10/08/C-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%99%A8/",
            "title": "C++二进制-十进制转换器",
            "date_published": "2015-10-08T14:05:52.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 布置了二进制-十进制转换器的小作业，本来还要求顺手扩展一下大数的四则运算，我嫌麻烦没做扩展，就只是写来玩玩。也算熟悉一下底层的二进制-十进制转换机制，顺便复习下C++源码规范。注释写了很多，就不多做解释了，只贴代码。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; converter.h:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n#ifndef _CONVERTER_H_\n#define _CONVERTER_H_\n\n#include &lt;string&gt;\n\n/*\n * This is a class to offer operations converting radix of number in string.\n */\nclass Converter\n&#123;\nprivate:\n\t/* to store the binary form of picked up number string */\n\tstd::string binVal;\n\t/* to store the decimal form of picked up number string */\n\tstd::string decVal;\n\t/* to sign the number by marking wether it is negtive */\n\tbool negtive;\n\t/* to mark wether the number has a dot */\n\tbool hasDot;\n\t/* to store the index of dot in binary number string */\n\tint binDotIndex;\n\t/* to store the index of dot in decimal number string */\n\tint decDotIndex;\n\t/* max reserved digits sum when float converted from decimal to binary */\n\tint binFloatPrecision;\n\t/*\n\t * Convert the binary number to decimal form then fill this-&gt;decVal.\n\t */\n\tvoid bin2Dec();\n\t/*\n\t * Convert the decimal number to binary form then fill this-&gt;binVal.\n\t */\n\tvoid dec2Bin();\npublic:\n\t/*\n\t * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n\t */\n\tConverter(std::string str, int radix, int binFloatPrecision = 20);\n\t/*\n\t * Get the the number string with specified radix.\n\t */\n\tstd::string getNum(int radix);\n&#125;;\n\n#endif\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; converter.cpp:</p>\n<pre><code class=\"hljs\">/*\n * Copyright (C) Bipedal Bit\n * Verson 1.0.0.1\n */\n\n #include &quot;converter.h&quot;\n #include &lt;iostream&gt;\n #include &lt;stdexcept&gt;\n\n/*\n * name: Converter\n * args:\n *\tstring str: the original string containing target number\n *\tint radix: the radix of the number to pick up form str\n *\tint binFloatPrecision: max reserved digits sum when float converted from decimal to binary\n *\t\twhose default value is 20\n * Constructor of the class to pick up number in string and fill both this-&gt;binVal and this-&gt;decVal.\n */\n Converter::Converter(std::string str, int radix, int binFloatPrecision)\n&#123;\n\t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* check binFloatPrecision */\n\tif (binFloatPrecision &lt; 1)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: binFloatPrecision should be greater than 0.\\n&quot;;\n\t\treturn;\n\t&#125;\n\t/* fill this-&gt;binFloatPrecision */\n\tthis-&gt;binFloatPrecision = binFloatPrecision;\n\t/* assistant variables for traversing the original string */\n\tint len = str.size();\n\tint i = 0;\n\t/* mark wether there&#39;s a dot in the number */\n\tbool hasDot = false;\n\t/* store number string temporarily */\n\tstd::string tmp = &quot;&quot;;\n\tif (len &gt; 0)\n\t&#123;\n\t\t/* handle binary radix */\n\t\tif (radix == 2)\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get &#39;0&#39;s and &#39;1&#39;s only */\n\t\t\t\tif (str[i] != &#39;0&#39; &amp;&amp; str[i] != &#39;1&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\t/* handle decimal radix */\n\t\telse\n\t\t&#123;\n\t\t\t/* remove useless characters */\n\t\t\twhile(str[i] != &#39;-&#39; &amp;&amp; !(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* pick up &#39;-&#39; */\n\t\t\tif(str[i] == &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = true;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tthis-&gt;negtive = false;\n\t\t\t&#125;\n\t\t\t/* remove spare &#39;0&#39;s */\n\t\t\twhile(str[i] == &#39;0&#39;)\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t&#125;\n\t\t\t/* get numbers */\n\t\t\tfor(; i &lt; len ; i++)\n\t\t\t&#123;\n\t\t\t\t/* get first dot only */\n\t\t\t\tif (!hasDot &amp;&amp; str[i] == &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\thasDot = true;\n\t\t\t\t\ttmp += &#39;.&#39;;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\t/* get all arabic numerals */\n\t\t\t\tif(!(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;))\n\t\t\t\t&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\ttmp += str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t/* if no number picked up set 0 */\n\tif(tmp == &quot;&quot;)\n\t&#123;\n\t\ttmp = &quot;0&quot;;\n\t&#125;\n\t/* add &#39;0&#39; if necessary */\n\tif (tmp[0] == &#39;.&#39;)\n\t&#123;\n\t\ttmp = &#39;0&#39; + tmp;\n\t&#125;\n\t/* mark wether the number has a dot */\n\tthis-&gt;hasDot = hasDot;\n\t/* fill corresponding number form */\n\tif (radix == 2)\n\t&#123;\n\t\tthis-&gt;binVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of binary form */\n\t\t\tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tbin2Dec();\n\t&#125;\n\telse\n\t&#123;\n\t\tthis-&gt;decVal = tmp;\n\t\tif (hasDot)\n\t\t&#123;\n\t\t\t/* store dot&#39;s index in the number string of decimal form */\n\t\t\tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n\t\t&#125;\n\t\tdec2Bin();\n\t&#125;\n\t/* have a test */\n/*\n\tstd::cout &lt;&lt; &quot;radix: 2&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;binVal &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; &quot;radix: 10&quot; &lt;&lt; std::endl;\n\tif(this-&gt;negtive)\n\t&#123;\n\t\tstd::cout &lt;&lt; &#39;-&#39;;\n\t&#125;\n\tstd::cout &lt;&lt; this-&gt;decVal &lt;&lt; std::endl;\n*/\n&#125;\n\n/*\n * name: getNum\n * arguments:\n *\tint radix: spedify a radix to find which form number is to got\n * return: the number string with specified form\n * access: public\n * Get the the number string with specified radix.\n */\n std::string Converter::getNum(int radix)\n &#123;\n \t/* check radix */\n\tif (radix != 2 &amp;&amp; radix != 10)\n\t&#123;\n\t\tstd::cerr &lt;&lt; &quot;Invalid argument: Do not support radixes beyond binary and decimal yet.\\n&quot;;\n\t\treturn NULL;\n\t&#125;\n \tstd::string tmp = &quot;&quot;;\n \t/* add the &#39;-&#39; character if necessary */\n \tif (this-&gt;negtive)\n \t&#123;\n \t\ttmp += &#39;-&#39;;\n \t&#125;\n \t/* add the binary form number */\n \tif (radix == 2)\n \t&#123;\n \t\ttmp += this-&gt;binVal;\n \t&#125;\n \t/* add the decimal form number */\n \telse\n \t&#123;\n \t\ttmp += this-&gt;decVal;\n \t&#125;\n \treturn tmp;\n &#125;\n\n/*\n * name: bin2Dec\n * access: private\n * Convert the binary number to decimal form then fill this-&gt;decVal.\n */\n void Converter::bin2Dec()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the binary number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;binDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;binVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint decLen;\n \t/* convert radix digit by digit while traversing the int part of the binary number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new binary digit into carry */\n \t\tcarry += this-&gt;binVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tdecLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 2 and add carries */\n \t\tfor(int j = decLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\ttmp[j] = tmp[j]*2+carry;\n \t\t\tif (tmp[j] &gt; 9)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/10;\n \t\t\t\t/* limit digit within 10 */\n \t\t\t\ttmp[j] %= 10;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%10)+tmp;\n \t\t\tcarry /= 10;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* get the length except the float part */\n \t\tint decIntLen = tmp.size();\n \t\t/* get the length of the whole binary number string */\n \t\tint binLen = this-&gt;binVal.size();\n \t\t/* convert radix digit by digit while traversing the float part of the binary number string */\n \t\tfor(int i = binLen-1 ; i &gt; intLen ; i--)\n \t\t&#123;\n \t\t\t/* carry to first float digit if occur a &#39;1&#39; */\n \t\t\tcarry = (this-&gt;binVal[i] == &#39;1&#39; ? 5 : 0);\n \t\t\t/* update tmp&#39;s length */\n \t\t\tdecLen = tmp.size();\n \t\t\t/* traverse tmp to divide each digit by 2 and add carries */\n \t\t\tfor(int j = decIntLen ; j &lt; decLen ; j++)\n \t\t\t&#123;\n \t\t\t\tif (tmp[j] &amp; 1)\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 5;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\ttmp[j] = tmp[j]/2 + carry;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* expand digit if necessary */\n \t\t\tif (carry)\n \t\t\t&#123;\n \t\t\t\ttmp += carry;\n \t\t\t&#125;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;decVal and this-&gt;decDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;decVal = tmp;\n \tthis-&gt;decDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n\n/*\n * name: dec2Bin\n * access: private\n * Convert the decimal number to binary form then fill this-&gt;binVal.\n */\n void Converter::dec2Bin()\n &#123;\n \t/* store number string temporarily */\n \tstd::string tmp = &quot;&quot;;\n \t/* ============== int part ============== */\n \t/* to get the int range of the decimal number string */\n \tint intLen;\n \tif (this-&gt;hasDot)\n \t&#123;\n \t\tintLen = this-&gt;decDotIndex;\n \t&#125;\n \telse\n \t&#123;\n \t\tintLen = this-&gt;decVal.size();\n \t&#125;\n \t/* may need carry while traversing digits */\n \tchar carry = 0;\n \t/* to store tmp&#39;s length */\n \tint binLen;\n \t/* convert radix digit by digit while traversing the int part of the decimal number string */\n \tfor(int i = 0 ; i &lt; intLen ; i++)\n \t&#123;\n \t\t/* add new decimal digit into carry */\n \t\tcarry += this-&gt;decVal[i]-&#39;0&#39;;\n \t\t/* update tmp&#39;s length */\n \t\tbinLen = tmp.size();\n \t\t/* traverse tmp to multiply each digit by 10 and add carries */\n \t\tfor(int j = binLen-1 ; j &gt;= 0 ; j--)\n \t\t&#123;\n \t\t\t/*\n \t\t\t * Type of tmp[] is char[] and MAX_CHAR = 127 &gt; 99.\n \t\t\t * So the assignment statement below will work safely.\n \t\t\t */\n \t\t\ttmp[j] = tmp[j]*10+carry;\n \t\t\tif (tmp[j] &gt; 1)\n \t\t\t&#123;\n \t\t\t\t/* update carry */\n \t\t\t\tcarry = tmp[j]/2;\n \t\t\t\t/* limit digit within 2 */\n \t\t\t\ttmp[j] &amp;= 1;\n \t\t\t&#125;\n \t\t\telse\n \t\t\t&#123;\n\t\t\t\tcarry = 0;\n \t\t\t&#125;\n \t\t&#125;\n \t\t/* expand digits if necessary */\n \t\twhile(carry)\n \t\t&#123;\n \t\t\ttmp = char(carry%2)+tmp;\n \t\t\tcarry /= 2;\n \t\t&#125;\n \t&#125;\n \t/* ============= part end ============== */\n \t/* add &#39;0&#39; if need */\n \tif (tmp == &quot;&quot;)\n \t&#123;\n \t\ttmp += (char)0;\n \t&#125;\n \t/* ============= float part ============== */\n \t/* if there is a float part */\n\tif (this-&gt;hasDot)\n \t&#123;\n \t\t/* add the dot to the number string */\n \t\ttmp += &#39;.&#39;;\n \t\t/* may need carry while traversing digits */\n \t\tcarry = 0;\n \t\t/* get the length of the whole decimal number string */\n \t\tint decLen = this-&gt;decVal.size();\n \t\t/* get the length of the float part of the decimal number string */\n \t\tint floatLen = decLen-intLen-1;\n \t\t/* get a copy of the float part of the decimal number string */\n \t\tstd::string tmp2 = this-&gt;decVal.substr(intLen+1, floatLen);\n \t\t/* adjust tmp2 to prepare for algorithm below */\n \t\tfor(int i = 0 ; i &lt; floatLen ; i++)\n \t\t&#123;\n \t\t\ttmp2[i] -= &#39;0&#39;;\n \t\t&#125;\n \t\t/*\n \t\t * asume:   B = b1*2^-1 + b2*2^-2 + b3*2^-3 + ...\n \t\t *            2*B = b1 + b2*2^-1 + b3*2^-2 + ... \t// take b1 as first digit\n \t\t * 2*(2*B-b1) = b2 + b3*2^-1 + ... \t\t// take b2 as second digit\n \t\t * \t\t...\n \t\t * so the binary float will got digit by digit in order\n \t\t */\n \t\tfor(int i = 0 ; i &lt; this-&gt;binFloatPrecision ; i++)\n \t\t&#123;\n \t\t\t/* traverse tmp2 to multiply each digit by 2 and add carries */\n \t\t\tfor(int j = floatLen-1 ; j &gt;= 0 ; j--)\n \t\t\t&#123;\n \t\t\t\ttmp2[j] = tmp2[j]*2+carry;\n \t\t\t\tif (tmp2[j] &gt; 9)\n \t\t\t\t&#123;\n \t\t\t\t\t/* update carry */\n \t\t\t\t\tcarry = tmp2[j]/10;\n \t\t\t\t\t/* limit digit within 10 */\n \t\t\t\t\ttmp2[j] %= 10;\n \t\t\t\t&#125;\n \t\t\t\telse\n \t\t\t\t&#123;\n \t\t\t\t\tcarry = 0;\n \t\t\t\t&#125;\n \t\t\t&#125;\n \t\t\t/* get the last carry as new digit of binary float */\n \t\t\ttmp += carry;\n \t\t\t/* reset carry */\n \t\t\tcarry = 0;\n \t\t&#125;\n \t&#125;\n \t/* ============== part end =============== */\n \t/* adjust string and fill this-&gt;binVal and this-&gt;binDotIndex */\n \tfor(int i = 0 ; i &lt; tmp.size() ; i++)\n \t&#123;\n \t\tif (tmp[i] == &#39;.&#39;)\n \t\t&#123;\n \t\t\tcontinue;\n \t\t&#125;\n \t\ttmp[i] += &#39;0&#39;;\n \t&#125;\n \tthis-&gt;binVal = tmp;\n \tthis-&gt;binDotIndex = tmp.find(&#39;.&#39;);\n &#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; test.cpp:</p>\n<pre><code class=\"hljs\">#include &quot;converter.h&quot;\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\t//Converter c(&quot;0.625&quot;, 10);\n\tConverter c(&quot;ujsgdfksagrua0.10100000000000000000&quot;, 2);\n\tcout &lt;&lt; c.getNum(10) &lt;&lt; endl;\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 都过500行了，会不会写得有点啰嗦？</p>\n",
            "tags": [
                "C++",
                "进制转换"
            ]
        },
        {
            "id": "https://bipedalbit.net/2015/10/08/C-cin%E3%80%81cout%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%84/",
            "url": "https://bipedalbit.net/2015/10/08/C-cin%E3%80%81cout%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%84/",
            "title": "C++ cin、cout的优化及测评",
            "date_published": "2015-10-08T11:56:46.000Z",
            "content_html": "<p>&nbsp;&nbsp;&nbsp; 参加过ACM比赛和部分自己做过测评的人想必不难发现，C++的cin和cout虽然比起C的scanf和printf来方便很多，但是速度似乎会打很大折扣。于是不求甚解的人们一拍脑门，认定因为C更“底层”，封装程度更低，所以势必比C++的输入输出执行效率更高。然而如若C++有知，恐怕要苦笑了。因为C++正是为了兼容C的输入输出才要在cin、cout中进行指针同步，降低了执行效率。那么可能挽回这种效率损失吗？答案是可以。</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp; C++中提供了解除指针同步的方法：<code>ios::sync_with_stdio(false)</code>。如字面意思，这个方法用来设置输入输出流是否与C的stdio同步。那么解除同步之后能有多大效果呢？毕竟C++确实因为封装程度比C高多多少少损失了一些执行效率。我动手进行了一系列测评，下面是源码。</p>\n<p>&nbsp;&nbsp;&nbsp; 这里我统一对输入输出做了重定向，不论是输入数据来源还是输入数据目标都是“data”文件。所有的输入&#x2F;输出测试都是读或写10^7次字符串与整型数的组合数据，每种输入&#x2F;输出测试都进行10次并取平均耗时作为评估值。</p>\n<p>&nbsp;&nbsp;&nbsp; 首先是C的输入输出。</p>\n<p>&nbsp;&nbsp;&nbsp; scanf.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tfreopen(&quot;data&quot;, &quot;r&quot;, stdin);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tchar s[20];\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tscanf(&quot;%s&quot;, s);\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tprintf(&quot;average cost: %lfs\\n&quot;, t_sum/testCnt);\n\tfclose(stdin);\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; printf.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tfreopen(&quot;data&quot;, &quot;w&quot;, stdout);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;string%d\\n&quot;, i);\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tprintf(&quot;average cost: %lfs\\n&quot;, t_sum/testCnt);\n\tfclose(stdout);\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 然后是不解锁同步的cin、cout方法。</p>\n<p>&nbsp;&nbsp;&nbsp; cin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tifstream fin(&quot;data&quot;);\n\tstreambuf *_cin =  cin.rdbuf(fin.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcin.rdbuf(_cin);\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; cout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tofstream fout(&quot;data&quot;);\n\tstreambuf *_cout =  cout.rdbuf(fout.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcout.rdbuf(_cout);\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 接下来是解锁同步的cin、cout方法。</p>\n<p>&nbsp;&nbsp;&nbsp; optimized_cin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tios::sync_with_stdio(false);\n\tifstream fin(&quot;data&quot;);\n\tstreambuf *_cin =  cin.rdbuf(fin.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcin.rdbuf(_cin);\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; optimized_cout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tios::sync_with_stdio(false);\n\tofstream fout(&quot;data&quot;);\n\tstreambuf *_cout =  cout.rdbuf(fout.rdbuf());\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tcout.rdbuf(_cout);\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 同时测试C++直接读写文件的方法。</p>\n<p>&nbsp;&nbsp;&nbsp; fin.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tifstream fin(&quot;data&quot;);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tstring s;\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tfin &gt;&gt; s;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tfin.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; fout.cpp:</p>\n<pre><code class=\"hljs\">#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint testCnt = 10;\n\tint caseCnt = 10000000;\n\tdouble t_sum = 0;\n\tofstream fout(&quot;data&quot;);\n\tfor(int j = 0 ; j &lt; testCnt ; j++)\n\t&#123;\n\t\tlong t_start = clock();\n\t\tfor(int i = 0 ; i &lt; caseCnt ; i++)\n\t\t&#123;\n\t\t\tfout &lt;&lt; &quot;string&quot; &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n\t\t&#125;\n\t\tlong t_end = clock();\n\t\tt_sum += (double)(t_end - t_start) / CLOCKS_PER_SEC;\n\t&#125;\n\tcout &lt;&lt; &quot;average cost: &quot; &lt;&lt; t_sum/testCnt &lt;&lt; &quot;s\\n&quot;;\n\tfout.close();\n\treturn 0;\n&#125;\n</code></pre>\n<p>&nbsp;&nbsp;&nbsp; 下面是测试结果：</p>\n<table><tr><th></th><th>scanf与printf</th><th>cin与cout</th><th>优化的cin与cout</th>\t<th>fin与fout</th></tr><tr><td>输入</td><td>1.125694s</td><td>2.46949s</td><td>0.950055s</td><td>0.834976s</td></tr><tr><td>输出</td><td>1.304706s</td><td>1.46059s</td><td>1.41783s</td><td>1.41298s</td></tr></table>\n\n<p>&nbsp;&nbsp;&nbsp; 可以看到，事实上，解开同步之前，cin耗时是scanf的两倍还多，cout则比printf略慢。解开枷锁的cin执行效率与直接读文件接近，甚至比C的scanf还要快。至于输出，解开同步的cout执行效率略有提高，同样接近直接写文件，但是确实还是比C的printf略慢一点。</p>\n",
            "tags": [
                "C++",
                "cin",
                "cout",
                "scanf",
                "printf"
            ]
        }
    ]
}