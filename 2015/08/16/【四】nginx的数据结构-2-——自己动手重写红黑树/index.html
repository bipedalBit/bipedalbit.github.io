

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bipedal Bit">
  <meta name="keywords" content="">
  
    <meta name="description" content="&nbsp;&nbsp;&nbsp; 不管看了多少遍有多滚瓜烂熟，数据结构或者算法的代码如果不亲自码一遍，我总是不敢说自己懂了。这次就来自己动手重写红黑树。">
<meta property="og:type" content="article">
<meta property="og:title" content="【四】nginx的数据结构(2)——自己动手重写红黑树">
<meta property="og:url" content="https://bipedalbit.net/2015/08/16/%E3%80%90%E5%9B%9B%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91/index.html">
<meta property="og:site_name" content="Hacking to the gate!">
<meta property="og:description" content="&nbsp;&nbsp;&nbsp; 不管看了多少遍有多滚瓜烂熟，数据结构或者算法的代码如果不亲自码一遍，我总是不敢说自己懂了。这次就来自己动手重写红黑树。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.blog.csdn.net/20150816200143108">
<meta property="og:image" content="http://img.blog.csdn.net/20150816200200052">
<meta property="article:published_time" content="2015-08-16T14:06:30.000Z">
<meta property="article:modified_time" content="2025-05-21T15:42:53.538Z">
<meta property="article:author" content="Bipedal Bit">
<meta property="article:tag" content="nginx">
<meta property="article:tag" content="rbtree">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://img.blog.csdn.net/20150816200143108">
  
  
  
  <title>【四】nginx的数据结构(2)——自己动手重写红黑树 - Hacking to the gate!</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bipedalbit.net","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hacking to the gate!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.minio.bipedalbit.net/bipedalbit-net-images/banner/125633249_p0_resize.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【四】nginx的数据结构(2)——自己动手重写红黑树"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2015-08-16 22:06" pubdate>
          2015年8月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          20 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【四】nginx的数据结构(2)——自己动手重写红黑树</h1>
            
            
              <div class="markdown-body">
                
                <p>&nbsp;&nbsp;&nbsp; 不管看了多少遍有多滚瓜烂熟，数据结构或者算法的代码如果不亲自码一遍，我总是不敢说自己懂了。这次就来自己动手重写红黑树。</p>
<span id="more"></span>
<p>&nbsp;&nbsp;&nbsp; 费话不多说，上重写代码，这次姑且用英语写的注释当复习英语了。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>
<pre><code class="hljs">/*
 * Copyright (C) Bipedal Bit
 * Verson 1.0.0.1
 */

#ifndef _RBTREE_H_INCLUDED_
#define _RBTREE_H_INCLUDED_

/* the node structure of the red-black tree */
typedef struct rbtree_node_s rbtree_node_t;
/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */
typedef int rbtree_key_t;
/* Abstract type is complicated to achieve with C so I use char* instead. */
typedef char* rbtree_data_t;

struct rbtree_node_s
&#123;
    /* key of the node */
    rbtree_key_t    key;
    /* pointer of the parent of the node */
    rbtree_node_t*  parent;
    /* pointer of the left kid of the node */
    rbtree_node_t*  left;
    /* pointer of the right kid of the node */
    rbtree_node_t*  right;
    /* color of the node */
    unsigned char   color;
    /* pointer of the value of the node corresponding to the key */
    rbtree_data_t   value;
&#125;;

/* the tree object stucture of the red-black tree */
typedef struct rbtree_s rbtree_t;
/* foundational insert function pointer*/
typedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);

struct rbtree_s
&#123;
    /* the pointer of the root node of the tree */
    rbtree_node_t* root;
    /* black leaf nodes as sentinel */
    rbtree_node_t* sentinel;
    /* the polymorphic insert function pointer */
    rbtree_insert_p insert;
&#125;;

/* macros */
#define rbtree_init(tree, s, i)     \
rbtree_sentinel_init(s);            \
(tree)-&gt;root = s;               \
(tree)-&gt;sentinel = s;           \
(tree)-&gt;insert = i

#define rbtree_red(node)    ((node)-&gt;color = 1)
#define rbtree_black(node)  ((node)-&gt;color = 0)
#define rbtree_is_red(node) ((node)-&gt;color)
#define rbtree_is_black(node)   (!rbtree_is_red(node))
 /* copy n2&#39;s color to n1 */
#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)
/* sentinel must be black cuz it&#39;s leaf node */
#define rbtree_sentinel_init(node)  rbtree_black(node)

/* statements of public methods */
void rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);
void rbtree_insert(rbtree_t* tree, rbtree_node_t* node);
void rbtree_delete(rbtree_t* tree, rbtree_node_t* node);
rbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);

#endif  /* _RBTREE_H_INCLUDED_ */
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 看过nginx源码的有心人会发现，我的头文件相对于ngx_rbree.h改动不大，非常像。<br>&nbsp;&nbsp;&nbsp; 关键的rbtree.c：</p>
<pre><code class="hljs">/*
 * Copyright (C) Bipedal Bit
 * Verson 1.0.0.1
 */

#include &lt;stddef.h&gt;
#include &quot;rbtree.h&quot;

/* inline methods */
/* get the node with the minimum key in a subtree of the red-black tree */
static inline rbtree_node_t*
rbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)
&#123;
    while(node-&gt;left != sentinel)
    &#123;
        node = node-&gt;left;
    &#125;

    return node;
&#125;

/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */
static inline void rbtree_replace(rbtree_t* tree,
    rbtree_node_t* node, rbtree_node_t* tmp)
&#123;
    /* upward: p[node] &lt;- p[tmp] */
    tmp-&gt;parent = node-&gt;parent;

    if (node == tree-&gt;root)
    &#123;
        tree-&gt;root = tmp;
    &#125;
    else if (node == node-&gt;parent-&gt;left)
    &#123;
        /* downward: left[p[node]] &lt;- tmp */
        node-&gt;parent-&gt;left = tmp;
    &#125;
    else
    &#123;
        /* downward: right[p[node]] &lt;- tmp */
        node-&gt;parent-&gt;right = tmp;
    &#125;

    node-&gt;parent = tmp;
&#125;

/* change the topologic structure of the tree keeping the order of the nodes */
static inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)
&#123;
    /* node as the var x in CLRS while tmp as the var y */
    rbtree_node_t* tmp = node-&gt;right;

    /* replace y with left[y] */
    /* downward: right[x] &lt;- left[y] */
    node-&gt;right = tmp-&gt;left;
    /* if left[[y] is not NIL it has a parent */
    if (tmp-&gt;left != tree-&gt;sentinel)
    &#123;
        /* upward: p[left[y]] &lt;- x */
        tmp-&gt;left-&gt;parent = node;
    &#125;

    /* replace x with y */
    rbtree_replace(tree, node, tmp);
    tmp-&gt;left = node;
&#125;

static inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* tmp = node-&gt;left;

    /* replace y with right[y] */
    node-&gt;left = tmp-&gt;right;
    if (tmp-&gt;right != tree-&gt;sentinel)
    &#123;
        tmp-&gt;right-&gt;parent = node;
    &#125;

    /* replace x with y */
    rbtree_replace(tree, node, tmp);
    tmp-&gt;right = node;
&#125;

/* static methods */
/* fix the red-black tree after the new node inserted */
static void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)
&#123;
    while(rbtree_is_red(node-&gt;parent))
    &#123;
        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)
        &#123;
            /* case 1: node&#39;s uncle is red */
            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))
            &#123;
                rbtree_black(node-&gt;parent);
                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);
                rbtree_red(node-&gt;parent-&gt;parent);
                node = node-&gt;parent-&gt;parent;
                /* Then we can consider the whole subtree */
                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */
                /* and keep looping till &quot;node&quot; become the root. */
            &#125;
            /* case 2: node&#39;s uncle is black */
            else
            &#123;
                /* ensure node is the left kid of its parent */
                if (node == node-&gt;parent-&gt;right)
                &#123;
                    node = node-&gt;parent;
                    rbtree_left_rotate(tree, node);
                &#125;
                /* case 2 -&gt; case 1 */
                rbtree_black(node-&gt;parent);
                rbtree_red(node-&gt;parent-&gt;parent);
                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);
            &#125;
        &#125;
        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */
        else
        &#123;
            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))
            &#123;
                rbtree_black(node-&gt;parent);
                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);
                rbtree_red(node-&gt;parent-&gt;parent);
                node = node-&gt;parent-&gt;parent;
            &#125;
            else
            &#123;
                if (node == node-&gt;parent-&gt;left)
                &#123;
                    node = node-&gt;parent;
                    rbtree_right_rotate(tree, node);
                &#125;
                rbtree_black(node-&gt;parent);
                rbtree_red(node-&gt;parent-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);
            &#125;
        &#125;
    &#125;
    /* ensure the root node being black */
    rbtree_black(tree-&gt;root);
&#125;

static void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* brother = NULL;

    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))
    &#123;
        if (node == node-&gt;parent-&gt;left)
        &#123;
            brother = node-&gt;parent-&gt;right;
            if (rbtree_is_red(brother))
            &#123;
                rbtree_black(brother);
                rbtree_red(node-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent);
                /* update brother after topologic change of the tree */
                brother = node-&gt;parent-&gt;right;
            &#125;

            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))
            &#123;
                rbtree_red(brother);
                /* go upward and keep on fixing color */
                node = node-&gt;parent;
            &#125;
            else
            &#123;
                if (rbtree_is_black(brother-&gt;right))
                &#123;
                    rbtree_black(brother-&gt;left);
                    rbtree_red(brother);
                    rbtree_right_rotate(tree, brother);
                    /* update brother after topologic change of the tree */
                    brother = node-&gt;parent-&gt;right;
                &#125;
                rbtree_copy_color(brother, node-&gt;parent);
                rbtree_black(node-&gt;parent);
                rbtree_black(brother-&gt;right);
                rbtree_left_rotate(tree, node-&gt;parent);
                /* end the loop and ensure root is black */
                node = tree-&gt;root;
            &#125;
        &#125;
        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */
        else
        &#123;
            brother = node-&gt;parent-&gt;left;
            if (rbtree_is_red(brother))
            &#123;
                rbtree_black(brother);
                rbtree_red(node-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent);
                brother = node-&gt;parent-&gt;left;
            &#125;

            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))
            &#123;
                rbtree_red(brother);
                node = node-&gt;parent;
            &#125;
            else
            &#123;
                if (rbtree_is_black(brother-&gt;left))
                &#123;
                    rbtree_black(brother-&gt;right);
                    rbtree_red(brother);
                    rbtree_right_rotate(tree, brother);
                    brother = node-&gt;parent-&gt;left;
                &#125;
                rbtree_copy_color(brother, node-&gt;parent);
                rbtree_black(node-&gt;parent);
                rbtree_black(brother-&gt;left);
                rbtree_left_rotate(tree, node-&gt;parent);
                node = tree-&gt;root;
            &#125;
        &#125;
    &#125;

    rbtree_black(node);
&#125;

/* public methods */
void rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)
&#123;
    /* Using ** to know wether the new node will be a left kid */
    /* or a right kid of its parent node. */
    rbtree_node_t** tmp = &amp;tree-&gt;root;
    rbtree_node_t* parent;

    while(*tmp != tree-&gt;sentinel)
    &#123;
        parent = *tmp;
        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;
    &#125;

    /* The pointer knows wether the node should be on the left side */
    /* or on the right one. */
    *tmp = node;
    node-&gt;parent = parent;
    node-&gt;left = tree-&gt;sentinel;
    node-&gt;right = tree-&gt;sentinel;
    rbtree_red(node);
&#125;

void rbtree_insert(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* sentinel = tree-&gt;sentinel;

    /* if the tree is empty */
    if (tree-&gt;root == sentinel)
    &#123;
        tree-&gt;root = node;
        node-&gt;parent = sentinel;
        node-&gt;left = sentinel;
        node-&gt;right = sentinel;
        rbtree_black(node);

        return;
    &#125;

    /* generally */
    tree-&gt;insert(tree, node);
    rbtree_insert_fixup(tree, node);
&#125;

void rbtree_delete(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* sentinel = tree-&gt;sentinel;
    /* wether &quot;node&quot; is on the left side or the right one */
    rbtree_node_t** ptr_to_node = NULL;
    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */
    rbtree_node_t* cover = NULL;
    /* wether we lossing a red node on the edge of the tree */
    int loss_red = rbtree_is_red(node);
    int is_root = (node == tree-&gt;root);

    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */
    /* sentinel in &quot;node&quot;&#39;s kids */
    if (node-&gt;left == sentinel)
    &#123;
        cover = node-&gt;right;
    &#125;
    else if (node-&gt;right == sentinel)
    &#123;
        cover = node-&gt;left;
    &#125;
    /* &quot;node&quot;&#39;s kids are both non-sentinel */
    else
    &#123;
        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */
        cover = rbtree_subtree_min(node-&gt;right, sentinel);
        node-&gt;key = cover-&gt;key;
        node-&gt;value = cover-&gt;value;
        node = cover;
        loss_red = rbtree_is_red(node);
        is_root = 0;
        /* move &quot;cover&quot;&#39;s kids */
        /* &quot;cover&quot; can only be a left kid */
        /* and can only have a right non-sentinel kid */
        /* because of function &quot;rbtree_subtree_min&quot; */
        cover = node-&gt;right;
    &#125;

    if (is_root)
    &#123;
        /* update root */
        tree-&gt;root = cover;
    &#125;
    else
    &#123;
        /* downward link */
        if (node == node-&gt;parent-&gt;left)
        &#123;
            node-&gt;parent-&gt;left = cover;
        &#125;
        else
        &#123;
            node-&gt;parent-&gt;right = cover;
        &#125;
    &#125;
    /* upward link */
    cover-&gt;parent = node-&gt;parent;
    /* &quot;cover&quot; may be a sentinel */
    if (cover != sentinel)
    &#123;
        /* set &quot;cover&quot; */
        cover-&gt;left = node-&gt;left;
        cover-&gt;right = node-&gt;right;
        rbtree_copy_color(cover, node);
    &#125;

    /* clear &quot;node&quot; since it&#39;s useless */
    node-&gt;key = -1;
    node-&gt;parent = NULL;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    node-&gt;value = NULL;

    if (loss_red)
    &#123;
        return;
    &#125;

    /* When lossing a black node on edge */
    /* the fifth rule of red-black tree will be broke. */
    /* So the tree need to be fixed. */
    rbtree_delete_fixup(tree, cover);
&#125;

/* find the node in the tree corresponding to the given key value */
rbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)
&#123;
    rbtree_node_t* tmp = tree-&gt;root;
    int step_cnt = 0;

    /* search the binary tree */
    while(tmp != tree-&gt;sentinel)
    &#123;
        /* next line is just fot test */
        // step_cnt++;
        if(key == tmp-&gt;key)
        &#123;
            /* next line is just for test */
            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);
            return tmp;
        &#125;

        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;
    &#125;

    return NULL;
&#125;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;  虽然明白nginx源码中100+行的长函数体也是一种避免太多函数调用增加时间空间开销的优化，我还是把所有函数都分类分割成100行以下。增加可读性是一方面，可能也是有点强迫症吧。之后会扩展几个统计方法，像max、min和mid，还会扩展一个遍历方法。<br>&nbsp;&nbsp;&nbsp; 下面是调用测试，test.c：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &quot;rbtree.h&quot;

int main(int argc, char const *argv[])
&#123;
    rbtree_t t = &#123;&#125;;
    rbtree_node_t s = &#123;&#125;;
    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);

    const int cnt = 10;
    const int max_len = 15;

#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;

    /* for gcc */
    char* v[] = TEST_VALUES;
    /* for g++ */
    // char v[][max_len] = TEST_VALUES;

    rbtree_node_t n[cnt];
    int i;
    for (i = 0; i &lt; cnt; i++)
    &#123;
        n[i].key = i+1;
        n[i].value = v[i];
        rbtree_insert(&amp;t, &amp;n[i]);
    &#125;

    rbtree_node_t* p[cnt];

    for (i = 1; i &lt;= cnt; i++)
    &#123;
        printf(&quot;key: %d\n&quot;, i);
        p[i] = rbtree_find(&amp;t, i);
        printf(&quot;value: %s\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);
    &#125;

    rbtree_delete(&amp;t, &amp;n[5]);

    printf(&quot;\nafter delete 6-&gt;mango:\n\n&quot;);

    for (i = 1; i &lt;= cnt; i++)
    &#123;
        printf(&quot;key: %d\n&quot;, i);
        p[i] = rbtree_find(&amp;t, i);
        printf(&quot;value: %s\n&quot;, (p[i] != NULL) ? p[i]-&gt;value : &quot;?&quot;);
    &#125;

    return 0;
&#125;
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 解开rbtree_find方法里的测试行注释，顺利执行：</p>
<pre><code class="hljs">key: 1
step count: 3, color: black, value: apple
key: 2
step count: 2, color: black, value: banana
key: 3
step count: 3, color: black, value: cherry
key: 4
step count: 1, color: black, value: grape
key: 5
step count: 3, color: black, value: lemon
key: 6
step count: 2, color: black, value: mango
key: 7
step count: 4, color: black, value: pear
key: 8
step count: 3, color: red, value: pineapple
key: 9
step count: 4, color: black, value: strawberry
key: 10
step count: 5, color: red, value: watermelon

after delete 6-&gt;mango:

key: 1
step count: 3, color: black, value: apple
key: 2
step count: 2, color: black, value: banana
key: 3
step count: 3, color: black, value: cherry
key: 4
step count: 1, color: black, value: grape
key: 5
step count: 3, color: black, value: lemon
key: 6
value: ?
key: 7
step count: 2, color: black, value: pear
key: 8
step count: 4, color: black, value: pineapple
key: 9
step count: 3, color: red, value: strawberry
key: 10
step count: 4, color: black, value: watermelon
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 下面分别是删除6-&gt;mango前的红黑树和删除后的红黑树示意图：<br><img src="http://img.blog.csdn.net/20150816200143108" srcset="/img/loading.gif" lazyload alt="" height="422" width="400" /><br><img src="http://img.blog.csdn.net/20150816200200052" srcset="/img/loading.gif" lazyload alt="" height="331" width="400" /><br>&nbsp;&nbsp;&nbsp; 下面我们来做个大量数据的压力测试，注意把rbtree_find方法里的测试行注释掉，不然后果恐怕会比较吓人：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &quot;rbtree.h&quot;

int main(int argc, char const *argv[])
&#123;
    double duration;
    double room;

    rbtree_t t = &#123;&#125;;
    rbtree_node_t s = &#123;&#125;;
    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);

    const int cnt = 1&lt;&lt;20;
    const int max_len = 15;

#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;

    /* for gcc */
    char* v[] = TEST_VALUES;
    /* for g++ */
    // char v[][max_len] = TEST_VALUES;

    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */
    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */
    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));
    int i;

    long time1 = clock();

    for (i = 0; i &lt; cnt; i++)
    &#123;
        n[i].key = i+1;
        n[i].value = v[i%10];
        rbtree_insert(&amp;t, &amp;n[i]);
    &#125;

    long time2 = clock();
    room = 48.0*cnt/(1&lt;&lt;20);
    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;
    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\n&quot;, cnt, room, duration);

    const int search_cnt = 1&lt;&lt;10;
    srand( (unsigned int)time(0) );
    for( i = 0 ; i &lt; search_cnt ; i++ )
    &#123;
        rbtree_find(&amp;t, (rand()%cnt)+1);
    &#125;

    long time3 = clock();
    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;
    printf(&quot;Searching %d nodes among %d spends %f seconds.\n&quot;, search_cnt, cnt, duration);

    const int delete_cnt = 1&lt;&lt;10;
    int nums[delete_cnt];
    int num;
    /* Let&#39;s hash! */
    char* mark = (char*)calloc(cnt, sizeof(char));
    memset(mark, 0, cnt*sizeof(char));
    for(i = 0; i &lt; delete_cnt; i++)
    &#123;
        for(;;)
        &#123;
            num = rand()%cnt;
            if (mark[num] == 0)
            &#123;
                mark[num] = 1;
                nums[i] = num;
                break;
            &#125;
        &#125;
    &#125;

    long time4 = clock();
    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;
    printf(&quot;Hash %d times spends %f seconds.\n&quot;, delete_cnt, duration);

    for(i = 0; i &lt; delete_cnt; i++)
    &#123;
        rbtree_delete(&amp;t, &amp;n[nums[i]]);
    &#125;

    long time5 = clock();
    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;
    printf(&quot;Deleting %d nodes among %d spends %f seconds.\n&quot;, delete_cnt, cnt, duration);
    free(mark);
    free(n);

    return 0;
&#125;
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 来看看结果：</p>
<pre><code class="hljs">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.
Searching 1024 nodes among 1048576 spends 0.001140 seconds.
Hash 1024 times spends 0.000334 seconds.
Deleting 1024 nodes among 1048576 spends 0.000783 seconds.
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 删除比查找还快，耗时只有哈希查找的两倍多点，上百万的插入也耗时不足半秒，嗯我还挺满意的。<br>&nbsp;&nbsp;&nbsp; 写统计和遍历方法去了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/nginx/" class="category-chain-item">nginx</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/nginx/" class="print-no-link">#nginx</a>
      
        <a href="/tags/rbtree/" class="print-no-link">#rbtree</a>
      
        <a href="/tags/C/" class="print-no-link">#C</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【四】nginx的数据结构(2)——自己动手重写红黑树</div>
      <div>https://bipedalbit.net/2015/08/16/【四】nginx的数据结构-2-——自己动手重写红黑树/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bipedal Bit</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2015年8月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/" title="Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2015/08/11/C%E8%AF%AD%E8%A8%80%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/" title="C语言的static关键字">
                        <span class="hidden-mobile">C语言的static关键字</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline.bipedalbit.net","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <div style="text-align: center;">
  当前页面浏览量: <span class="waline-pageview-count"></span>
</div>
<script type="module">
  import { pageviewCount } from 'https://unpkg.com/@waline/client@v3/dist/pageview.js';

  pageviewCount({
    serverURL: 'https://comment-plugin.bipedalbit.net/',
    path: window.location.pathname,
    // 可选配置项
    // selector: 'waline-pageview-count',
    // update: true,
  });

  // 等待数据加载完成，检查 span 内容是否为空
  setTimeout(() => {
    const span = document.querySelector('.waline-pageview-count');
    if (!span.textContent.trim()) {
      span.textContent = '1';
    }
  }, 1000); // 1秒后执行，确保数据加载完成
</script>

        </div>
      </div>
    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d = OML2D.loadOml2d({libraryUrls:{"complete":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/complete.js","cubism2":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism2.js","cubism5":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js"},mobileDisplay:true,models:[{"path":"https://cdn.minio.bipedalbit.net/bipedalbit-net-images/live2d-model/HK416-2-destroy/model.json","mobilePosition":[0,-45],"mobileScale":0.06,"mobileStageStyle":{"width":200,"height":240},"motionPreloadStrategy":"IDLE","position":[0,-60],"scale":0.08,"stageStyle":{"width":250,"height":300}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":200,"height":80,"left":"calc(50% - 10px)","top":"-100px"},mobileStyle: {"width":180,"height":60,"left":"calc(50% - 5px)","top":"-100px"},idleTips:{interval:30000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
,wordTheDay:true}}});</script><!-- hexo injector body_end end --></body>
</html>
