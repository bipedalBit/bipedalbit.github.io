

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bipedal Bit">
  <meta name="keywords" content="">
  
    <meta name="description" content="&nbsp;&nbsp;&nbsp; 基础版的红黑树写完之后总觉得有些辅助功能不补充一下就难以体现红黑树在统计方面的优越性，于是我又写了红黑树扩展版。">
<meta property="og:type" content="article">
<meta property="og:title" content="【五】nginx的数据结构(3)——扩展红黑树">
<meta property="og:url" content="https://bipedalbit.net/2015/08/18/%E3%80%90%E4%BA%94%E3%80%91nginx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E7%BA%A2%E9%BB%91%E6%A0%91/index.html">
<meta property="og:site_name" content="Hacking to the gate!">
<meta property="og:description" content="&nbsp;&nbsp;&nbsp; 基础版的红黑树写完之后总觉得有些辅助功能不补充一下就难以体现红黑树在统计方面的优越性，于是我又写了红黑树扩展版。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2015-08-17T18:04:43.000Z">
<meta property="article:modified_time" content="2025-05-21T15:42:53.545Z">
<meta property="article:author" content="Bipedal Bit">
<meta property="article:tag" content="nginx">
<meta property="article:tag" content="rbtree">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>【五】nginx的数据结构(3)——扩展红黑树 - Hacking to the gate!</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bipedalbit.net","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hacking to the gate!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.minio.bipedalbit.net/bipedalbit-net-images/banner/125633249_p0_resize.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【五】nginx的数据结构(3)——扩展红黑树"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2015-08-18 02:04" pubdate>
          2015年8月18日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          21 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【五】nginx的数据结构(3)——扩展红黑树</h1>
            
            
              <div class="markdown-body">
                
                <p>&nbsp;&nbsp;&nbsp; 基础版的红黑树写完之后总觉得有些辅助功能不补充一下就难以体现红黑树在统计方面的优越性，于是我又写了红黑树扩展版。</p>
<span id="more"></span>
<p>&nbsp;&nbsp;&nbsp; 发扬我一贯的支线任务狂魔的作风，一晚上就完成了之前设想的红黑树扩展版本。<br>&nbsp;&nbsp;&nbsp; rbtree.h：</p>
<pre><code class="hljs">/*
 * Copyright (C) Bipedal Bit
 * Verson 1.0.0.2
 */

#ifndef _RBTREE_H_INCLUDED_
#define _RBTREE_H_INCLUDED_

/* the node structure of the red-black tree */
typedef struct rbtree_node_s rbtree_node_t;
/* Using type int means its range is -0x7fffffff-1~0x7fffffff. */
typedef int rbtree_key_t;
/* Abstract type is complicated to achieve with C so I use char* instead. */
typedef char* rbtree_data_t;

struct rbtree_node_s
&#123;
    /* key of the node */
    rbtree_key_t    key;
    /* pointer of the parent of the node */
    rbtree_node_t*  parent;
    /* pointer of the left kid of the node */
    rbtree_node_t*  left;
    /* pointer of the right kid of the node */
    rbtree_node_t*  right;
    /* color of the node */
    unsigned char   color;
    /* pointer of the value of the node corresponding to the key */
    rbtree_data_t   value;
    /* count of nodes in the subtree whose root is the current node */
    int node_cnt;
&#125;;

/* the tree object stucture of the red-black tree */
typedef struct rbtree_s rbtree_t;
/* foundational insert function pointer */
typedef void (*rbtree_insert_p) (rbtree_t* root, rbtree_node_t* node);
/* foundational visit function pointer */
typedef void (*rbtree_visit_p) (rbtree_node_t* node);

struct rbtree_s
&#123;
    /* the pointer of the root node of the tree */
    rbtree_node_t* root;
    /* black leaf nodes as sentinel */
    rbtree_node_t* sentinel;
    /* the polymorphic insert function pointer */
    rbtree_insert_p insert;
&#125;;

/* macros */
#define rbtree_init(tree, s, i)     \
rbtree_sentinel_init(s);            \
(tree)-&gt;root = s;               \
(tree)-&gt;sentinel = s;           \
(tree)-&gt;insert = i

#define rbtree_red(node)    ((node)-&gt;color = 1)
#define rbtree_black(node)  ((node)-&gt;color = 0)
#define rbtree_is_red(node) ((node)-&gt;color)
#define rbtree_is_black(node)   (!rbtree_is_red(node))
 /* copy n2&#39;s color to n1 */
#define rbtree_copy_color(n1, n2)   (n1-&gt;color = n2-&gt;color)
/* sentinel must be black cuz it&#39;s leaf node */
#define rbtree_sentinel_init(node)  \
rbtree_black(node);         \
(node)-&gt;node_cnt = 0

/* statements of public methods */
void rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node);
void rbtree_insert(rbtree_t* tree, rbtree_node_t* node);
void rbtree_delete(rbtree_t* tree, rbtree_node_t* node);
/* get node by key */
rbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key);
/* get node by order number */
rbtree_node_t* rbtree_index(rbtree_t* tree, int index);
int rbtree_height(rbtree_t* tree, rbtree_node_t* node);
int rbtree_count(rbtree_t* tree);
void rbtree_visit(rbtree_node_t* node);
void rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p);

#endif  /* _RBTREE_H_INCLUDED_ */
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 可以看到，我增加了按序号查找结点、求树高、求结点数、可重写访问节点方法的遍历，这么几个功能。<br>&nbsp;&nbsp;&nbsp; 为了提高按序号查找结点的效率，我增加了一个结点项node_cnt，代表当前结点为根的子树上的结点总数。这样按序号查找结点的过程将是一个二分查找，时间效率与按key查找相同，都是O(log2n)。<br>&nbsp;&nbsp;&nbsp; 遍历方法使用递归的中序遍历，默认的结点访问方法是个空方法，用户可以自行重写。<br>&nbsp;&nbsp;&nbsp; rbtree.c：</p>
<pre><code class="hljs">/*
 * Copyright (C) Bipedal Bit
 * Verson 1.0.0.2
 */

#include &lt;stddef.h&gt;
#include &quot;rbtree.h&quot;

/* inline methods */
/* get the node with the minimum key in a subtree of the red-black tree */
static inline rbtree_node_t*
rbtree_subtree_min(rbtree_node_t* node, rbtree_node_t* sentinel)
&#123;
    while(node-&gt;left != sentinel)
    &#123;
        node = node-&gt;left;
    &#125;

    return node;
&#125;

/* replace the node &quot;node&quot; in the tree with node &quot;tmp&quot; */
static inline void rbtree_replace(rbtree_t* tree,
    rbtree_node_t* node, rbtree_node_t* tmp)
&#123;
    /* upward: p[node] &lt;- p[tmp] */
    tmp-&gt;parent = node-&gt;parent;

    if (node == tree-&gt;root)
    &#123;
        tree-&gt;root = tmp;
    &#125;
    else if (node == node-&gt;parent-&gt;left)
    &#123;
        /* downward: left[p[node]] &lt;- tmp */
        node-&gt;parent-&gt;left = tmp;
    &#125;
    else
    &#123;
        /* downward: right[p[node]] &lt;- tmp */
        node-&gt;parent-&gt;right = tmp;
    &#125;

    node-&gt;parent = tmp;
&#125;

/* change the topologic structure of the tree keeping the order of the nodes */
static inline void rbtree_left_rotate(rbtree_t* tree, rbtree_node_t* node)
&#123;
    /* node as the var x in CLRS while tmp as the var y */
    rbtree_node_t* tmp = node-&gt;right;

    /* fix node_cnt */
    node-&gt;node_cnt = node-&gt;left-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;
    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;

    /* replace y with left[y] */
    /* downward: right[x] &lt;- left[y] */
    node-&gt;right = tmp-&gt;left;
    /* if left[[y] is not NIL it has a parent */
    if (tmp-&gt;left != tree-&gt;sentinel)
    &#123;
        /* upward: p[left[y]] &lt;- x */
        tmp-&gt;left-&gt;parent = node;
    &#125;

    /* replace x with y */
    rbtree_replace(tree, node, tmp);
    tmp-&gt;left = node;
&#125;

static inline void rbtree_right_rotate(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* tmp = node-&gt;left;

    /* fix node_cnt */
    node-&gt;node_cnt = node-&gt;right-&gt;node_cnt + tmp-&gt;right-&gt;node_cnt + 1;
    tmp-&gt;node_cnt = node-&gt;node_cnt + tmp-&gt;left-&gt;node_cnt + 1;

    /* replace y with right[y] */
    node-&gt;left = tmp-&gt;right;
    if (tmp-&gt;right != tree-&gt;sentinel)
    &#123;
        tmp-&gt;right-&gt;parent = node;
    &#125;

    /* replace x with y */
    rbtree_replace(tree, node, tmp);
    tmp-&gt;right = node;
&#125;

/* static methods */
/* fix the red-black tree after the new node inserted */
static void rbtree_insert_fixup(rbtree_t* tree, rbtree_node_t* node)
&#123;
    while(rbtree_is_red(node-&gt;parent))
    &#123;
        if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)
        &#123;
            /* case 1: node&#39;s uncle is red */
            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;right))
            &#123;
                rbtree_black(node-&gt;parent);
                rbtree_black(node-&gt;parent-&gt;parent-&gt;right);
                rbtree_red(node-&gt;parent-&gt;parent);
                node = node-&gt;parent-&gt;parent;
                /* Then we can consider the whole subtree */
                /* which is represented by the new &quot;node&quot; as the &quot;node&quot; before */
                /* and keep looping till &quot;node&quot; become the root. */
            &#125;
            /* case 2: node&#39;s uncle is black */
            else
            &#123;
                /* ensure node is the left kid of its parent */
                if (node == node-&gt;parent-&gt;right)
                &#123;
                    node = node-&gt;parent;
                    rbtree_left_rotate(tree, node);
                &#125;
                /* case 2 -&gt; case 1 */
                rbtree_black(node-&gt;parent);
                rbtree_red(node-&gt;parent-&gt;parent);
                rbtree_right_rotate(tree, node-&gt;parent-&gt;parent);
            &#125;
        &#125;
        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */
        else
        &#123;
            if (rbtree_is_red(node-&gt;parent-&gt;parent-&gt;left))
            &#123;
                rbtree_black(node-&gt;parent);
                rbtree_black(node-&gt;parent-&gt;parent-&gt;left);
                rbtree_red(node-&gt;parent-&gt;parent);
                node = node-&gt;parent-&gt;parent;
            &#125;
            else
            &#123;
                if (node == node-&gt;parent-&gt;left)
                &#123;
                    node = node-&gt;parent;
                    rbtree_right_rotate(tree, node);
                &#125;
                rbtree_black(node-&gt;parent);
                rbtree_red(node-&gt;parent-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent-&gt;parent);
            &#125;
        &#125;
    &#125;
    /* ensure the root node being black */
    rbtree_black(tree-&gt;root);
&#125;

static void rbtree_delete_fixup(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* brother = NULL;

    while(node != tree-&gt;root &amp;&amp; rbtree_is_black(node))
    &#123;
        if (node == node-&gt;parent-&gt;left)
        &#123;
            brother = node-&gt;parent-&gt;right;
            if (rbtree_is_red(brother))
            &#123;
                rbtree_black(brother);
                rbtree_red(node-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent);
                /* update brother after topologic change of the tree */
                brother = node-&gt;parent-&gt;right;
            &#125;

            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))
            &#123;
                rbtree_red(brother);
                /* go upward and keep on fixing color */
                node = node-&gt;parent;
            &#125;
            else
            &#123;
                if (rbtree_is_black(brother-&gt;right))
                &#123;
                    rbtree_black(brother-&gt;left);
                    rbtree_red(brother);
                    rbtree_right_rotate(tree, brother);
                    /* update brother after topologic change of the tree */
                    brother = node-&gt;parent-&gt;right;
                &#125;
                rbtree_copy_color(brother, node-&gt;parent);
                rbtree_black(node-&gt;parent);
                rbtree_black(brother-&gt;right);
                rbtree_left_rotate(tree, node-&gt;parent);
                /* end the loop and ensure root is black */
                node = tree-&gt;root;
            &#125;
        &#125;
        /* same as the &quot;if&quot; clause before with &quot;left&quot; and &quot;right&quot; exchanged */
        else
        &#123;
            brother = node-&gt;parent-&gt;left;
            if (rbtree_is_red(brother))
            &#123;
                rbtree_black(brother);
                rbtree_red(node-&gt;parent);
                rbtree_left_rotate(tree, node-&gt;parent);
                brother = node-&gt;parent-&gt;left;
            &#125;

            if (rbtree_is_black(brother-&gt;left) &amp;&amp; rbtree_is_black(brother-&gt;right))
            &#123;
                rbtree_red(brother);
                node = node-&gt;parent;
            &#125;
            else
            &#123;
                if (rbtree_is_black(brother-&gt;left))
                &#123;
                    rbtree_black(brother-&gt;right);
                    rbtree_red(brother);
                    rbtree_right_rotate(tree, brother);
                    brother = node-&gt;parent-&gt;left;
                &#125;
                rbtree_copy_color(brother, node-&gt;parent);
                rbtree_black(node-&gt;parent);
                rbtree_black(brother-&gt;left);
                rbtree_left_rotate(tree, node-&gt;parent);
                node = tree-&gt;root;
            &#125;
        &#125;
    &#125;

    rbtree_black(node);
&#125;

/* public methods */
void rbtree_insert_value(rbtree_t* tree, rbtree_node_t* node)
&#123;
    /* Using ** to know wether the new node will be a left kid */
    /* or a right kid of its parent node. */
    rbtree_node_t** tmp = &amp;tree-&gt;root;
    rbtree_node_t* parent;

    while(*tmp != tree-&gt;sentinel)
    &#123;
        parent = *tmp;

        /* update node_cnt */
        (parent-&gt;node_cnt)++;

        tmp = (node-&gt;key &lt; parent-&gt;key) ? &amp;parent-&gt;left : &amp;parent-&gt;right;
    &#125;

    /* The pointer knows wether the node should be on the left side */
    /* or on the right one. */
    *tmp = node;
    node-&gt;parent = parent;
    node-&gt;left = tree-&gt;sentinel;
    node-&gt;right = tree-&gt;sentinel;
    rbtree_red(node);
&#125;

void rbtree_visit(rbtree_node_t* node)
&#123;
    /* visiting the current node */
&#125;

void rbtree_insert(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* sentinel = tree-&gt;sentinel;

    /* if the tree is empty */
    if (tree-&gt;root == sentinel)
    &#123;
        tree-&gt;root = node;
        node-&gt;parent = sentinel;
        node-&gt;left = sentinel;
        node-&gt;right = sentinel;
        rbtree_black(node);

        return;
    &#125;

    /* generally */
    tree-&gt;insert(tree, node);
    rbtree_insert_fixup(tree, node);
&#125;

void rbtree_delete(rbtree_t* tree, rbtree_node_t* node)
&#123;
    rbtree_node_t* sentinel = tree-&gt;sentinel;
    /* wether &quot;node&quot; is on the left side or the right one */
    rbtree_node_t** ptr_to_node = NULL;
    /* &quot;cover&quot; is the node which is going to cover &quot;node&quot; */
    rbtree_node_t* cover = NULL;
    /* wether we lossing a red node on the edge of the tree */
    int loss_red = rbtree_is_red(node);
    int is_root = (node == tree-&gt;root);

    /* get &quot;cover&quot; &amp; &quot;loss_red&quot;  */
    /* sentinel in &quot;node&quot;&#39;s kids */
    if (node-&gt;left == sentinel)
    &#123;
        cover = node-&gt;right;
    &#125;
    else if (node-&gt;right == sentinel)
    &#123;
        cover = node-&gt;left;
    &#125;
    /* &quot;node&quot;&#39;s kids are both non-sentinel */
    else
    &#123;
        /* update &quot;node&quot; &amp; &quot;loss_red&quot; &amp; &quot;is_root&quot; &amp; &quot;cover&quot; */
        cover = rbtree_subtree_min(node-&gt;right, sentinel);
        node-&gt;key = cover-&gt;key;
        node-&gt;value = cover-&gt;value;
        node = cover;
        loss_red = rbtree_is_red(node);
        is_root = 0;
        /* move &quot;cover&quot;&#39;s kids */
        /* &quot;cover&quot; can only be a left kid */
        /* and can only have a right non-sentinel kid */
        /* because of function &quot;rbtree_subtree_min&quot; */
        cover = node-&gt;right;
    &#125;

    if (is_root)
    &#123;
        /* update root */
        tree-&gt;root = cover;
    &#125;
    else
    &#123;
        /* downward link */
        if (node == node-&gt;parent-&gt;left)
        &#123;
            node-&gt;parent-&gt;left = cover;
        &#125;
        else
        &#123;
            node-&gt;parent-&gt;right = cover;
        &#125;
    &#125;
    /* upward link */
    cover-&gt;parent = node-&gt;parent;
    /* &quot;cover&quot; may be a sentinel */
    if (cover != sentinel)
    &#123;
        /* set &quot;cover&quot; */
        cover-&gt;left = node-&gt;left;
        cover-&gt;right = node-&gt;right;
        rbtree_copy_color(cover, node);
    &#125;

    /* clear &quot;node&quot; since it&#39;s useless */
    node-&gt;key = -1;
    node-&gt;parent = NULL;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    node-&gt;value = NULL;

    /* update node_cnt */
    rbtree_node_t* tmp = cover-&gt;parent;
    while(tmp != sentinel)
    &#123;
        (tmp-&gt;node_cnt)--;
        tmp = tmp-&gt;parent;
    &#125;

    if (loss_red)
    &#123;
        return;
    &#125;

    /* When lossing a black node on edge */
    /* the fifth rule of red-black tree will be broke. */
    /* So the tree need to be fixed. */
    rbtree_delete_fixup(tree, cover);
&#125;

/* find the node in the tree corresponding to the given key value */
rbtree_node_t* rbtree_find(rbtree_t* tree, rbtree_key_t key)
&#123;
    rbtree_node_t* tmp = tree-&gt;root;
    /* next line is just fot test */
    // int step_cnt = 0;

    /* search the binary tree */
    while(tmp != tree-&gt;sentinel)
    &#123;
        /* next line is just fot test */
        // step_cnt++;
        if(key == tmp-&gt;key)
        &#123;
            /* next line is just for test */
            // printf(&quot;step count: %d, color: %s, &quot;, step_cnt, rbtree_is_red(tmp) ? &quot;red&quot; : &quot;black&quot;);
            return tmp;
        &#125;

        tmp = (key &lt; tmp-&gt;key) ? tmp-&gt;left : tmp-&gt;right;
    &#125;

    return NULL;
&#125;

/* find the node in the tree corresponding to the given order number */
rbtree_node_t* rbtree_index(rbtree_t* tree, int index)
&#123;
    if (index &lt; 0 || index &gt;= rbtree_count(tree))
    &#123;
        return NULL;
    &#125;

    rbtree_node_t* tmp = tree-&gt;root;
    int left_cnt = 0;
    int sub_left_cnt;

    while(tmp-&gt;node_cnt &gt; 0)
    &#123;
        sub_left_cnt = tmp-&gt;left-&gt;node_cnt;
        if (left_cnt + sub_left_cnt == index)
        &#123;
            return tmp;
        &#125;

        if (left_cnt + sub_left_cnt &lt; index)
        &#123;
            left_cnt += sub_left_cnt + 1;
            tmp = tmp-&gt;right;
        &#125;
        else
        &#123;
            tmp = tmp-&gt;left;
        &#125;
    &#125;
&#125;

/* get the height of the subtree */
int rbtree_height(rbtree_t* tree, rbtree_node_t* node)
&#123;
    if (node == tree-&gt;sentinel)
    &#123;
        return 0;
    &#125;

    int left_height = rbtree_height(tree, node-&gt;left);
    int right_height = rbtree_height(tree, node-&gt;right);
    int sub_height = (left_height &gt; right_height) ? left_height : right_height;
    return sub_height+1;
&#125;

/* get the count of nodes in the tree */
int rbtree_count(rbtree_t* tree)
&#123;
    return tree-&gt;root-&gt;node_cnt;
&#125;

/* visit every node of the subtree whose root is given in order */
void rbtree_traversal(rbtree_t* tree, rbtree_node_t* node, rbtree_visit_p visit)
&#123;
    if (node != tree-&gt;sentinel)
    &#123;
        rbtree_traversal(tree, node-&gt;left, visit);
        visit(node);
        rbtree_traversal(tree, node-&gt;right, visit);
    &#125;
&#125;
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 还是做个压力测试。<br>&nbsp;&nbsp;&nbsp; test.c：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &quot;rbtree.h&quot;

int main(int argc, char const *argv[])
&#123;
    double duration;
    double room;

    rbtree_t t = &#123;&#125;;
    rbtree_node_t s = &#123;&#125;;
    rbtree_init(&amp;t, &amp;s, rbtree_insert_value);

    const int cnt = 1&lt;&lt;20;
    const int max_len = 15;

#define TEST_VALUES &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;grape&quot;, &quot;lemon&quot;, &quot;mango&quot;, &quot;pear&quot;, &quot;pineapple&quot;, &quot;strawberry&quot;, &quot;watermelon&quot;&#125;

    /* for gcc */
    char* v[] = TEST_VALUES;
    /* for g++ */
    // char v[][max_len] = TEST_VALUES;

    /* Default stack size in Ubuntu Kylin 14.04 is 8MB. */
    /* It&#39;s not enough. So I use memory in heap which offers a lot larger room. */
    rbtree_node_t* n = (rbtree_node_t*)calloc(cnt, sizeof(rbtree_node_t));
    int i;

    long time1 = clock();

    for (i = 0; i &lt; cnt; i++)
    &#123;
        n[i].key = i+1;
        n[i].value = v[i%10];
        n[i].node_cnt = 1;
        rbtree_insert(&amp;t, &amp;n[i]);
    &#125;

    srand( (unsigned int)time(0) );
    int no = rand()%cnt;
    printf(&quot;n[%d]-&gt;key = %d\n&quot;, no, rbtree_index(&amp;t, no)-&gt;key);

    long time2 = clock();
    room = 48.0*cnt/(1&lt;&lt;20);
    duration = (double)(time2 - time1) / CLOCKS_PER_SEC;
    printf(&quot;Inserting %d nodes costs %.2fMB and spends %f seconds.\n&quot;, cnt, room, duration);

    const int search_cnt = 1&lt;&lt;10;
    for( i = 0 ; i &lt; search_cnt ; i++ )
    &#123;
        rbtree_find(&amp;t, (rand()%cnt)+1);
    &#125;

    long time3 = clock();
    duration = (double)(time3 - time2) / CLOCKS_PER_SEC;
    printf(&quot;Searching %d nodes among %d spends %f seconds.\n&quot;, search_cnt, cnt, duration);

    const int index_cnt = 1&lt;&lt;10;
    for( i = 0 ; i &lt; index_cnt ; i++ )
    &#123;
        rbtree_index(&amp;t, (rand()%cnt));
    &#125;

    long time4 = clock();
    duration = (double)(time4 - time3) / CLOCKS_PER_SEC;
    printf(&quot;Indexing %d nodes among %d spends %f seconds.\n&quot;, index_cnt, cnt, duration);

    const int delete_cnt = 1&lt;&lt;10;
    int nums[delete_cnt];
    int num;
    /* Let&#39;s hash! */
    char* mark = (char*)calloc(cnt, sizeof(char));
    memset(mark, 0, cnt*sizeof(char));
    for(i = 0; i &lt; delete_cnt; i++)
    &#123;
        for(;;)
        &#123;
            num = rand()%cnt;
            if (mark[num] == 0)
            &#123;
                mark[num] = 1;
                nums[i] = num;
                break;
            &#125;
        &#125;
    &#125;

    long time5 = clock();
    duration = (double)(time5 - time4) / CLOCKS_PER_SEC;
    printf(&quot;Hash %d times spends %f seconds.\n&quot;, delete_cnt, duration);

    for(i = 0; i &lt; delete_cnt; i++)
    &#123;
        rbtree_delete(&amp;t, &amp;n[nums[i]]);
    &#125;

    long time6 = clock();
    duration = (double)(time6 - time5) / CLOCKS_PER_SEC;
    printf(&quot;Deleting %d nodes among %d spends %f seconds.\n&quot;, delete_cnt, cnt, duration);
    free(mark);

    int h = rbtree_height(&amp;t, t.root);
    long time7 = clock();
    duration = (double)(time7 - time6) / CLOCKS_PER_SEC;
    printf(&quot;The height of the tree is %d. Getting it spends %f seconds.\n&quot;, h, duration);

    rbtree_traversal(&amp;t, t.root, rbtree_visit);
    long time8 = clock();
    duration = (double)(time8 - time7) / CLOCKS_PER_SEC;
    printf(&quot;Traversal the tree spends %f seconds.\n&quot;, duration);

    printf(&quot;Count of nodes in the tree is %d.\n&quot;, rbtree_count(&amp;t));

    free(n);

    return 0;
&#125;
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 上一个版本的压力测试结果：</p>
<pre><code class="hljs">Inserting 1048576 nodes costs 48.00MB and spends 0.425416 seconds.
Searching 1024 nodes among 1048576 spends 0.001140 seconds.
Hash 1024 times spends 0.000334 seconds.
Deleting 1024 nodes among 1048576 spends 0.000783 seconds.
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 扩展版本的压力测试结果：</p>
<pre><code class="hljs">Inserting 1048576 nodes costs 48.00MB and spends 0.467859 seconds.
Searching 1024 nodes among 1048576 spends 0.001188 seconds.
Indexing 1024 nodes among 1048576 spends 0.001484 seconds.
Hash 1024 times spends 0.000355 seconds.
Deleting 1024 nodes among 1048576 spends 0.001417 seconds.
The height of the tree is 28. Getting it spends 0.021669 seconds.
Traversal the tree spends 0.023913 seconds.
Count of nodes in the tree is 1047552.
</code></pre>
<p>&nbsp;&nbsp;&nbsp; 比较一下可以发现：<br>&nbsp;&nbsp;&nbsp; 1.插入结点略慢了一点，因为插入时多维护了一个node_cnt项。<br>&nbsp;&nbsp;&nbsp; 2.按key查找结点速度没有变化。<br>&nbsp;&nbsp;&nbsp; 3.哈希查找速度没有变化。<br>&nbsp;&nbsp;&nbsp; 4.删除结点花的时间几乎是原来的两倍，因为每次删除后都要一路向上更新node_cnt，几乎相当于包含了一次按key查询。<br>&nbsp;&nbsp;&nbsp; 5.按序号查询比按key查询略慢，因为每次进入右子树需要多做一次加法。<br>&nbsp;&nbsp;&nbsp; 6.遍历花的时间与求树高相同，因为它们的实质都是遍历树，时间效率O(n)数量级，具体点为2n次结点访问，分别为结点入栈和出栈时。<br>&nbsp;&nbsp;&nbsp; 别问我max、min、mid在哪，能按序号查询了这些还是问题吗？</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/nginx/" class="category-chain-item">nginx</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/nginx/" class="print-no-link">#nginx</a>
      
        <a href="/tags/rbtree/" class="print-no-link">#rbtree</a>
      
        <a href="/tags/C/" class="print-no-link">#C</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【五】nginx的数据结构(3)——扩展红黑树</div>
      <div>https://bipedalbit.net/2015/08/18/【五】nginx的数据结构-3-——扩展红黑树/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Bipedal Bit</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2015年8月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2015/09/06/node-js%E7%9A%84-Cannot-enqueue-Handshake-after-invoking-quit-%E9%94%99%E8%AF%AF/" title="node.js的&#39;Cannot enqueue Handshake after invoking quit&#39;错误">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">node.js的&#39;Cannot enqueue Handshake after invoking quit&#39;错误</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2015/08/16/Linux%E4%B8%8BSublime%E7%9A%84C-C-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8FMakefile-%E6%B8%85%E7%90%86-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE/" title="Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置">
                        <span class="hidden-mobile">Linux下Sublime的C/C++多文件程序Makefile+清理+执行配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline.bipedalbit.net","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <div style="text-align: center;">
  当前页面浏览量: <span class="waline-pageview-count"></span>
</div>
<script type="module">
  import { pageviewCount } from 'https://unpkg.com/@waline/client@v3/dist/pageview.js';

  pageviewCount({
    serverURL: 'https://comment-plugin.bipedalbit.net/',
    path: window.location.pathname,
    // 可选配置项
    // selector: 'waline-pageview-count',
    // update: true,
  });

  // 等待数据加载完成，检查 span 内容是否为空
  setTimeout(() => {
    const span = document.querySelector('.waline-pageview-count');
    if (!span.textContent.trim()) {
      span.textContent = '1';
    }
  }, 1000); // 1秒后执行，确保数据加载完成
</script>

        </div>
      </div>
    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d = OML2D.loadOml2d({libraryUrls:{"complete":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/complete.js","cubism2":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism2.js","cubism5":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js"},mobileDisplay:true,models:[{"path":"https://cdn.minio.bipedalbit.net/bipedalbit-net-images/live2d-model/HK416-2-destroy/model.json","mobilePosition":[0,-45],"mobileScale":0.06,"mobileStageStyle":{"width":200,"height":240},"motionPreloadStrategy":"IDLE","position":[0,-60],"scale":0.08,"stageStyle":{"width":250,"height":300}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":200,"height":80,"left":"calc(50% - 10px)","top":"-100px"},mobileStyle: {"width":180,"height":60,"left":"calc(50% - 5px)","top":"-100px"},idleTips:{interval:30000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
,wordTheDay:true}}});</script><!-- hexo injector body_end end --></body>
</html>
